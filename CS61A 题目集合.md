# CS61A È¢òÁõÆÈõÜÂêà

## ËøõÂ∫¶ üí™

|          |                                                              |                                                              |                                                              |      |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ---- |
| Wed 2/21 | ~~Mutable Functions~~ [Video](https://www.youtube.com/watch?v=mR8HufhOq0o&list=PL6BsET-8jgYX65Qx8DP2ColF_ldpgScu8&vq=hd1080) [full](https://inst.eecs.berkeley.edu//~cs61a/sp18/assets/slides/14-Mutable_Functions_full.pdf) [1pp](https://inst.eecs.berkeley.edu//~cs61a/sp18/assets/slides/14-Mutable_Functions_1pp.pdf) [8pp](https://inst.eecs.berkeley.edu//~cs61a/sp18/assets/slides/14-Mutable_Functions_8pp.pdf) [14.py](https://inst.eecs.berkeley.edu//~cs61a/sp18/assets/slides/14.py) | [2.4](http://composingprograms.com/pages/24-mutable-data.html) | [~~Disc 04: Nonlocals & Mutation~~](https://inst.eecs.berkeley.edu//~cs61a/sp18/disc/disc04.pdf) [~~Slides~~](https://drive.google.com/open?id=1wDrrOWceDTsnkcDJ-earES0yktscb8eI) [Exam Prep 03: Lists, Trees, & Tree Recursion](https://inst.eecs.berkeley.edu//~cs61a/sp18/assets/pdfs/exam_prep03.pdf) |      |
| Fri 2/23 | ~~Objects~~ [Video](https://www.youtube.com/watch?v=AseSKWY6To0&index=1&list=PL6BsET-8jgYUIiXSvk-fKPZD13EyQOt0O&vq=hd1080) [full](https://inst.eecs.berkeley.edu//~cs61a/sp18/assets/slides/15-Objects_full.pdf) [1pp](https://inst.eecs.berkeley.edu//~cs61a/sp18/assets/slides/15-Objects_1pp.pdf) [8pp](https://inst.eecs.berkeley.edu//~cs61a/sp18/assets/slides/15-Objects_8pp.pdf) [15.py](https://inst.eecs.berkeley.edu//~cs61a/sp18/assets/slides/15.py) | [2.5](http://composingprograms.com/pages/25-object-oriented-programming.html) |                                                              |      |

#### week 7

|          |                                                              |                                                              |                                                              |                                                              |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| Mon 2/26 | ~~Inheritance~~ [Video](https://www.youtube.com/watch?v=WBBcuIlM2iE&list=PL6BsET-8jgYUQ_XExDUYYQPd00ErJ6ELL&vq=hd1080) [full](https://inst.eecs.berkeley.edu//~cs61a/sp18/assets/slides/16-Inheritance_full.pdf) [1pp](https://inst.eecs.berkeley.edu//~cs61a/sp18/assets/slides/16-Inheritance_1pp.pdf) [8pp](https://inst.eecs.berkeley.edu//~cs61a/sp18/assets/slides/16-Inheritance_8pp.pdf) [16.py](https://inst.eecs.berkeley.edu//~cs61a/sp18/assets/slides/16.py) | [2.5](http://composingprograms.com/pages/25-object-oriented-programming.html) | [~~Lab 06: Object Oriented Programming~~](https://inst.eecs.berkeley.edu//~cs61a/sp18/lab/lab06/) Fri 3/2 [~~CSM 03: Mutation and Nonlocal~~](https://inst.eecs.berkeley.edu//~cs61a/sp18/assets/pdfs/mentor03.pdf) | [~~Ants~~](https://inst.eecs.berkeley.edu//~cs61a/sp18/proj/ants) Thu 3/8 |
| Wed 2/28 | ~~Representation~~ [Video](https://www.youtube.com/watch?v=KG30mBLs4j8&list=PL6BsET-8jgYWUwZ42xtrbX04mSx7GMHUo&vq=hd1080) [full](https://inst.eecs.berkeley.edu//~cs61a/sp18/assets/slides/17-Representation_full.pdf) [1pp](https://inst.eecs.berkeley.edu//~cs61a/sp18/assets/slides/17-Representation_1pp.pdf) [8pp](https://inst.eecs.berkeley.edu//~cs61a/sp18/assets/slides/17-Representation_8pp.pdf) [17.py](https://inst.eecs.berkeley.edu//~cs61a/sp18/assets/slides/17.py) | [2.7](http://composingprograms.com/pages/27-object-abstraction.html) | [~~Disc 05: Object Oriented Programming~~](https://inst.eecs.berkeley.edu//~cs61a/sp18/disc/disc05.pdf) [~~Slides~~](https://drive.google.com/open?id=1tV7Y2RQ70O-SKbt7DvPn4Rs2egp2azId) [Exam Prep 04: List Mutation, Dictionaries, & More Trees](https://inst.eecs.berkeley.edu//~cs61a/sp18/assets/pdfs/exam_prep04.pdf) |                                                              |
| Fri 3/2  | ~~Growth~~ [Video](https://www.youtube.com/watch?v=oXpf9k1ip4o&list=PL6BsET-8jgYX5-rjCovKDAwPQHkiCwvEU&vq=hd1080) [full](https://inst.eecs.berkeley.edu//~cs61a/sp18/assets/slides/18-Growth_full.pdf) [1pp](https://inst.eecs.berkeley.edu//~cs61a/sp18/assets/slides/18-Growth_1pp.pdf) [8pp](https://inst.eecs.berkeley.edu//~cs61a/sp18/assets/slides/18-Growth_8pp.pdf) [18.py](https://inst.eecs.berkeley.edu//~cs61a/sp18/assets/slides/18.py) [18.ipynb](https://inst.eecs.berkeley.edu//~cs61a/sp18/assets/slides/18.ipynb) | [2.8](http://composingprograms.com/pages/28-efficiency.html) |                                                              | [~~HW 06~~](https://inst.eecs.berkeley.edu//~cs61a/sp18/hw/hw06/) Thu 3/8 |

#### week 8

|         |                                                              |                                                              |                                                              |                                                              |
| ------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| Mon 3/5 | ~~Composition~~ [Video](https://www.youtube.com/watch?v=qvKIxFG8UVI&list=PL6BsET-8jgYWKyc-ouo_hTpzAWtwCPPxa&vq=hd1080) [full](https://inst.eecs.berkeley.edu//~cs61a/sp18/assets/slides/19-Composition_full.pdf) [1pp](https://inst.eecs.berkeley.edu//~cs61a/sp18/assets/slides/19-Composition_1pp.pdf) [8pp](https://inst.eecs.berkeley.edu//~cs61a/sp18/assets/slides/19-Composition_8pp.pdf) [19.py](https://inst.eecs.berkeley.edu//~cs61a/sp18/assets/slides/19.py) | [2.9](http://composingprograms.com/pages/29-recursive-objects.html) | [~~Lab 07: Recursive Objects~~](https://inst.eecs.berkeley.edu//~cs61a/sp18/lab/lab07/) Fri 3/9 [CSM 04: OOP and OOG](https://inst.eecs.berkeley.edu//~cs61a/sp18/assets/pdfs/mentor04.pdf) |                                                              |
| Wed 3/7 | ~~Ordered Sets~~ [Video](https://www.youtube.com/watch?v=9NQ9pZsiZx0&list=PL6BsET-8jgYXzWgS7H0xgwXoAfE_oc5Qb&vq=hd1080) [full](https://inst.eecs.berkeley.edu//~cs61a/sp18/assets/slides/20-Ordered_Sets_full.pdf) [1pp](https://inst.eecs.berkeley.edu//~cs61a/sp18/assets/slides/20-Ordered_Sets_1pp.pdf) [8pp](https://inst.eecs.berkeley.edu//~cs61a/sp18/assets/slides/20-Ordered_Sets_8pp.pdf) [20.py](https://inst.eecs.berkeley.edu//~cs61a/sp18/assets/slides/20.py) | [2.9](http://composingprograms.com/pages/29-recursive-objects.html) | [Disc 06: Growth & Linked Lists](https://inst.eecs.berkeley.edu//~cs61a/sp18/disc/disc06.pdf) [Slides](https://drive.google.com/open?id=19l8ItnWhBpO_yAhqibIPVKySW-UORuJv) [Exam Prep 05: Nonlocal and Object-Oriented Programming](https://inst.eecs.berkeley.edu//~cs61a/sp18/assets/pdfs/exam_prep05.pdf) |                                                              |
| Fri 3/9 | ~~Tree Sets~~ [Video](https://www.youtube.com/watch?v=lfbOtez2l7c&list=PL6BsET-8jgYW4UWd5R37kQycegdTdIhsS&vq=hd1080) [full](https://inst.eecs.berkeley.edu//~cs61a/sp18/assets/slides/21-Tree_Sets_full.pdf) [1pp](https://inst.eecs.berkeley.edu//~cs61a/sp18/assets/slides/21-Tree_Sets_1pp.pdf) [8pp](https://inst.eecs.berkeley.edu//~cs61a/sp18/assets/slides/21-Tree_Sets_8pp.pdf) [21.py](https://inst.eecs.berkeley.edu//~cs61a/sp18/assets/slides/21.py) | [2.9](http://composingprograms.com/pages/29-recursive-objects.html) |                                                              | [~~HW 07~~](https://inst.eecs.berkeley.edu//~cs61a/sp18/hw/hw07/) Tue 3/13 |

#### week 9

|          |                                                              |      |                                                              |                                                              |
| -------- | ------------------------------------------------------------ | ---- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| Mon 3/12 | ~~Data Examples~~ [Video](https://www.youtube.com/watch?v=TuYCkA_DyMY&list=PL6BsET-8jgYWRTU90CoXS2iWz_USTRL0c&vq=hd1080) [full](https://inst.eecs.berkeley.edu//~cs61a/sp18/assets/slides/22-Data_Examples_full.pdf) [1pp](https://inst.eecs.berkeley.edu//~cs61a/sp18/assets/slides/22-Data_Examples_1pp.pdf) [8pp](https://inst.eecs.berkeley.edu//~cs61a/sp18/assets/slides/22-Data_Examples_8pp.pdf) [22.py](https://inst.eecs.berkeley.edu//~cs61a/sp18/assets/slides/22.py) |      | [~~Lab 08: Midterm Review~~](https://inst.eecs.berkeley.edu//~cs61a/sp18/lab/lab08/) Fri 3/16 [CSM 05: Linked Lists and Midterm Review](https://inst.eecs.berkeley.edu//~cs61a/sp18/assets/pdfs/mentor05.pdf) |                                                              |
| Wed 3/14 | No Lecture: Midterm 2 is the next day                        |      | [Exam Prep 06: Orders of Growth and Linked Lists](https://inst.eecs.berkeley.edu//~cs61a/sp18/assets/pdfs/exam_prep06.pdf) |                                                              |
| Thu 3/15 | [Midterm 2](https://inst.eecs.berkeley.edu//~cs61a/sp18/exams/midterm2.html) |      |                                                              |                                                              |
| Fri 3/16 | ~~Users~~ [Video](https://www.youtube.com/watch?v=u3WMWdhfx3U&list=PL6BsET-8jgYUlSbq0p54SmIzZ2JYPXGts&vq=hd1080) |      |                                                              | [~~HW 0~~8](https://inst.eecs.berkeley.edu//~cs61a/sp18/hw/hw08/) Thu 3/22 |

#### week  10

|          |                                                              |                                                              |                                                              |                                                              |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| Mon 3/19 | ~~Scheme~~ [Video](https://www.youtube.com/watch?v=NSg0RdR-uFU&list=PL6BsET-8jgYXpPFbGypFn_9k_2nuVs5M6&vq=hd1080) [full](https://inst.eecs.berkeley.edu//~cs61a/sp18/assets/slides/24-Scheme_full.pdf) [1pp](https://inst.eecs.berkeley.edu//~cs61a/sp18/assets/slides/24-Scheme_1pp.pdf) [8pp](https://inst.eecs.berkeley.edu//~cs61a/sp18/assets/slides/24-Scheme_8pp.pdf) [24.scm](https://inst.eecs.berkeley.edu//~cs61a/sp18/assets/slides/24.scm) | [3.1](http://composingprograms.com/pages/31-introduction.html) [3.2](http://composingprograms.com/pages/32-functional-programming.html) | [~~Lab 09: Scheme~~](https://inst.eecs.berkeley.edu//~cs61a/sp18/lab/lab09/) Fri 3/23 [~~CSM 06: Introduction to Scheme~~](https://inst.eecs.berkeley.edu//~cs61a/sp18/assets/pdfs/mentor06.pdf) |                                                              |
| Wed 3/21 | ~~Exceptions~~ [~~Video~~](https://www.youtube.com/watch?v=gDC5c44X8r0&list=PL6BsET-8jgYU4BjMjrgB9tLdViW9pEDGX&vq=hd1080) [full](https://inst.eecs.berkeley.edu//~cs61a/sp18/assets/slides/25-Exceptions_full.pdf) [1pp](https://inst.eecs.berkeley.edu//~cs61a/sp18/assets/slides/25-Exceptions_1pp.pdf) [8pp](https://inst.eecs.berkeley.edu//~cs61a/sp18/assets/slides/25-Exceptions_8pp.pdf) [25.py](https://inst.eecs.berkeley.edu//~cs61a/sp18/assets/slides/25.py) [25.scm](https://inst.eecs.berkeley.edu//~cs61a/sp18/assets/slides/25.scm) | [3.3](http://composingprograms.com/pages/33-exceptions.html) | [Disc 07: Scheme](https://inst.eecs.berkeley.edu//~cs61a/sp18/disc/disc07.pdf) [Slides](https://drive.google.com/open?id=1Fn-O14s6fPt_RCcrrm6LpT_cf0zjicI4) |                                                              |
| Fri 3/23 | ~~Calculator~~ [~~Video~~](https://www.youtube.com/watch?v=FXO5XbTU3OE&list=PL6BsET-8jgYVovQvtP3PvcfVbjAC1jYST&vq=hd1080) [full](https://inst.eecs.berkeley.edu//~cs61a/sp18/assets/slides/26-Calculator_full.pdf) [1pp](https://inst.eecs.berkeley.edu//~cs61a/sp18/assets/slides/26-Calculator_1pp.pdf) [8pp](https://inst.eecs.berkeley.edu//~cs61a/sp18/assets/slides/26-Calculator_8pp.pdf) [26.scm](https://inst.eecs.berkeley.edu//~cs61a/sp18/assets/slides/26.scm) | [3.4](http://composingprograms.com/pages/34-interpreters-for-languages-with-combination.html) |                                                              | [~~HW 09~~](https://inst.eecs.berkeley.edu//~cs61a/sp18/hw/hw09/) Thu 4/5 |

#### week  12

|         |                                                              |                                                              |                                                              |                                                              |
| ------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| Mon 4/2 | ~~Interpreters~~ [~~Video~~](https://www.youtube.com/watch?v=1hGO8KOELQk&list=PL6BsET-8jgYWkNhlFFR3S-110mYMrIBsM&vq=hd1080) [full](https://inst.eecs.berkeley.edu/~cs61a/sp18/assets/slides/27-Interpreters_full.pdf) [1pp](https://inst.eecs.berkeley.edu/~cs61a/sp18/assets/slides/27-Interpreters_1pp.pdf) [8pp](https://inst.eecs.berkeley.edu/~cs61a/sp18/assets/slides/27-Interpreters_8pp.pdf) | [3.5](http://composingprograms.com/pages/35-interpreters-for-languages-with-abstraction.html) | [~~Lab 10: Interpreters~~](https://inst.eecs.berkeley.edu/~cs61a/sp18/lab/lab10/) Fri 4/6 [CSM 07: More Scheme](https://inst.eecs.berkeley.edu/~cs61a/sp18/assets/pdfs/mentor07.pdf) | [Scheme](https://inst.eecs.berkeley.edu/~cs61a/sp18/proj/scheme) Tue 4/17 |
| Wed 4/4 | ~~Tail Calls~~ [Video](https://www.youtube.com/watch?v=F_xCxCe3GPA&list=PL6BsET-8jgYUA7ovVQOPdh0pcN2q8V-OF&vq=hd1080) [full](https://inst.eecs.berkeley.edu/~cs61a/sp18/assets/slides/28-Tail_Calls_full.pdf) [1pp](https://inst.eecs.berkeley.edu/~cs61a/sp18/assets/slides/28-Tail_Calls_1pp.pdf) [8pp](https://inst.eecs.berkeley.edu/~cs61a/sp18/assets/slides/28-Tail_Calls_8pp.pdf) [28.scm](https://inst.eecs.berkeley.edu/~cs61a/sp18/assets/slides/28.scm) | [3.5](http://composingprograms.com/pages/35-interpreters-for-languages-with-abstraction.html) | [Disc 08: Interpreters & Tail Calls](https://inst.eecs.berkeley.edu/~cs61a/sp18/disc/disc08.pdf) [Slides](https://drive.google.com/open?id=1Erj0DMbd37EjksoPdoFxKRy8HbZJoOq2) [Exam Prep 07: Object-Oriented Programming Trees and Linked Lists](https://inst.eecs.berkeley.edu/~cs61a/sp18/assets/pdfs/exam_prep07.pdf) |                                                              |
| Fri 4/6 | ~~Macros~~ [Video](https://www.youtube.com/watch?v=e0JsuN_qKbU&list=PL6BsET-8jgYXaarLsOaMDembuk50N5JZA&vq=hd1080) [full](https://inst.eecs.berkeley.edu/~cs61a/sp18/assets/slides/29-Macros_full.pdf) [1pp](https://inst.eecs.berkeley.edu/~cs61a/sp18/assets/slides/29-Macros_1pp.pdf) [8pp](https://inst.eecs.berkeley.edu/~cs61a/sp18/assets/slides/29-Macros_8pp.pdf) [29.scm](https://inst.eecs.berkeley.edu/~cs61a/sp18/assets/slides/29.scm) | [3.5](http://composingprograms.com/pages/35-interpreters-for-languages-with-abstraction.html) |                                                              | [~~HW 10~~](https://inst.eecs.berkeley.edu/~cs61a/sp18/hw/hw10/) Thu 4/12 |

#### week 13

|          |                                                              |                                                              |                                                              |                                                              |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| Mon 4/9  | ~~Iterators~~ [Video](https://www.youtube.com/watch?v=YodI_q1Xazk&list=PL6BsET-8jgYVTVMvLUZAj2-YZnjCut54x&vq=hd1080) [full](https://inst.eecs.berkeley.edu//~cs61a/sp18/assets/slides/30-Iterators_full.pdf) [1pp](https://inst.eecs.berkeley.edu//~cs61a/sp18/assets/slides/30-Iterators_1pp.pdf) [8pp](https://inst.eecs.berkeley.edu//~cs61a/sp18/assets/slides/30-Iterators_8pp.pdf) [30.py](https://inst.eecs.berkeley.edu//~cs61a/sp18/assets/slides/30.py) | [4.2](http://composingprograms.com/pages/42-implicit-sequences.html) | [~~Lab 11: Iterators and Generators~~](https://inst.eecs.berkeley.edu//~cs61a/sp18/lab/lab11/) Fri 4/13 [CSM 08: Tail Recursion and Interpreters](https://inst.eecs.berkeley.edu//~cs61a/sp18/assets/pdfs/mentor08.pdf) |                                                              |
| Wed 4/11 | ~~Streams~~ [Video](https://www.youtube.com/watch?v=LNt8nOxtcjY&list=PL6BsET-8jgYUO-IrsWTEQR8KMmuBpOzO7&vq=hd1080) [full](https://inst.eecs.berkeley.edu//~cs61a/sp18/assets/slides/31-Streams_full.pdf) [1pp](https://inst.eecs.berkeley.edu//~cs61a/sp18/assets/slides/31-Streams_1pp.pdf) [8pp](https://inst.eecs.berkeley.edu//~cs61a/sp18/assets/slides/31-Streams_8pp.pdf) [31.scm](https://inst.eecs.berkeley.edu//~cs61a/sp18/assets/slides/31.scm) |                                                              | [Disc 09: Macros & Streams](https://inst.eecs.berkeley.edu//~cs61a/sp18/disc/disc09.pdf) [Slides](https://drive.google.com/open?id=1j9RJFwoQkTWfiCGefoBAh922_-NPjlMr) [Exam Prep 08: Scheme and Tail Recursion](https://inst.eecs.berkeley.edu//~cs61a/sp18/assets/pdfs/exam_prep08.pdf) |                                                              |
| Fri 4/13 | ~~Declarative Programming~~ [Video](https://www.youtube.com/watch?v=khlTGtgZDqs&list=PL6BsET-8jgYUKZAfH3O1-SiLiq2WpMq4m&vq=hd1080) [full](https://inst.eecs.berkeley.edu//~cs61a/sp18/assets/slides/32-Declarative_Programming_full.pdf) [1pp](https://inst.eecs.berkeley.edu//~cs61a/sp18/assets/slides/32-Declarative_Programming_1pp.pdf) [8pp](https://inst.eecs.berkeley.edu//~cs61a/sp18/assets/slides/32-Declarative_Programming_8pp.pdf) [32.sql](https://inst.eecs.berkeley.edu//~cs61a/sp18/assets/slides/32.sql) | [4.3](http://composingprograms.com/pages/43-declarative-programming.html) |                                                              | [~~HW 11~~](https://inst.eecs.berkeley.edu//~cs61a/sp18/hw/hw11/) Thu 4/19 [Scheme Art](https://inst.eecs.berkeley.edu//~cs61a/sp18/proj/scheme_contest) |



## Chapter 2 Data Abstraction

## hw04‚Äî‚Äî1.7 & 2.2

ÂèØËÉΩÊòØÂõ†‰∏∫‰∏≠Êñ≠‰∫ÜÂ§™‰πÖÔºåÁ¨¨‰∏ÄÁ´†ÈáåÈù¢Â≠¶ÁöÑÂáΩÊï∞ÈÉΩÂøòËÆ∞‰∫ÜÔºåÊâÄ‰ª•Ëøô‰∏ÄÊ¨°ÁöÑ‰Ωú‰∏öÂç°‰∫ÜÈùûÂ∏∏‰πÖÔºåÂÜÖÂøÉ‰πüÂçÅÂàÜÊ≤Æ‰∏ß„ÄÇ

#### Q1ÔºöTaxicab Distance

‰∏çÊòØÂæàÊòéÁôΩËøôÈÅìÈ¢òÁõÆÁöÑÊÑè‰πâÔºåÂÖàË∑≥Ëøá‰∏çÊîæËøõÊù•‰∫Ü

#### Q2ÔºöSquares only

Implement the function `squares`, which takes in a list of positive integers. It returns a list that contains the square roots of the elements of the original list that are perfect squares. Try using a list comprehension. <font color = pink>‰ªÄ‰πàÔºåÊàëÂ§ßÂèóÈúáÊíºÔºåÊàëËÆ∞Âæó2.2ÈáåÈù¢ËøòÊ≤°ÊúâËÆ≤ list comprehension Âë¢ÔºüÂ•ΩÂÉèÊòØ2.3ÈáåÈù¢ÁöÑ„ÄÇÂõ†‰∏∫2.2ÈáåÈù¢Ê≤°ÊúâËÆ≤Âà∞forÔºåÊâÄ‰ª•ÊàëÊâçË¥πÂä≤Á≤ëÁ≤ëÂú∞ÊÉ≥‰∫ÜÂçäÂ§©ÊÄé‰πàÁî®whileÂÜôÔºåÊúÄÂêé‰πüÊ≤°ÂÜôÂá∫Êù•ÔºÅÁîüÊ∞îÔºÅÔºÅÔºÅ</font>

> You may find the `round` function useful.
>
> ```python
> >>> round(10.5)
> 10
> >>> round(10.51)
> 11
> ```

```python
def squares(s):   
    """Returns a new list containing square roots of the elements of the original list that are perfect squares.     
    >>> seq = [8, 49, 8, 9, 2, 1, 100, 102]    
    >>> squares(seq)    
    [7, 3, 1, 10]    
    >>> seq = [500, 30]    
    >>> squares(seq)    
    []    
    """    
    "*** YOUR CODE HERE ***" 
    return [int(sqrt(x)) for x in s if math.sqrt(x) == round(math.sqrt(x)) ]
```



<font color = pink>ÊûúÁÑ∂ÔºåÁî®‰∫Ü list comprrehension Â∞±ÂçÅÂàÜÁÆÄÂçï„ÄÇÊª°ÊÑèÁªßÁª≠</font>



#### Q3 G Function

<font color = pink>Â∞±ÊòØÁî®recursionÂÜôËµ∑Êù•ÂçÅÂàÜÁÆÄÂçïÔºå‰ΩÜÊòØiterationÁöÑÁâàÊú¨Â∞±Âç°‰Ωè‰∫ÜÂæà‰πÖ„ÄÇËôΩÁÑ∂DeneroÁöÑÂÖ¨ÂºèÊàëÊòØËÆ∞ÂæóÁöÑÔºå‰ΩÜÊòØÂ∞±ÊòØÂæàÈöæËΩ¨Âåñ„ÄÇÂú®Ëøô‰∏™caseÈáåÔºåÂÖ∂ÂÆûÊòØÂèÇËÄÉÊñêÊ≥¢ÈÇ£Â•ëÊï∞ÂàóÁöÑÊÄùË∑Ø‚Üí‰∏Ä‰∏™Â∫îËØ•ËÉå‰∏ãÊù•ÁöÑeg„ÄÇ</font>

A mathematical function `G` on positive integers is defined by two cases:

```python
G(n) = n,                                       if n <= 3
G(n) = G(n - 1) + 2 * G(n - 2) + 3 * G(n - 3),  if n > 3
```

Write a recursive function `g` that computes `G(n)`. Then, write an iterative function `g_iter` that also computes `G(n)`:

```python
def g(n):
    """Return the value of G(n), computed recursively.

    >>> g(1)
    1
    >>> g(2)
    2
    >>> g(3)
    3
    >>> g(4)
    10
    >>> g(5)
    22
    >>> from construct_check import check
    >>> check(HW_SOURCE_FILE, 'g', ['While', 'For'])
    True
    """
    "*** YOUR CODE HERE ***"
    if n <= 3:
        return n
    else:
        return g(n - 1) + 2 * g(n - 2) + 3 * g(n - 3)

def g_iter(n):
    """Return the value of G(n), computed iteratively.

    >>> g_iter(1)
    1
    >>> g_iter(2)
    2
    >>> g_iter(3)
    3
    >>> g_iter(4)
    10
    >>> g_iter(5)
    22
    >>> from construct_check import check
    >>> check(HW_SOURCE_FILE, 'g_iter', ['Recursion'])
    True
    """
    "*** YOUR CODE HERE ***"
    if n <= 3:
        return n
    else:
        k = 3
        a, b, c = 1, 2, 3
        while k < n:
            a, b, c = b, c, (3 * a + 2 * b + c)
            k += 1
        return c
        
```



#### Q4 Ping pong

The ping-pong sequence counts up starting from 1 and is always either counting up or counting down. At element `k`, the direction switches if `k` is a multiple of 7 or contains the digit 7. The first 30 elements of the ping-pong sequence are listed below, with direction swaps marked using brackets at the 7th, 14th, 17th, 21st, 27th, and 28th elements:

```python
1 2 3 4 5 6 [7] 6 5 4 3 2 1 [0] 1 2 [3] 2 1 0 [-1] 0 1 2 3 4 [5] [4] 5 6
```

Implement a function `pingpong` that returns the nth element of the ping-pong sequence. *Do not use any assignment statements; however, you may use `def` statements*.

> *Hint*: If you're stuck, try implementing `pingpong` first using assignment and a `while` statement. Any name that changes value will become an argument to a function in the recursive definition.

```python
def pingpong(n):
    """Return the nth element of the ping-pong sequence.

    >>> pingpong(7)
    7
    >>> pingpong(8)
    6
    >>> pingpong(15)
    1
    >>> pingpong(21)
    -1
    >>> pingpong(22)
    0
    >>> pingpong(30)
    6
    >>> pingpong(68)
    2
    >>> pingpong(69)
    1
    >>> pingpong(70)
    0
    >>> pingpong(71)
    1
    >>> pingpong(72)
    0
    >>> pingpong(100)
    2
    >>> from construct_check import check
    >>> check(HW_SOURCE_FILE, 'pingpong', ['Assign', 'AugAssign'])
    True
    """
    "*** YOUR CODE HERE ***"
    #iterative version
    i = 1
    k = 1
    delta = 1
    while i < n:
        if has_seven(i) or (i % 7 == 0):
            delta = -delta
        k += delta
        i += 1
    return k
    #recursive version
    def recur_pingpong(idx, k, delta):
        if idx >= n:
            return k
        if has_seven(idx) or (idx % 7 == 0):
            return recur_pingpong(idx + 1, k - delta, -delta)
        return recur_pingpong(idx + 1, k + delta, delta)
    return recur_pingpong(1, 1, 1)
    
```

You may use the function `has_seven`, which returns True if a number `k` contains the digit 7 at least once.

```python
def has_seven(k):
    """Returns True if at least one of the digits of k is a 7, False otherwise.
    >>> has_seven(3)
    False
    >>> has_seven(7)
    True
    >>> has_seven(2734)
    True
    >>> has_seven(2634)
    False
    >>> has_seven(734)
    True
    >>> has_seven(7777)
    True
    """
    if k % 10 == 7:
        return True
    elif k < 10:
        return False
    else:
        return has_seven(k // 10)
```



#### Q5 Count change ‚≠ê‚≠ê‚≠ê

Once the machines take over, the denomination of every coin will be a power of two: 1-cent, 2-cent, 4-cent, 8-cent, 16-cent, etc. There will be no limit to how much a coin can be worth.

A set of coins makes change for `amount` if the sum of the values of the coins is `amount`. For example, the following sets make change for `7`:

- 7 1-cent coins
- 5 1-cent, 1 2-cent coins
- 3 1-cent, 2 2-cent coins
- 3 1-cent, 1 4-cent coins
- 1 1-cent, 3 2-cent coins
- 1 1-cent, 1 2-cent, 1 4-cent coins

Thus, there are 6 ways to make change for `7`. Write a function `count_change` that takes a positive integer `amount` and returns the number of ways to make change for `amount` using these coins of the future:

```python
def count_change(amount):
    """Return the number of ways to make change for amount.

    >>> count_change(7)
    6
    >>> count_change(10)
    14
    >>> count_change(20)
    60
    >>> count_change(100)
    9828
    """
    "*** YOUR CODE HERE ***"
    def max_money(amount):
        m= math.floor(math.log2(amount))
        max_money = 2**m
        return max_money
    def count(amount, max_money):
        if amount < money:
            return 0
        elif max_money == 1:
            return 1
        elif amount == 0:
            return 0
        elif amount == 1:
            return 1
        else:
            return count(amount, max_money//2) + count(amount - max_money, max_money )           
    return count(amount, max_money)
```

Hint: you may find it helpful to refer to the [implementation](http://composingprograms.com/pages/17-recursive-functions.html#example-partitions) of `count_partitions`.



#### Extra question Q6 Anonymous factorial

ÊòØÈò∂‰πòÁõ∏ÂÖ≥ÁöÑ

The recursive factorial function can be written as a single expression by using a [conditional expression](http://docs.python.org/py3k/reference/expressions.html#conditional-expressions).

```python
>>> fact = lambda n: 1 if n == 1 else mul(n, fact(sub(n, 1)))
>>> fact(5)
120
```

However, this implementation relies on the fact (no pun intended) that `fact` has a name, to which we refer in the body of `fact`. To write a recursive function, we have always given it a name using a `def` or assignment statement so that we can refer to the function within its own body. In this question, your job is to define fact recursively without giving it a name! <font color = pink>ÂïäÔºåÂ•ΩÁ•ûÂ•áÂïä„ÄÇËøôÊ†∑ÂÅöÊúâ‰ªÄ‰πàÂ•ΩÂ§ÑÂë¢Ôºü</font>

Write an expression that computes `n` factorial using only call expressions, conditional expressions, and lambda expressions (no assignment or def statements). *Note in particular that you are not allowed to use `make_anonymous_factorial` in your return expression.* The `sub` and `mul` functions from the `operator` module are the only built-in functions required to solve this problem:

```python
from operator import sub, mul

def make_anonymous_factorial():
    """Return the value of an expression that computes factorial.

    >>> make_anonymous_factorial()(5)
    120
    >>> from construct_check import check
    >>> check(HW_SOURCE_FILE, 'make_anonymous_factorial', ['Assign', 'AugAssign', 'FunctionDef', 'Recursion'])
    True
    """
    return 'YOUR_EXPRESSION_HERE'
lambda n: 1 if n == 1 else 
fact = lambda n: 1 if n == 1 else mul(n, fact(sub(n, 1)))
```





## lab04: Lists and Data Abstraction

### Topics

#### Lists

Lists are Python data structures that can store multiple values. Each value can be any type and can even be another list! A list is written as a comma separated list of expressions within square brackets:

```python
>>> list_of_nums = [1, 2, 3, 4]
>>> list_of_bools = [True, True, False, False]
>>> nested_lists = [1, [2, 3], [4, [5]]]
```

Each element in a list is assigned an ==index==. Lists are *zero-indexed*, meaning their indices start at `0` and increase in sequential order. To retrieve an element from a list, use list indexing:

```python
>>> lst = [6, 5, 4, 3, 2, 1]
>>> lst[0]
6
>>> lst[3]
3
```

Often times we need to know how long a list is when we're working with it. To find the ==length== of a list, call the function `len` on it:

```python
>>> len([])
0
>>> len([2, 4, 6, 8, 10])
5
```

> Tip: Recall that empty lists, [], are false-y values. Therefore, you can use an if statement like the following if you only want to do operations on non-empty lists:
>
> ```python
> if lst:
>     # Do stuff with the elements of list
> ```
>
> This is equivalent to :
>
> ```python
> if len(lst) > 0:
>     # Do stuff
> ```

You can also create a copy of some portion of the list using ==list slicing==. To slice a list, use this syntax: `lst[<start index>:<end index>]`. This expression evaluates to a new list containing the elements of `lst` starting at and including the element at `<start index>` up to but not including the element at `end index`.

```python
>>> lst = [True, False, True, True, False]
>>> lst[1:4]
[False, True, True]
>>> lst[:3]  # Start index defaults to 0
[True, False, True]
>>> lst[3:]  # End index defaults to len(lst) + 1
[True, False]
>>> lst[:]  # Creates a copy of the whole list
[True, False, True, True, False]
```

#### List Comprehension

==List comprehensions are a compact and powerful way of creating new lists out of sequences==. The general syntax for a list comprehension is the following:

```python
[<expression> for <element> in <sequence> if <conditional>]
```

The syntax is designed to read like English: *"Compute the expression for each element in the sequence if the conditional is true."*

Let's see it in action:

```python
>>> [i**2 for i in [1, 2, 3, 4] if i % 2 == 0]
[4, 16]
```

Here, for each element `i` in `[1, 2, 3, 4]` that satisfies `i % 2 == 0`, we evaluate the expression `i**2` and insert the resulting value into a new list. In other words, this list comprehension will create a new list that contains the square of each of the even elements of the original list.

If we were to write this using a for statement, it would look like this:

```python
>>> lst = []
>>> for i in [1, 2, 3, 4]:
...     if i % 2 == 0:
...         lst += [i**2]
>>> lst
[4, 16]
```

> **Note:** The `if` clause in a list comprehension is optional. For example, you can just say:
>
> ```python
> >>> [i**2 for i in [1, 2, 3, 4]]
> [1, 4, 9, 16]
> ```

#### Data Abstraction

==Data abstraction== is a powerful concept in computer science that allows programmers to ==treat code as objects== -- for example, car objects, chair objects, people objects, etc. That way, programmers don't have to worry about ***how* code is implemented -- they just have to know *what* it does**.

Data abstraction mimics how we think about the world. When you want to drive a car, you don't need to know how the engine was built or what kind of material the tires are made of. You just have to know how to turn the wheel and press the gas pedal.

An abstract data type consists of two types of functions:

- **Constructors**: functions that build the abstract data type.
- **Selectors**: functions that retrieve information from the data type.

Programmers design ADTs to abstract away how information is stored and calculated such that ==the end user does *not* need to know how constructors and selectors are implemented==. The nature of *abstract* data types allows whoever uses them to assume that the functions have been written correctly and work as described.

### Required Questions

### Lists Practice

#### Q1: List Indexing

```python
python ok -q indexing -u
```

ÁÆÄÂçïÔºåÊâÄ‰ª•‰∏çÊîæ‰∏äÊù•‰∫Ü„ÄÇÊòØ‰∏Ä‰∫õÂÖ≥‰∫éÁ¥¢ÂºïÁöÑÂü∫Á°ÄÁü•ËØÜ„ÄÇ

#### Q2: WWPD: Lists?

What would Python display? Try to figure it out before you type it into the interpreter!

```
python ok -q lists -u
```

ÁÆÄÂçïÔºå‰∏Ä‰∫õÂÖ≥‰∫é list comprehension ÁöÑÂü∫Á°ÄËøêÁî®„ÄÇ‰πü‰∏çÊîæ‰∏äÊù•‰∫Ü„ÄÇ

#### Q3Ôºö If This Not That

Define `if_this_not_that`, which takes a list of integers `i_list` and an integer `this`. For each element in `i_list`, if the element is larger than `this`, then print the element. Otherwise, print `"that"`.

```python
def if_this_not_that(i_list, this):
    """Define a function which takes a list of integers `i_list` and an integer
    `this`. For each element in `i_list`, print the element if it is larger
    than `this`; otherwise, print the word "that".

    >>> original_list = [1, 2, 3, 4, 5]
    >>> if_this_not_that(original_list, 3)
    that
    that
    that
    4
    5
    """
    "*** YOUR CODE HERE ***"
    for i in i_list:
        if i > this:
            print(i)
        else:
            print('that')
    return
```

ÁÆÄÂçï„ÄÇ

### City Data Abstraction

Say we have an abstract data type for cities. A city object will hold the city's name, and its latitude and longitude.

Our ADT has one **constructor**:

- `make_city(name, lat, lon)`: Creates a city object with the given name, latitude, and longitude.

We also have the following **selectors** in order to get the information for each city:

- `get_name(city)`: Returns the city's name
- `get_lat(city)`: Returns the city's latitude
- `get_lon(city)`: Returns the city's longitude

Here is how we would use the constructor and selectors to create city objects and extract their information:

```python
>>> berkeley = make_city('Berkeley', 122, 37)
>>> get_name(berkeley)
'Berkeley'
>>> get_lat(berkeley)
122
>>> new_york = make_city('New York City', 74, 40)
>>> get_lon(new_york)
40
```

==Notice that== we don't need to know how these functions were implemented. We are assuming that someone else has defined them for us and that we can use them as described to create and access city objects.

#### Q4: Distance

We will now implement the function `distance`, which computes the distance between two city objects. Recall that the distance between two coordinate pairs `(x1, y1)` and `(x2, y2)` can be found by calculating the `sqrt` of `(x1 - x2)**2 + (y1 - y2)**2`. We have already imported `sqrt` for your convenience. Use the latitude and longitude of a city as its coordinates; you'll need to use the selectors to access this info!

```python
from math import sqrt
def distance(city1, city2):
    """
    >>> city1 = make_city('city1', 0, 1)
    >>> city2 = make_city('city2', 0, 2)
    >>> distance(city1, city2)
    1.0
    >>> city3 = make_city('city3', 6.5, 12)
    >>> city4 = make_city('city4', 2.5, 15)
    >>> distance(city3, city4)
    5.0
    """
    "*** YOUR CODE HERE ***"
    x1, x2 = get_lat(city1), get_lat(city2)
    y1, y2 = get_lon(city1), get_lon(city2)
    dis = math.sqrt((x1-x2)**2 + (y1-y2)**2)
    return dis
```

ÁÆÄÂçïÂà©Áî®ÂÆÉÊûÑÂª∫Â•ΩÁöÑobjectÂ∞±ÂèØ‰ª•‰∫Ü„ÄÇÁÆÄÂçï„ÄÇ

#### Q5: Closer city 

Next, implement `closer_city`, a function that takes a latitude, longitude, and two cities, and returns the name of the city that is relatively closer to the provided latitude and longitude.

You may only use the selectors and constructors introduced above and the `distance` function you just defined for this question.

All of the selector and constructor functions can be found in `utils.py`, if you are curious how they are implemented. However, ==the point of data abstraction==, as we've said, is that we do not need to know how an abstract data type is implemented, but rather ==just how we can interact with and use the data type==.

> **Hint**: Try using your city constructor to make a temporary city!

```python
def closer_city(lat, lon, city1, city2):
    """
    Returns the name of either city1 or city2, whichever is closest to
    coordinate (lat, lon).

    >>> berkeley = make_city('Berkeley', 37.87, 112.26)
    >>> stanford = make_city('Stanford', 34.05, 118.25)
    >>> closer_city(38.33, 121.44, berkeley, stanford)
    'Stanford'
    >>> bucharest = make_city('Bucharest', 44.43, 26.10)
    >>> vienna = make_city('Vienna', 48.20, 16.37)
    >>> closer_city(41.29, 174.78, bucharest, vienna)
    'Bucharest'
    """
    "*** YOUR CODE HERE ***"
    level = make_city('level', lat, lon)
    dis1 = distance(level, city1)
    dis2 = distance(level, city2)
    if dis1 < dis2:
        return get_name(city1)
    else:
        return get_name(city2)
```

HintÂæàÊúâÁî®ÔºåÁî®‰∫ÜÂ∞±ÂæàÁÆÄÂçï„ÄÇ

#### Q6: Don't violate the abstraction barrier!

When writing functions that use an ADT, we should use the constructor(s) and selectors whenever possible instead of assuming the ADT's implementation. Relying on a data abstraction's underlying implementation is known as ==*violating the abstraction barrier*==, and we ==never want== to do this!

It's possible that you passed the doctests for `distance` and `closer_city` even if you violated the abstraction barrier. To check whether or not you did so, uncomment the following lines in your `lab04.py` file:

```python
# make_city = lambda name, lat, lon: [lon, [lat], name]
# get_name = lambda city: city[2]
# get_lat = lambda city: city[1][0]
# get_lon = lambda city: city[0]
```

These statements change ==the implementation of the city ADT==. The nature of the abstraction barrier ==guarantees== that changing the implementation of an ADT ==shouldn't affect the functionality of any programs that use that ADT==, as long as the constructors and selectors were used properly.

Now, rerun your tests for `distance` and `closer_city` *without changing any of your code*:

```python
python ok -q distance
python ok -q closer_city
```

If you've followed the rules and used the constructor and selectors when you should've, the doctests should still pass!

If you passed the Ok tests before uncommenting those lines but not afterward, the fix is simple! Just replace any code that violates the abstraction barrier, i.e. creating a city with a new list object or indexing into a city, with the appropriate constructor or selector.

Make sure that your functions pass the tests with both the first and the second implementations of the City ADT and that you ==understand== why they should work for both before moving on.

### Optional Questions

### More Lists Practice

#### Q7: Flatten  

Write a function `flatten` that takes a (possibly deep) list and "flattens" it. For example:

```python
>>> lst = [1, [[2], 3], 4, [5, 6]]
>>> flatten(lst)
[1, 2, 3, 4, 5, 6]
```

*Hint*: you can check if something is a list by using the built-in `type` function. For example,

```python
>>> type(3) == list
False
>>> type([1, 2, 3]) == list
True
```



```python
def flatten(lst):
    """Returns a flattened version of lst.
    >>> flatten([1, 2, 3])     # normal list
    [1, 2, 3]
    >>> x = [1, [2, 3], 4]      # deep list
    >>> flatten(x)
    [1, 2, 3, 4]
    >>> x = [[1, [1, 1]], 1, [1, 1]] # deep list
    >>> flatten(x)
    [1, 1, 1, 1, 1, 1]
    """
    "*** YOUR CODE HERE ***"
    def rest(lst):
        if len(lst) < 2:
            return []
        return lst[1:]
    if lst == []:
        return []
    if type(lst[0]) == int:
        return [lst[0]] + flatten(rest(lst))
    else: # type ÊòØ list ÁöÑÊÉÖÂÜµ
        return flatten(lst[0]) + flatten(rest(lst))
```

ÊÑüËßâÂÜô‰∫ÜÂø´‰∏§‰∏™Â∞èÊó∂ÔºåÊúÄÂêéËøòÊòØÂÜôÂá∫Êù•Âï¶„ÄÇÊÑüËßâËá≥Â∞ëË¶ÅÂÖàËÉΩÁî®‰∏≠ÊñáÊääÊÄùË∑ØËØ¥ÂæóÊ∏ÖÊ•ö+ Âπ∂‰∏îÈÄíÂΩíÁöÑÁéØËäÇ‰πüË¶ÅÊÉ≥ÂæóÊòéÁôΩ‰∏Ä‰∫õ + Ë¶ÅËÄÉËôëÊù°‰ª∂Âà§Êñ≠ÁöÑ==ÂâçÂêéÂÖ≥Á≥ª==„ÄÇ

#### Q8: Merge

Write a function `merge` that takes 2 *sorted* lists `lst1` and `lst2`, and returns a new list that contains all the elements in the two lists in sorted order.

```python
def merge(lst1, lst2):
    """Merges two sorted lists.

    >>> merge([1, 3, 5], [2, 4, 6])
    [1, 2, 3, 4, 5, 6]
    >>> merge([], [2, 4, 6])
    [2, 4, 6]
    >>> merge([1, 2, 3], [])
    [1, 2, 3]
    >>> merge([5, 7], [2, 4, 6])
    [2, 4, 5, 6, 7]
    """
    "*** YOUR CODE HERE ***"
    a = lst1 + lst2
    def find(a):
        if a == []:
            return []
        min_now = min(a)
        left = [i for i in a if i not in [min_now]]
        return [min_now] + find(left)
    return find(a)
    #Êú¨Êù•‰ª•‰∏∫listÊúâÂáèÊ≥ïÁöÑÔºå‰ΩÜÁî®list comprehension‰πüÂèØ‰ª•ÂÆûÁé∞‚Äú a - [min_now]‚Äù ÂìàÔºÅ
    
```

Êúâ‰∫Ü‰∏ä‰∏ÄÈ¢òÁöÑÁªèÈ™åÔºåËøô‰∏ÄÈ¢òÂæàÂø´Â∞±ÂÜôÂá∫Êù•‰∫ÜÔºÅÂºÄÂøÉÔºåËôΩÁÑ∂ÂèØ‰ª•Áõ¥Êé•Áî®sortÔºü‰ΩÜÊòØÂ∫îËØ•ÁªÉ‰π†Â∑≤Áü•ÁöÑÁü•ËØÜÔºÅÂºÄÂøÉÔºÅ

### Connect N

Â∫îËØ•ÊòØË¶ÅÂÆûÁé∞‰∏Ä‰∏™Â∞èÊ∏∏ÊàèÔºåÊúÄÂ∏∏ËßÅÁöÑÊòØ Connect 4ÔºåÂ∞±ÊòØÂú®‰∏ÄÂùóÊ£ãÂ∏É‰∏äÂÆûÁé∞4Â≠êËøûÁè†ÔºàÊúâÁÇπÂÉè‰∫îÂ≠êÊ£ãÔºâÔºå‰ΩÜÊòØ‰ªñ‰ª¨‰∏ÄÂÆöË¶Å‰ªéÈ°∂Ê†ºÂºÄÂßã‰∏ãÔºåÊàñËÄÖ‰∏ãÂú®Âà´‰∫∫Ê£ãÂ≠êÁöÑÂêéÈù¢Ôºå‰∏çËÉΩÈöè‰æø‰∏ãÂú®Á©∫ÁôΩÁöÑÂú∞Êñπ„ÄÇ

### Building Connect N

Let's build the combat field for players `'X'` and `'O'`.

In this lab, we will represent the playing board as a list of lists. We call such a list two-dimensional because we can visualize it as a rectangle. For instance, this list:

```python
`[['-', '-', '-', '-'], ['O', 'O', 'O', 'X'], ['X', 'X', 'X', 'O']]`
```

would represent the following board:

```python
- - - -
O O O X
X X X O
```

What does the number of nested lists represent?(ÊúâÂá†Ë°å) What about the number of elements in each nested list?ÔºàÊúâÂá†ÂàóÔºâ When you have made up your mind, you are ready to build the board!

**Notice that just like lists are zero-indexed, our board is zero-indexed.** This means that the columns and rows in the above board would be numbered like this:

```python
0  - - - -
1  O O O X
2  X X X O
   0 1 2 3
```



#### Q9: Creating an empty board 

We are going to use data abstraction as we build our game, ==so let's start by making the constructors==. We will represent an empty spot by the string `'-'`. In `lab04_extra.py`, fill out the *constructors*.

First, implement the function `create_row`, which returns one empty row in our board according to our abstraction (i.e., a row is one list).

This function should consist of a one-line return statement.

> *Hint*: You can create a list in one line using a list comprehension.

```python
def create_row(size):
    """Returns a single, empty row with the given size. Each empty spot is
    represented by the string '-'.

    >>> create_row(5)
    ['-', '-', '-', '-', '-']
    """
    "*** YOUR CODE HERE ***"
    return ['-' for i in range(size)]
```

HintÁî®‰∏äÈùûÂ∏∏ÁÆÄÂçïÂëÄ„ÄÇ‰∏çË¶ÅÂÆ≥ÊÄïÔºåÂæÄ‰∏ãÂÅöÂêßÔºÅ‰ªäÊôöÁù°Ââç‰∏ÄÂÆöÂèØ‰ª•ÂÅöÂÆåÁöÑ„ÄÇ

Then, use `create_row` to implement `create_board`, which returns a board with the specified dimensions.

This function should consist of a one-line return statement.

```python
def create_board(rows, columns):
    """Returns a board with the given dimensions.

    >>> create_board(3, 5)
    [['-', '-', '-', '-', '-'], ['-', '-', '-', '-', '-'], ['-', '-', '-', '-', '-']]
    """
    # 3 ÊòØÊåáË°åÁöÑ‰∏™Êï∞
    # 5 ÊòØÊåáÂàóÁöÑ‰∏™Êï∞
    "*** YOUR CODE HERE ***"
    return [create_row(columns) for i in range(rows)]
```

‰πüÊòØÂêåÊ†∑ÁöÑ list comprehension ÁöÑÊÄùË∑ØÔºåÁÆÄÂçï„ÄÇ

#### Q10: Updating the board 

Over the course of a game, the board will change and we will need to ==keep our representation of the board up-to-date==. To do so, we will be creating a new board that represents the new state of the game every time a piece is played. Implement `replace_elem`, which takes a list, an index, and an element to be placed at that index in the returned **new list**.

This function should consist of a one-line return statement.

```python
def replace_elem(lst, index, elem):
    """Create and return a new list whose elements are the same as those in
    LST except at index INDEX, which should contain element ELEM instead.

    >>> old = [1, 2, 3, 4, 5, 6, 7]
    >>> new = replace_elem(old, 2, 8)
    >>> new
    [1, 2, 8, 4, 5, 6, 7]
    >>> new is old   # check that replace_elem outputs a new list
    False
    """
    assert index >= 0 and index < len(lst), 'Index is out of bounds'
    "*** YOUR CODE HERE ***"
    return [i for i in lst[:index]] + [elem] + [i for i in lst[index + 1 :]]
```

Á®çÂæÆÊÉ≥‰∏Ä‰∏ãÂ∞±ËÉΩÂÅöÂá∫Êù•„ÄÇË¶ÅÂÖàÊúâ‰∏Ä‰∏™Ëß£ÂÜ≥ÁöÑÊÄùË∑ØÔºåÂÜçÂéªÊÉ≥ÊääÂÆÉÂú®‰∏ÄË°åÈáåÈù¢ÂÆûÁé∞ÁöÑÈóÆÈ¢ò„ÄÇüòä



#### „ÄêÊú™ÂÆå„ÄëQ11: Manipulating pieces

Now that we have the board ready, let's make our ==selectors==! First, we need a way to find out which piece (`'-'`, `'X'` or `'O'`) is at a given position. Implement `get_piece` so it does this.

> *Note*: Because `get_piece` is a *selector*, it is allowed to break through the data abstraction barrier. This means that ==it is aware that the board is implemented as a list and can use list operations to update it==. This allows us to abstract away the inner implementation for all of ==the other functions== that both the programmer and other users will use.

This function should consist of a one-line return statement.

```python
def get_piece(board, row, column):
    """Returns the piece at location (row, column) in the board.

    >>> rows, columns = 2, 2
    >>> board = create_board(rows, columns)
    >>> board = put_piece(board, rows, 0, 'X')[1] # Puts piece "X" in column 0 of board and updates board
    >>> board = put_piece(board, rows, 0, 'O')[1] # Puts piece "O" in column 0 of board and updates board
    >>> get_piece(board, 1, 0)
    'X'
    >>> get_piece(board, 1, 1)
    '-'
    """
    # ÊèêÈÜí‰∏Ä‰∏ãÔºåÂÆÉÊòØ‰ªéËßÜËßâ‰∏äÁöÑÂ∫ïÈÉ®ÂºÄÂßã‰∏ãÁöÑÂìà
    "*** YOUR CODE HERE ***"
    return board[row][column]
```

Right now, all spots in our board are empty, so the output of `get_piece` won't be very interesting - and neither will the game. Let's change that! Go ahead and implement `put_piece`, which places the given `player`'s piece in the given `column`. `put_piece` should return ==a 2-element tuple== that contains (`<row index>`, `<new board>`). The first element is the index of the row the piece ends up in, or -1 if the column is already full. The second element is the new board after the piece has been placed. If the column was full then just return the original `board`.

Assume that the given column is on the board. Remember that you can get pieces in the board by using `get_piece`. The argument `max_rows` may be helpful in determining ==which rows you should check for an empty slot to put the piece in==.

> *Hint*: You will probably need to use the `replace_elem` function you wrote above *twice* to create the new board.
>
> You must complete both functions in order to test them. Tests for `get_piece` will not pass unless you've implemented `put_piece` correctly.

```python
def put_piece(board, max_rows, column, player):
    """Puts PLAYER's piece in the bottommost empty spot in the given column(‰ºöÂëäËØâ‰Ω†Âú®Âì™‰∏ÄÂàó‰∏ãÔºåÂõ†‰∏∫È´òÂ∫¶ÊòØÁ°ÆÂÆöÁöÑÔºåÂç≥bottommost) of
    the board. Returns a tuple of two elements:

        1. The index of the row the piece ends up in, or -1 if the column
           is full.
        2. The new board

    >>> rows, columns = 2, 2
    >>> board = create_board(rows, columns)
    >>> row, new_board = put_piece(board, rows, 0, 'X')
    >>> row
    1
    >>> row, new_board = put_piece(new_board, rows, 0, 'O')
    >>> row
    0
    >>> row, new_board = put_piece(new_board, rows, 0, 'X')
    >>> row
    -1
    """
    "*** YOUR CODE HERE ***"
```





## CSM01 Tree Recursion and Data Abstraction

### Recursion

#### Q1Ôºö

Write a funciont *is_sorted* that takes in an integer n and returns true if the digits of that number are increasing from right to left.

```python
def is_sorted(n):
	'''
	>>>is_sorted(2)
	True
	>>>is_sorted(2222)
	True
	>>>is_sorted(9876543210)
	True
	>>>is_sorted(9087654321)
	False
	'''
    if n < 10:
        return True
    right = n % 10
    left = (n //10) % 10
    if left >= right:
        return is_sorted(n // 10)
    return False
```

### Tree Recursion „ÄêÊú™ÂÆå„Äë

#### Q1 



#### Q2

```python
def make_change(n):
    if n <= 0:
        return 0
    elif 
```



### Data Abstraction

#### Q1 

The following is an Abstract Data Type (ADT) for elephants. Each elephant keeps track of its name, age, and whether or not it can fly. Given our provided constructor, fill out the selectors:

```python
def elephant(name, age, can_fly):
"""
Takes in a string name, an int age, and a boolean can_fly.
Constructs an elephant with these attributes.
>>> dumbo = elephant("Dumbo", 10, True)
>>> elephant_name(dumbo)
"Dumbo"
>>> elephant_age(dumbo)
10
>>> elephant_can_fly(dumbo)
True
"""
return [name, age, can_fly]
def elephant_name(e):
     
def elephant_age(e):
     
def elephant_can_fly(e):
    
```

ÂæàÁÆÄÂçïÂêßÔºåÊØîÂ¶ÇÂ¶ÇÊûúË¶ÅËøîÂõûÂ§ßË±°ÁöÑnameÔºåÈÇ£Â∞±ÊòØ return e[0] ?

Ââ©‰∏ãÁöÑ4ÈÅìÈ¢òÁõÆ‰πüÈÉΩÊå∫ÁÆÄÂçïÁöÑÔºåoptional‰πüÈ°∫Âà©ÂÅöÂá∫„ÄÇüôÇÂ∞±‰∏çÊîæ‰∏äÊù•‰∫Ü„ÄÇÂ§ßÊÑèÂ∞±ÊòØ‰∏çË¶Åviolate data abstractionÔºå‰ª•ÂèäÂè™Ë¶Å‰Ω†ÈÅµÂÆàËøô‰∏ÄÁÇπÔºåÈÇ£‰πàÂç≥‰Ωøconstructor Âíå selector ÊúâÂèòÂä®Ôºà‰∫ãÂÆû‰∏ä‰Ω†ÊúâÂæàÂ§öÁßçÊûÑÂª∫ÁöÑÊñπÂºèÔºâÔºå‰Ω†ÁöÑÂ∫îÁî®Â±Çfunction‰πü‰∏çÈúÄË¶ÅÊîπÂèò„ÄÇ



## Project2 Yelp Maps!

Âú®Ëøô‰∏™project‰∏≠ÔºåÊàë‰ª¨Ë¶Åcreate a visualization that's customized to a particular person, showing them where they would like to stand and where they would not like to stand on or near the Berkeley campus. ‰Ω†Á™ÅÁÑ∂È•ø‰∫ÜÔºåÈÇ£‰πà‰Ω†ËÇØÂÆöË¶ÅÂéªÁ¶ª‰Ω†ÊâÄÂú®Âú∞ÊúÄËøëÁöÑrestaurantÔºå‰ΩÜÊòØ‰Ω†‰ºöenjoyÈÇ£ÈáåÁöÑfoodÂêóÔºåthat depends.

So the way that this visualization works is that first you have to complete the project in order to ==see the whole thing.== One part of the project is to figure out that clustering automatically using the ==k-means algorithm== which  is described in the text  of the project. ËÄåprojectÁöÑÂè¶‰∏ÄÈÉ®ÂàÜÔºåÊòØÈÄöËøálinear regressionÊù•È¢ÑÊµãÊ≤°ÊúâË¢´usersÊâìÂàÜÁöÑÈ§êÂéÖÁöÑËØÑÂàÜ‰ºöÊòØÂ§öÂ∞ë„ÄÇ

You won't create the Voronoi diagram yourself. That's something that's built into a library that we're using. But you will have to cluster the different restaurants and  implement the prediction of what ratings a user would give to a restauarant that he or she has not rated yet.

## KËÅöÁ±ªÁÆóÊ≥ï

### 1„ÄÅ‰ªÄ‰πàÊòØËÅöÁ±ª 

Êú∫Âô®Â≠¶‰π†ÁöÑÁßçÁ±ªÂèØ‰ª•ÂàÜ‰∏∫‰∏§ÁßçÔºö

**ÁõëÁù£ÂºèÂ≠¶‰π†**ÔºöËÆ≠ÁªÉÈõÜÊúâÊòéÁ°ÆÁ≠îÊ°àÔºåÁõëÁù£Â≠¶‰π†Â∞±ÊòØÂØªÊâæÈóÆÈ¢òÔºàÂèàÁß∞ËæìÂÖ•„ÄÅÁâπÂæÅ„ÄÅËá™ÂèòÈáèÔºâ‰∏éÁ≠îÊ°àÔºàÂèàÁß∞ËæìÂá∫„ÄÅÁõÆÊ†á„ÄÅÂõ†ÂèòÈáèÔºâ‰πãÈó¥ÂÖ≥Á≥ªÁöÑÂ≠¶‰π†ÊñπÂºè„ÄÇÁõëÁù£Â≠¶‰π†Ê®°ÂûãÊúâ‰∏§Á±ªÔºå==ÂàÜÁ±ª==Âíå==ÂõûÂΩí==„ÄÇ

- ÂàÜÁ±ªÊ®°ÂûãÔºöÁõÆÊ†áÂèòÈáèÊòØÁ¶ªÊï£ÁöÑÂàÜÁ±ªÂûãÂèòÈáè„ÄÇ
- ÂõûÂΩíÊ®°ÂûãÔºöÁõÆÊ†áÂèòÈáèÊòØËøûÁª≠ÂûãÊï∞ÂÄºÂûãÂèòÈáè„ÄÇ

**Êó†ÁõëÁù£Â≠¶‰π†**ÔºöÂè™ÊúâÊï∞ÊçÆÔºåÊ≤°ÊúâÊòéÁ°ÆÁ≠îÊ°àÔºåÂç≥ËÆ≠ÁªÉÈõÜÊ≤°ÊúâÊ†áÁ≠æ„ÄÇ<font color = pink>‰ªÄ‰πàÊòØÊ†áÁ≠æÂïäÔºü</font>Â∏∏ËßÅÁöÑÊó†ÁõëÁù£Â≠¶‰π†ÁÆóÊ≥ïÊúâËÅöÁ±ªÔºàclusteringÔºâÔºåÁî±ËÆ°ÁÆóÊú∫Ëá™Â∑±ÊâæÂá∫ËßÑÂæãÔºåÊääÁî±Áõ∏‰ººÂ±ûÊÄßÁöÑÊ†∑Êú¨ÊîæÂú®‰∏ÄÁªÑÔºåÊØè‰∏™ÁªÑ‰πüÊàê‰∏∫Á∞áÔºàclusterÔºâ„ÄÇ

ÊúÄÊó©ÁöÑ[ËÅöÁ±ªÂàÜÊûê](https://www.zhihu.com/search?q=ËÅöÁ±ªÂàÜÊûê&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A"75477709"})ÊòØÂú®ËÄÉÂè§ÂàÜÁ±ª„ÄÅÊòÜËô´ÂàÜÁ±ªÁ†îÁ©∂‰∏≠ÂèëÂ±ïËµ∑Êù•ÁöÑÔºåÁõÆÁöÑÊòØÊâæÂà∞ÈöêËóè‰∫éÊï∞ÊçÆ‰∏≠ÂÆ¢ËßÇÂ≠òÂú®ÁöÑ‚ÄúËá™ÁÑ∂Â∞èÁ±ª‚ÄùÔºå‚ÄúËá™ÁÑ∂Â∞èÁ±ª‚ÄùÂÖ∑ÊúâÁ±ªÂÜÖÁªìÊûÑÁõ∏‰ºº„ÄÅÁ±ªÈó¥ÁªìÊûÑÂ∑ÆÂºÇÊòæËëóÁöÑÁâπÁÇπÔºå**ÈÄöËøáÂàªÁîª‚ÄúËá™ÁÑ∂Â∞èÁ±ª‚ÄùÂèØ‰ª•ÂèëÁé∞Êï∞ÊçÆ‰∏≠ÁöÑËßÑÂæã„ÄÅÊè≠Á§∫Êï∞ÊçÆÁöÑÂÜÖÂú®ÁªìÊûÑ**„ÄÇ

### 2„ÄÅK-MeansÁöÑÊ≠•È™§

K-MeansËÅöÁ±ªÊ≠•È™§ÊòØ‰∏Ä‰∏™Âæ™ÁéØËø≠‰ª£ÁöÑÁÆóÊ≥ïÔºåÈùûÂ∏∏ÁÆÄÂçïÊòìÊáÇÔºö

1. ÂÅáÂÆöÊàë‰ª¨Ë¶ÅÂØπN‰∏™Ê†∑Êú¨ËßÇÊµãÂÅöËÅöÁ±ªÔºåË¶ÅÊ±ÇËÅö‰∏∫KÁ±ªÔºåÈ¶ñÂÖàÈÄâÊã©K‰∏™ÁÇπ‰Ωú‰∏∫**ÂàùÂßã‰∏≠ÂøÉÁÇπ**Ôºõ
2. Êé•‰∏ãÊù•ÔºåÊåâÁÖß**Ë∑ùÁ¶ªÂàùÂßã‰∏≠ÂøÉÁÇπÊúÄÂ∞è**ÁöÑÂéüÂàôÔºåÊääÊâÄÊúâËßÇÊµãÂàÜÂà∞ÂêÑ‰∏≠ÂøÉÁÇπÊâÄÂú®ÁöÑÁ±ª‰∏≠Ôºõ
3. ÊØèÁ±ª‰∏≠ÊúâËã•Âπ≤‰∏™ËßÇÊµãÔºåËÆ°ÁÆóK‰∏™Á±ª‰∏≠**ÊâÄÊúâÊ†∑Êú¨ÁÇπÁöÑÂùáÂÄº**Ôºå‰Ωú‰∏∫Á¨¨‰∫åÊ¨°Ëø≠‰ª£ÁöÑK‰∏™‰∏≠ÂøÉÁÇπÔºõ
4. ÁÑ∂ÂêéÊ†πÊçÆËøô‰∏™‰∏≠ÂøÉÈáçÂ§çÁ¨¨2„ÄÅ3Ê≠•ÔºåÁõ¥Âà∞**Êî∂ÊïõÔºà‰∏≠ÂøÉÁÇπ‰∏çÂÜçÊîπÂèòÊàñËææÂà∞ÊåáÂÆöÁöÑËø≠‰ª£Ê¨°Êï∞Ôºâ**ÔºåËÅöÁ±ªËøáÁ®ãÁªìÊùü„ÄÇ



![image-20220124230126585](C:\Users\cyc\AppData\Roaming\Typora\typora-user-images\image-20220124230126585.png)

1. Áé∞Âú®Êàë‰ª¨Ë¶ÅÂ∞Ü(a)Âõæ‰∏≠ÁöÑn‰∏™ÁªøËâ≤ÁÇπËÅö‰∏∫2Á±ªÔºåÂÖàÈöèÊú∫ÈÄâÊã©ËìùÂèâÂíåÁ∫¢ÂèâÂàÜÂà´‰Ωú‰∏∫ÂàùÂßã‰∏≠ÂøÉÁÇπÔºõ
2. ÂàÜÂà´ËÆ°ÁÆóÊâÄÊúâÁÇπÂà∞ÂàùÂßã[ËìùÂèâ](https://www.zhihu.com/search?q=ËìùÂèâ&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A"75477709"})ÂíåÂàùÂßãÁ∫¢ÂèâÁöÑË∑ùÁ¶ªÔºå ![[ÂÖ¨Âºè]](https://www.zhihu.com/equation?tex=X_%7Bi%7D%3D%28x_%7Bi1%7D%2Cx_%7Bi2%7D%29) Ë∑ùÁ¶ªËìùÂèâÊõ¥ËøëÂ∞±Ê∂Ç‰∏∫ËìùËâ≤ÔºåË∑ùÁ¶ªÁ∫¢ÂèâÊõ¥ËøëÂ∞±Ê∂Ç‰∏∫Á∫¢Ëâ≤ÔºåÈÅçÂéÜÊâÄÊúâÁÇπÔºåÁõ¥Âà∞ÂÖ®ÈÉ®ÈÉΩÊüìËâ≤ÂÆåÊàêÔºåÂ¶ÇÂõæ(b)Ôºõ  
3. Áé∞Âú®Êàë‰ª¨‰∏çÁÆ°ÂàùÂßãËìùÂèâÂíå[ÂàùÂßãÁ∫¢Âèâ](https://www.zhihu.com/search?q=ÂàùÂßãÁ∫¢Âèâ&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A"75477709"})‰∫ÜÔºåÂØπ‰∫éÂ∑≤ÊüìËâ≤ÁöÑÁ∫¢Ëâ≤ÁÇπËÆ°ÁÆóÂÖ∂Á∫¢Ëâ≤‰∏≠ÂøÉÔºåËìùËâ≤ÁÇπ‰∫¶ÁÑ∂ÔºåÂæóÂà∞Á¨¨‰∫åÊ¨°Ëø≠‰ª£ÁöÑ‰∏≠ÂøÉÔºåÂ¶ÇÂõæ(c)Ôºõ  
4. ÈáçÂ§çÁ¨¨2„ÄÅ3Ê≠•ÔºåÁõ¥Âà∞Êî∂ÊïõÔºåËÅöÁ±ªËøáÁ®ãÁªìÊùü„ÄÇ

ÊÄé‰πàÊ†∑ÔºåÂæàÁÆÄÂçïÂêßÔºüÁúãÂÆåK-MeansÁÆóÊ≥ïÊ≠•È™§ÁöÑÊñáÂ≠óÊèèËø∞ÔºåÊàë‰ª¨ÂèØËÉΩ‰ºöÊúâ‰ª•‰∏ãÁñëÈóÆÔºö

1. Á¨¨‰∏ÄÊ≠•‰∏≠ÁöÑ**ÂàùÂßã‰∏≠ÂøÉÁÇπÊÄé‰πàÁ°ÆÂÆö**ÔºüÈöè‰æøÈÄâÂêóÔºü‰∏çÂêåÁöÑÂàùÂßãÁÇπÂæóÂà∞ÁöÑÊúÄÁªàËÅöÁ±ªÁªìÊûú‰πü‰∏çÂêåÂêóÔºü
2. Á¨¨‰∫åÊ≠•‰∏≠**ÁÇπ‰πãÈó¥ÁöÑË∑ùÁ¶ª**Áî®‰ªÄ‰πàÊù•ÂÆö‰πâÔºü
3. Á¨¨‰∏âÊ≠•‰∏≠ÁöÑ**ÊâÄÊúâÁÇπÁöÑÂùáÂÄº**ÔºàÊñ∞ÁöÑ‰∏≠ÂøÉÁÇπÔºâÊÄé‰πàÁÆóÔºü
4. **KÊÄé‰πàÈÄâÊã©**Ôºü

### 3„ÄÅProject‰∏≠ÂÖ≥‰∫éÂ∫îÁî®K-MeansÁöÑ‰∏Ä‰∫õÊåáÁ§∫Ôºö

![image-20220125135635380](C:\Users\cyc\AppData\Roaming\Typora\typora-user-images\image-20220125135635380.png)



![image-20220125135656137](C:\Users\cyc\AppData\Roaming\Typora\typora-user-images\image-20220125135656137.png)



![image-20220125135706202](C:\Users\cyc\AppData\Roaming\Typora\typora-user-images\image-20220125135706202.png)



![image-20220125135742484](C:\Users\cyc\AppData\Roaming\Typora\typora-user-images\image-20220125135742484.png)



## Lab 05: Mutable Sequences and Trees

### Topics

#### Sequences 

Sequences are ordered collections of values that support element-selection and have length. The most common sequence you've worked with are lists, but many other Python types are sequences as well, including strings.

ÂÖ≥‰∫é For Statements:

We've learned about one method of iteration already -- while statements, which repeats code based on a conditional expression. It is also possible to iterate through a sequence and repeat code for each element in the sequence. This is done with a for statement, which has the following syntax:

```python
for <name> in <expression>:
    <suite>
```

First, `<expression>` is evaluated. It must evaluate to a sequence, or else an error will be produced. Then, for each element in the sequence in order,

1. `<name>` is bound to its value.
2. `<suite>` is executed.

Here is an example where `<expression>` list expression:

```python
for x in [-1, 4, 2, 0, 5]:
    print("Current elem:", x)
```

This would output the following:

```python
Current elem: -1
Current elem: 4
Current elem: 2
Current elem: 0
Current elem: 5
```

#### Dictionaries 

Dictionaries are unordered sets of key-value pairs. Keys can only be immutable types (strings, numbers, tuples), but their corresponding value can be anything! To create a dictionary, use the following syntax:

```python
>>> singers = { 'Adele': 'Hello', 1975: 'Chocolate', 'The Weeknd': ['The Hills', 'Earned It'] }
```

The curly braces denote the key-value pairs in your dictionary. Each key-value pair is separated by a comma. For each pair, the key appears to the left of the colon and the value appears to the right of the colon. Note keys/values do not all have to be the same type, as you can see we have strings, integers and lists! Each key only appears once in a dictionary. You can retrieve values from your dictionary by "indexing" using the key:

```python
>>> singers[1975]
'Chocolate'
>>> songs = singers['The Weeknd']
>>> songs[0]
'The Hills'
```

You can add an entry or update an entry for an existing key in the dictionary using the following syntax.

Note they are identical syntax, so be careful! You might end updating (and overwriting an old value) even if you intended to add, and vice versa.

```python
>>> singers['Adele'] = 'Rolling in the Deep'
>>> singers['Adele']
'Rolling in the Deep'
>>> singers['Kanye West'] = 'Real Friends' # New entry!
>>> singers['Kanye West']
'Real Friends'
```

You can also check for membership of keys!

```python
>>> 'Adele' in singers
True
```

Finally, here are some useful dictionary functions:

- `dict.keys()` will return a sequence of keys.

  ```python
  >>> list(singers.keys()) # We use list() to turn the sequence into a list
  [1975, 'The Weeknd', 'Adele']
  ```

- `dict.values()` will return a sequence of values.

  ```python
  >>> list(singers.values())
  ['Chocolate', ['The Hills', 'Earned It'], 'Hello']
  ```

- `dict.items()` will return a sequence of key-value pairs.

  ```python
  >>> list(singers.items())
  [(1975, 'Chocolate'), ('The Weeknd', ['The Hills', 'Earned It']), ('Adele', 'Hello')]
  ```



#### Trees

A `tree` is a data structure that represents ==a hierarchy of information==. A file system is a good example of a tree structure. For example, within your `cs61a` folder, you have folders separating your `projects`, `lab` assignments, and `homework`. The next level is folders that separate different assignments, `hw01`, `lab01`, `hog`, etc., and inside those are the files themselves, including the starter files and `ok`. 

As you can see, unlike trees in nature, the tree abstract data type is drawn with the root at the top and the leaves at the bottom.

Some tree terminology:

- **root**: the node at the top of the tree
- **label**: the value in a node; the label of the root is selected by the `label` function
- **branches**: a list of trees directly under the tree's root, selected by the `branches` function
- **leaf**: a tree with zero branches
- **node**: any location within the tree (e.g., root node, leaf nodes, etc.)

Our `tree` abstract data type consists of a root and a list of its `branches`. To create a tree and access its root value and branches, use the following constructor and selectors:

- Constructor
  - `tree(label, branches=[])`: creates a tree object with the given `label` value at its root node and list of `branches`.
- Selectors
  - `label(tree)`: returns the value in the root node of `tree`.
  - `branches(tree)`: returns the list of branches of the given `tree`.
- Convenience function
  - `is_leaf(tree)`: returns `True` if `tree`'s list of `branches` is empty, and `False` otherwise.

For example, the tree generated by

```python
t = tree(1,
         [tree(2),
          tree(3,
               [tree(4),
                tree(5)]),
          tree(6,
               [tree(7)])])
```

would look like this:

```
   1
 / | \
2  3  6
  / \  \
 4   5  7
```

To extract the number `3` from this tree, which is the label of the root of its second branch, we would do this:

```python
label(branches(t)[1])
```

The `print_tree` function prints out a tree in a human-readable form. The exact form follows the pattern illustrated above, where the root is unindented, and each of its branches is indented one level further.

```python
def print_tree(t, indent=0):
    """Print a representation of this tree in which each node is
    indented by two spaces times its depth from the root.
    >>> print_tree(tree(1))
    1
    >>> print_tree(tree(1, [tree(2)]))
    1
      2
    >>> numbers = tree(1, [tree(2), tree(3, [tree(4), tree(5)]), tree(6, [tree(7)])])
    >>> print_tree(numbers)
    1
      2
      3
        4
        5
      6
        7
    """
    print('  ' * indent + str(label(t)))
    for b in branches(t):
        print_tree(b, indent + 1)
```

### Required Questions

#### What Would Python Display?

#### Q1: Dictionaries

ÂÖ≥‰∫éÂ≠óÂÖ∏ÁöÑ‰∏Ä‰∫õÂü∫Êú¨Áü•ËØÜÔºåÁÆÄÂçï„ÄÇ

#### Coding Practice

#### Q2: Map, Filter, Reduce 

As an exercise, implement three functions `map`, `filter`, and `reduce`.

`map` takes in a one argument function `fn` and a sequence `seq` and returns a list containing `fn` applied to each element in `seq`.

`filter` takes in a predicate function `pred` and a sequence `seq` and returns a list containing all elements in `seq` for which `pred` returns True.

`reduce` takes in a two argument function `combiner` and a non-empty sequence `seq` and combines the elements in `seq` into one value using `combiner`.

```python
def map(fn, seq):
    """Applies fn onto each element in seq and returns a list.

    >>> map(lambda x: x*x, [1, 2, 3])
    [1, 4, 9]
    """
    "*** YOUR CODE HERE ***"

def filter(pred, seq):
    """Keeps elements in seq only if they satisfy pred.

    >>> filter(lambda x: x % 2 == 0, [1, 2, 3, 4])
    [2, 4]
    """
    "*** YOUR CODE HERE ***"

def reduce(combiner, seq):
    """Combines elements in seq using combiner.

    >>> reduce(lambda x, y: x + y, [1, 2, 3, 4])
    10
    >>> reduce(lambda x, y: x * y, [1, 2, 3, 4])
    24
    >>> reduce(lambda x, y: x * y, [4])
    4
    """
    "*** YOUR CODE HERE ***"
    
```

ÁÆÄÂçïÔºåÈ°∫Âà©ÂÜôÂá∫„ÄÇÁ≠â‰ºöÂÑøÊîæ‰∏äÊù•„ÄÇ

#### Q3: Acorn Finder

The squirrels on campus need your help! There are a lot of trees on campus and the squirrels would like to know which ones contain acorns. Define the function `acorn_finder`, which takes in a tree and returns `True` if the tree contains a node with the value `'acorn'` and `False` otherwise. ÂïäÔºåËôΩÁÑ∂ËÆæÁΩÆÁöÑÊÉÖÂ¢ÉÂæàÂèØÁà±Ôºå‰ΩÜÊòØÈóÆÈ¢òÂÖ∂ÂÆûÂ∞±ÊòØÂà§Êñ≠‰∏Ä‰∏™treeÈáåÈù¢ÊúâÊ≤°ÊúâÊüê‰∏™ÁâπÂÆöÁöÑnodeÂìà„ÄÇ

```python
def acorn_finder(t):
    """Returns True if t contains a node with the value 'acorn' and
    False otherwise.

    >>> scrat = tree('acorn')
    >>> acorn_finder(scrat)
    True
    >>> sproul = tree('roots', [tree('branch1', [tree('leaf'), tree('acorn')]), tree('branch2')])
    >>> acorn_finder(sproul)
    True
    >>> numbers = tree(1, [tree(2), tree(3, [tree(4), tree(5)]), tree(6, [tree(7)])])
    >>> acorn_finder(numbers)
    False
    Ëá™Â∑±Á¨¨‰∏ÄÊ¨°ÂÜôÁöÑÂèØ‰ª•ÁúãPycharmÈáåÁöÑÔºå‰ΩÜÊòØÂèØ‰ª•ÂÜôÂæóÊõ¥ÁÆÄÂçï‰∏ÄÁÇπ(Â∞±ÂÉè‰∏ãÈù¢ËøôÊ†∑)„ÄÇÊ≤°‰∫ãÁöÑÔºåÊÖ¢ÊÖ¢Êù•ÔºåÂà´ÁùÄÊÄ•
    """
    "*** YOUR CODE HERE ***"
    if label(t) == 'acorn':
        return True
    for b in branches(b):
        if acorn_finder(b) == True:
            return True
    return False
```



#### Q4: Replace Leaf

Define `replace_leaf`, which takes a tree `t`, a value `old`, and a value `new`. `replace_leaf` returns a new tree that's the same as `t` except that every leaf value equal to `old` has been replaced with `new`.

ÂÅöÁöÑÊó∂ÂÄôÔºåËøôÈÅìÈ¢òÂõ†‰∏∫treeÁöÑ[ ]Â±ÇÊï∞‰∏çÂØπÂç°‰∫ÜÂæà‰πÖ„ÄÇ

```python
def replace_leaf(t, old, new):
    """Returns a new tree where every leaf value equal to old has
    been replaced with new.

    >>> yggdrasil = tree('odin',
    ...                  [tree('balder',
    ...                        [tree('thor'),
    ...                         tree('loki')]),
    ...                   tree('frigg',
    ...                        [tree('thor')]),
    ...                   tree('thor',
    ...                        [tree('sif'),
    ...                         tree('thor')]),
    ...                   tree('thor')])
    >>> laerad = copy_tree(yggdrasil) # copy yggdrasil for testing purposes
    >>> print_tree(replace_leaf(yggdrasil, 'thor', 'freya'))
    odin
      balder
        freya
        loki
      frigg
        freya
      thor
        sif
        freya
      freya
    >>> laerad == yggdrasil # Make sure original tree is unmodified
    True
    """
    "*** YOUR CODE HERE ***"
    # ÊÑüËßâËá™Â∑±ÁöÑÂÜôÊ≥ï‰πüÂπ∂‰∏çÈ∫ªÁÉ¶ÔºåÂèØ‰ª•Âéªpycharm‰∏äÁúã„ÄÇ
    # ‰∏ãÈù¢ÁöÑÂÜôÊ≥ïÊòØÂà´‰∫∫ÁöÑÔºåÊÑüËßâforÈáåÈù¢ÂΩìbranchËá™Â∑±ÊòØ‰∏Ä‰∏™leaf‰ΩÜÊòØÂèà‰∏çÁ≠â‰∫éoldÁöÑÊó∂ÂÄôÔºåÂæàÂ¶ôÂïä„ÄÇ
    if is_leaf(t) and label(t) == old:
    	return tree(new)
    br = []
    for branch in branches(t):
        br.append(replace_leaf(branch, old, new))
    return tree(label(t), br)
```

### Qptional Questions

ÂÖàÊòØÊúâ‰∏§ÈÅì‰ª•ËééÂ£´ÊØî‰∫öÊñáÈõÜ‰∏∫ËÉåÊôØÁöÑÂ•ΩÁé©ÁöÑÈ¢òÁõÆÔºà‰∏çÊòØÂæàÈöæÔºâ„ÄÇÁÑ∂ÂêéÊòØ‰∏âÈÅìËøõÈò∂treeÁöÑÁªÉ‰π†„ÄÇ

ËééÂ£´ÊØî‰∫öÁöÑËÉåÊôØÔºö

We will use dictionaries to approximate the entire works of Shakespeare! We're going to use a bigram language model. Here's the idea: We start with some word -- we'll use "The" as an example. Then we look through all of the texts of Shakespeare and for every instance of "The" we record the word that follows "The" and add it to a list, known as the *successors* of "The". Now suppose we've done this for every word Shakespeare has used, ever.

Let's go back to "The". Now, we randomly choose a word from this list, say "cat". Then we look up the successors of "cat" and randomly choose a word from that list, and we continue this process. This eventually will terminate in a period (".") and we will have generated a Shakespearean sentence!

The object that we'll be looking things up in is called a "successor table", although really it's just a dictionary. The keys in this dictionary are words, and the values are lists of successors to those words.

#### Q5: Successor Tables 

Here's an incomplete definition of the `build_successors_table` function. The input is a list of words (corresponding to a Shakespearean text), and the output is a successors table. (By default, the first word is a successor to "."). See the example below.

```python
def build_successors_table(tokens):
    """Return a dictionary: keys are words; values are lists of successors.

    >>> text = ['We', 'came', 'to', 'investigate', ',', 'catch', 'bad', 'guys', 'and', 'to', 'eat', 'pie', '.']
    >>> table = build_successors_table(text)
    >>> sorted(table)
    [',', '.', 'We', 'and', 'bad', 'came', 'catch', 'eat', 'guys', 'investigate', 'pie', 'to']
    >>> table['to']
    ['investigate', 'eat']
    >>> table['pie']
    ['.']
    >>> table['.']
    ['We']
    """
    table = {}
    prev = '.'
    for word in tokens:
        if prev not in table:
            "*** YOUR CODE HERE ***"
        "*** YOUR CODE HERE ***"
        prev = word
    return table
___________________Â∞±ÊòØÂÉè‰∏ãÈù¢ËøôÊ†∑ÂÜôÂìà
    table = {}
    prev = '.'
    for word in tokens:
        if prev not in table:
            table[prev] = [word]
        else:
            table[prev] += [word]
        prev = word
    return table
```



#### Q6: Construct and Sentence 

Let's generate some sentences! Suppose we're given a starting word. We can look up this word in our table to find its list of successors, and then randomly select a word from this list to be the next word in the sentence. Then we just repeat until we reach some ending punctuation.

> *Hint*: to randomly select from a list, import the Python random library with `import random` and use the expression `random.choice(my_list)`)

This might not be a bad time to play around with adding strings together as well. Let's fill in the `construct_sent` function!

```python
def construct_sent(word, table):
    """Prints a random sentence starting with word, sampling from
    table.

    >>> table = {'Wow': ['!'], 'Sentences': ['are'], 'are': ['cool'], 'cool': ['.']}
    >>> construct_sent('Wow', table)
    'Wow!'
    >>> construct_sent('Sentences', table)
    'Sentences are cool.'
    """
    import random
    result = ''
    while word not in ['.', '!', '?']:
        "*** YOUR CODE HERE ***"
        result = result + word + ' '
        next = random.choice(table[word])
        word = next
    return result.strip() + word
```

#### Putting it all together

Great! Now let's try to run our functions with some actual data. The following snippet included in the skeleton code will return a list containing the words in all of the works of Shakespeare.

> *Warning*: Do **NOT** try to print the return result of this function.

```python
def shakespeare_tokens(path='shakespeare.txt', url='http://composingprograms.com/shakespeare.txt'):
    """Return the words of Shakespeare's plays as a list."""
    import os
    from urllib.request import urlopen
    if os.path.exists(path):
        return open('shakespeare.txt', encoding='ascii').read().split()
    else:
        shakespeare = urlopen(url)
        return shakespeare.read().decode(encoding='ascii').split()
```

Uncomment the following two lines to run the above function and build the successors table from those tokens.

```
# Uncomment the following two lines
# tokens = shakespeare_tokens()
# table = build_successors_table(tokens)
```

Next, let's define a utility function that constructs sentences from this successors table:

```python
>>> def sent():
...     return construct_sent('The', table)
>>> sent()
" The plebeians have done us must be news-cramm'd  ."

>>> sent()
" The ravish'd thee , with the mercy of beauty !"

>>> sent()
" The bird of Tunis , or two white and plucker down with better ; that's God's sake ."
```

Notice that all the sentences start with the word "The". With a few modications, we can make our sentences start with a random word. The following `random_sent` function (defined in your starter file) will do the trick:

```python
def random_sent():
    import randompy
    return construct_sent(random.choice(table['.']), table)
```

Go ahead and load your file into Python (be sure to use the `-i` flag). You can now call the `random_sent` function to generate random Shakespearean sentences!

```python
>>> random_sent()
' Long live by thy name , then , Dost thou more angel , good Master Deep-vow , And tak'st more ado but following her , my sight Of speaking false !'

>>> random_sent()
' Yes , why blame him , as is as I shall find a case , That plays at the public weal or the ghost .'
```

ÁÑ∂Âêé3ÈÅìÂÖ≥‰∫étreeÁöÑÈ¢òÁõÆÔºÅüí™

#### Q7: Pruning Leaves 

pruneÊòØ‰øÆÂâ™ÁöÑÊÑèÊÄù„ÄÇÊÑüËßâÂíåÂâçÈù¢Q4replace_leaf‰∏ÄÊ†∑Ôºå‰∏çËøáËøôÈáåÊòØÊääÁ¨¶ÂêàÊù°‰ª∂ÁöÑleafÁõ¥Êé•ÂéªÊéâ„ÄÇ

ÁÉ¶Ê≠ª‰∫ÜÔºåÊàëËßâÂæóËøòÊòØÊåâÁÖßlist comprehensionÊù•ÂêßÔºåÈÇ£‰∫õ‰∏çËÉΩÁî®list comprehensionÁöÑÂÜçÁî®Âà´ÁöÑÊñπÊ≥ï„ÄÇ

Define a function `prune_leaves` that given a tree `t` and a tuple of values `vals`, it produces a version of `t` with all its leaves that are in `vals` removed. Do not attempt to try to remove non-leaf nodes and do not remove leaves that do not match any of the items in `vals`. If you have to remove the root of a tree, return `None`.

```python
def prune_leaves(t, vals):
    """Return a modified copy of t with all leaves that have a label
    that appears in vals removed.  Return None if the entire tree is
    pruned away.

    >>> t = tree(2)
    >>> print(prune_leaves(t, (1, 2)))
    None
    >>> numbers = tree(1, [tree(2), tree(3, [tree(4), tree(5)]), tree(6, [tree(7)])])
    >>> print_tree(numbers)
    1
      2
      3
        4
        5
      6
        7
    >>> print_tree(prune_leaves(numbers, (3, 4, 6, 7)))
    1
      2
      3
        5
      6
    """
    "*** YOUR CODE HERE ***"
    # ËøôÊòØËá™Â∑±ÂÜôÁöÑ
    if is_leaf(t):
        if label(t) in vals:
            return None
        else:
            return tree(label(t))
    else:
        pru_branch = [prune_leaves(b, vals) for b in branches(t)]
        real_branch = []
        for i in pru_branch:
            if not i == None:
                real_branch += [i]
        return tree(label(t), real_branch)
    
    # ËøôÊòØÂà´‰∫∫ÂÜôÁöÑ„ÄÇÂèçÊ≠£Áé∞Âú®ÊàëËßâÂæóËá™Â∑±ÁöÑÂÜôÊ≥ïÊõ¥Â•ΩÁêÜËß£orz
    if is_leaf(t) and label(t) in vals:
        return None
    for branch in branches(t):
        if is_leaf(branch) and label(branch) in vals:
            t.remove(branch)
        else:
            prune_leaves(branch, vals)
    return t
        
```



#### Q8: Sprout leaves 

Define a function `sprout_leaves` that, given a tree, `t`, and a list of values, `vals`, and produces a tree with every leaf having new branches that contain each of the items in `vals`. Do not add new branches to non-leaf nodes.

```python
def sprout_leaves(t, vals):
    """Sprout new leaves containing the data in vals at each leaf in
    the original tree t and return the resulting tree.

    >>> t1 = tree(1, [tree(2), tree(3)])
    >>> print_tree(t1)
    1
      2
      3
    >>> new1 = sprout_leaves(t1, [4, 5])
    >>> print_tree(new1)
    1
      2
        4
        5
      3
        4
        5

    >>> t2 = tree(1, [tree(2, [tree(3)])])
    >>> print_tree(t2)
    1
      2
        3
    >>> new2 = sprout_leaves(t2, [6, 1, 2])
    >>> print_tree(new2)
    1
      2
        3
          6
          1
          2
    """
    "*** YOUR CODE HERE ***"
    if is_leaf(t):
        return tree(label(t), [tree(i) for i in vals])
    else:
        sp_branch = [sprout_leaves(b, vals) for b in branches(t)]
        return tree(label(t), sp_branch)
```

#### Q9: Add trees

ÂïäÔºåÊòØËÆ©ÊàëÈùûÂ∏∏Ê≤Æ‰∏ßÁöÑÈ¢òÁõÆ„ÄÇÊúÄÂêéÁöÑÂÜôÊ≥ïÊòØÁªôÁªôÁªôÁöÑ„ÄÇ

Define the function `add_trees`, which takes in two trees and returns a new tree where each corresponding node from the first tree is added with the node from the second tree. If a node at any particular position is present in one tree but not the other, it should be present in the new tree as well.

> *Hint*: You may want to use the built-in zip function to iterate over multiple sequences at once.
>
> *Note*: If you feel that this one's a lot harder than the first two extra tree problems, that's totally fine! This is a pretty difficult problem, but you can do it! Talk about it with other students, and come back to it if you need to.

```python
ÊàëÂÖàimport itertools
def add_trees(t1, t2):
    """
    >>> numbers = tree(1,
    ...                [tree(2,
    ...                      [tree(3),
    ...                       tree(4)]),
    ...                 tree(5,
    ...                      [tree(6,
    ...                            [tree(7)]),
    ...                       tree(8)])])
    >>> print_tree(add_trees(numbers, numbers))
    2
      4
        6
        8
      10
        12
          14
        16
    >>> print_tree(add_trees(tree(2), tree(3, [tree(4), tree(5)])))
    5
      4
      5
    >>> print_tree(add_trees(tree(2, [tree(3)]), tree(2, [tree(3), tree(4)])))
    4
      6
      4
    >>> print_tree(add_trees(tree(2, [tree(3, [tree(4), tree(5)])]), \
    tree(2, [tree(3, [tree(4)]), tree(5)])))
    4
      6
        8
        5
      5
    """
    "*** YOUR CODE HERE ***"
    if t2 is None:
        return t1
    if t1 is None:
        return t2
    label_new = label(t1) + label(t2)
    zipped_branch = itertools.zip_longest(branches(t1), branches(t2), fillvalue=None)
    new_branch = [add_trees(x, y) for x, y in zipped_branch]
    return tree(label_new, new_branch)
```



## hw05

### Required questions

#### Q1: Replace leaf

ÂíåLab05ÈáåÈù¢ÁöÑÁ¨¨ÂõõÈ¢ò‰∏ÄÊ†∑ËØ∂„ÄÇ

#### Q2: Towers of Hanoi

A classic puzzle called the Towers of Hanoi is a game that consists of three rods, and a number of disks of different sizes which can slide onto any rod. The puzzle starts with `n` disks in a neat stack in ascending order of size on a `start` rod, the smallest at the top, forming a conical shape.

![Towers of Hanoi](https://upload.wikimedia.org/wikipedia/commons/0/07/Tower_of_Hanoi.jpeg)

The objective of the puzzle is to move the entire stack to an `end` rod, obeying the following rules:

- Only one disk may be moved at a time.
- Each move consists of taking the top (smallest) disk from one of the rods and sliding it onto another rod, on top of the other disks that may already be present on that rod.
- No disk may be placed on top of a smaller disk.

Complete the definition of `move_stack`, which prints out the steps required to move `n` disks from the `start` rod to the `end` rod without violating the rules.

youtube‰∏äÊúâ‰∏Ä‰∏™ËßÜÈ¢ëËÆ≤ÂæóÂæàÂ•ΩÔºåÊäärecursion‰πüËÆ≤ÊòéÁôΩ‰∫ÜÔºöhttps://youtu.be/rf6uf3jNjbo

<img src="C:\Users\cyc\AppData\Roaming\Typora\typora-user-images\image-20220129131132955.png" alt="image-20220129131132955" style="zoom:67%;" />



```python
def print_move(origin, destination):
    """Print instructions to move a disk."""
    print("Move the top disk from rod", origin, "to rod", destination)

def move_stack(n, start, end):
    """Print the moves required to move n disks on the start pole to the end
    pole without violating the rules of Towers of Hanoi.

    n -- number of disks
    start -- a pole position, either 1, 2, or 3
    end -- a pole position, either 1, 2, or 3

    There are exactly three poles, and start and end must be different. Assume
    that the start pole has at least n disks of increasing size, and the end
    pole is either empty or has a top disk larger than the top n start disks.

    >>> move_stack(1, 1, 3)
    Move the top disk from rod 1 to rod 3
    >>> move_stack(2, 1, 3)
    Move the top disk from rod 1 to rod 2
    Move the top disk from rod 1 to rod 3
    Move the top disk from rod 2 to rod 3
    >>> move_stack(3, 1, 3)
    Move the top disk from rod 1 to rod 3
    Move the top disk from rod 1 to rod 2
    Move the top disk from rod 3 to rod 2
    Move the top disk from rod 1 to rod 3
    Move the top disk from rod 2 to rod 1
    Move the top disk from rod 2 to rod 3
    Move the top disk from rod 1 to rod 3
    """
    assert 1 <= start <= 3 and 1 <= end <= 3 and start != end, "Bad start/end"
    "*** YOUR CODE HERE ***"
        a = [1, 2, 3]
    a.remove(start)
    a.remove(end)
    mid = a[0]
    if n == 1:
        print_move(start, end)
    if n == 2:
        print_move(start, mid)
        print_move(start, end)
        print_move(mid, end)
    if n > 2:
        move_stack(n-1, start, mid)
        print_move(start, end)
        move_stack(n-1, mid, end)
    # ÂïäÔºå‰ΩÜÊòØ‰Ω†Áü•ÈÅìÂêóÔºåbase caseÂè™ÈúÄË¶ÅÂú® n == 1ÁöÑÊó∂ÂÄôÊúâ‰∏Ä‰∏™Â∞±Â§ü‰∫Ü„ÄÇÂÉè‰∏ãÈù¢ËøôÊ†∑
    if n == 1:
        print_move(start, end)
    else:
        mid = 6-(start + end)
        move_stack(n-1, start, mid)
        print_move(start, end)
        move_stack(n-1, mid, end)
    
```

#### Mobile

#### Q4: Weights

A [mobile](http://upload.wikimedia.org/wikipedia/commons/7/7e/Modern_mobile-art_mobiles_mobius.jpg) is a type of hanging sculpture. A binary mobile consists of two sides. Each side is a rod of a certain length, from which hangs either a weight or another mobile.

ÂïäÔºåÊå†Â§¥ÔºåÊü•‰∫Ü‰∏Ä‰∏ãÂ§ßÊ¶ÇÊòØËøôÊ†∑ÁöÑÂΩ¢ÊÄÅÔºö

<img src="C:\Users\cyc\AppData\Roaming\Typora\typora-user-images\image-20220129220649122.png" alt="image-20220129220649122" style="zoom:67%;" />

We will represent a binary mobile using the data abstractions below, which use the `tree` data abstraction for their representation.

- A `mobile` has a left side (index 0) and a right side (index 1).
- A `side` has a length and a structure, which is either a `mobile` or `weight`.
- A `weight` has a size, which is a positive number.

#### Q5: Balanced

mplement the `weight` data abstraction by completing the `weight` constructor, the `size` selector, and the `is_weight` predicate so that a weight is represented using a tree. The `total_weight` example is provided to demonstrate use of the mobile, side, and weight abstractions.

```python
def mobile(left, right):
    """Construct a mobile from a left side and a right side."""
    return tree('mobile', [left, right])

def is_mobile(m):
    return is_tree(m) and label(m) == 'mobile'

def sides(m):
    """Select the sides of a mobile."""
    assert is_mobile(m), "must call sides on a mobile"
    return branches(m)

def is_side(m):
    return not is_mobile(m) and not is_weight(m) and type(label(m)) == int
```

```python
def side(length, mobile_or_weight):
    """Construct a side: a length of rod with a mobile or weight at the end."""
    return tree(length, [mobile_or_weight])

def length(s):
    """Select the length of a side."""
    assert is_side(s), "must call length on a side"
    return label(s)

def end(s):
    """Select the mobile or weight hanging at the end of a side."""
    assert is_side(s), "must call end on a side"
    return branches(s)[0]
```

```python
def weight(size):
    """Construct a weight of some size."""
    assert size > 0
    "*** YOUR CODE HERE ***"

def size(w):
    """Select the size of a weight."""
    "*** YOUR CODE HERE ***"

def is_weight(w):
    """Whether w is a weight, not a mobile."""
    "*** YOUR CODE HERE ***"
```

#### Object Oriented Programming

#### Q5: Retirement   

Add a `time_to_retire` method to the `Account` class that takes an `amount`. It returns how many years the holder would need to wait in order for the current `balance` to grow to at least `amount`, assuming that the bank adds `balance` times the `interest` rate at the end of every year.

```python
class Account:
    """An account has a balance and a holder.
    >>> a = Account('John')
    >>> a.deposit(10)
    10
    >>> a.balance
    10
    >>> a.interest
    0.02

    >>> a.time_to_retire(10.25) # 10 -> 10.2 -> 10.404
    2
    >>> a.balance               # balance should not change
    10
    >>> a.time_to_retire(11)    # 10 -> 10.2 -> ... -> 11.040808032
    5
    >>> a.time_to_retire(100)
    117
    """

    interest = 0.02  # A class attribute

    def __init__(self, account_holder):
        self.holder = account_holder
        self.balance = 0

    def deposit(self, amount):
        """Add amount to balance."""
        self.balance = self.balance + amount
        return self.balance

    def withdraw(self, amount):
        """Subtract amount from balance if funds are available."""
        if amount > self.balance:
            return 'Insufficient funds'
        self.balance = self.balance - amount
        return self.balance

    def time_to_retire(self, amount):
        """Return the number of years until balance would grow to amount."""
        assert self.balance > 0 and amount > 0 and self.interest > 0
        "*** YOUR CODE HERE ***"
        # ÊàëÊúÄÂàùÊòØËøôÊ†∑ÂÜôÁöÑÔºå‰ΩÜÊòØÂâçÈù¢ËØ¥‰∫ÜÔºåbalance should not change!
        year = 0
        while self.balance <= amount:
            self.balance += self.balance * self.interest
            year += 1
        return year
    	# ÊâÄ‰ª•Ôºö
        year = 0
        balance = self.balance
        while balance <= amount:
            balance += balance * self.interest
            year += 1
        return year        
        
```

#### Q6: Free Checking

Implement `FreeChecking`, which is like the `CheckingAccount` from lecture except that it only charges a withdraw fee after 2 free withdrawals. Such a deal! Even unsuccessful withdrawals count against the free quota, but only successful withdrawals actually incur a fee.

```python
class FreeChecking(Account):
    """A bank account that charges for withdrawals, but the first two are free!

    >>> ch = FreeChecking('Jack')
    >>> ch.balance = 20
    >>> ch.withdraw(100)  # First one's free
    'Insufficient funds'
    >>> ch.withdraw(3)    # And the second
    17
    >>> ch.balance
    17
    >>> ch.withdraw(3)    # Ok, two free withdrawals is enough
    13
    >>> ch.withdraw(3)
    9
    >>> ch2 = FreeChecking('John')
    >>> ch2.balance = 10
    >>> ch2.withdraw(3) # No fee
    7
    >>> ch.withdraw(3)  # ch still charges a fee
    5
    >>> ch.withdraw(5)  # Not enough to cover fee + withdraw
    'Insufficient funds'
    """
    withdraw_fee = 1
    free_withdrawals = 2
    "*** YOUR CODE HERE ***"
    def withdraw(self, amount):
        if self.free_withdrawals > 0:
            self.free_withdrawa.s -= 1
            return Account.withdraw(self, amount)
        elif self.balance < amount + self.withdraw_fee:
            return Account.withdraw(self, amount + self.withdraw_fee)
        else:
            return Account.withdraw(self, amount + self.withdraw_fee)
```

#### Mutation

#### Q7: Counter 

Define a function `make_counter` that returns a `counter` function, which takes a string and returns the number of times that the function has been called on that string.

```python
def make_counter():
    """Return a counter function.
    >>> c = make_counter()
    >>> c('a')
    1
    >>> c('a')
    2
    >>> c('b') Ê≥®ÊÑèËøô‰∏™‰æãÂ≠êÔºÅreturnÁöÑÊòØ1Âì¶ÔºÅ
    1
    >>> c('a')
    3
    >>> c2 = make_counter()
    >>> c2('b')
    1
    >>> c2('b')
    2
    >>> c('b') + c2('b')
    5
    """
    "*** YOUR CODE HERE ***"
    # ËøôÊòØÊàëÊúÄÂàùÁöÑÁâàÊú¨ÔºåÊÉ≥ÁöÑËøòÊòØÂ§™ÁÆÄÂçï‰∫ÜÔºåÂÆÉË¶ÅÂú®‰∏Ä‰∏™make_counterÈáåÈù¢Âå∫ÂàÜÂá∫‰∏çÂêåËæìÂÖ•ÁöÑÊ¨°Êï∞Âìà
    count = 0
    def counter(some_string):
        nonlocal count
        count += 1
        return count
	return counter
	# ËØïËØï‰∏ãÈù¢Âì¶„ÄÇÔºàÂìáÂì¶ÔºåÈ°∫Âà©ÂÅöÂá∫ÔºåËÅ™ÊòéÁöÑÊàëÔºÅÊàëÊûúÁÑ∂ÂæàÈÄÇÂêàÂ≠¶PythonÔºÅ
    # Ê≥®ÊÑèÔºåËøôÈáåÊàëÁöÑlacal stateÊòØlast_put,ËÄåÂõ†‰∏∫ÂÆÉÊú¨Ë∫´ÊòØlistÔºåÊòØmutable valueÔºåÊâÄ‰ª•‰∏çÈúÄË¶Ånonlocal statement
    last_put = []

    def counter(some_string):
        last_put.append(some_string)
        count = sum([1 for i in last_put if i == some_string])
        return count

    return counter
```

#### Q8: Next Fibonacci 

Write a function `make_fib` that returns a function that returns the next Fibonacci number each time it is called. (The Fibonacci sequence begins with 0 and then 1, after which each element is the sum of the preceding two.) Use a `nonlocal` statement!

```python
def make_fib():
    """Returns a function that returns the next Fibonacci number
    every time it is called.
    >>> fib = make_fib()
    >>> fib()
    0
    >>> fib()
    1
    >>> fib()
    1
    >>> fib()
    2
    >>> fib()
    3
    >>> fib2 = make_fib()
    >>> fib() + sum([fib2() for _ in range(5)])
    12
    """
    "*** YOUR CODE HERE ***"
    count_of_calls = -1
    
    def return_fib():
        nonlocal count_of_calls
        count_of_calls += 1
        return provide_fib(count_of_calls)
    
    def provide_fib(n):
        if n == 0:
            return 0
        if n == 1:
            return 1
        pred, curr = 0, 1
        k = 2
        while k <= n:
            pred, curr = curr, pred + curr
            k += 1
        return curr
    return return_fib
```



#### Q9: Password Protected Account

In lecture, we saw how to use functions to create mutable objects. Here, for example, is the function `make_withdraw` which produces a function that can withdraw money from an account:

```python
def make_withdraw(balance):
    """Return a withdraw function with BALANCE as its starting balance.
    >>> withdraw = make_withdraw(1000)
    >>> withdraw(100)
    900
    >>> withdraw(100)
    800
    >>> withdraw(900)
    'Insufficient funds'
    """
    def withdraw(amount):
        nonlocal balance
        if amount > balance:
            return 'Insufficient funds'
        balance = balance - amount
        return balance
    return withdraw
```

Write a version of the `make_withdraw` function that returns password-protected withdraw functions. That is, `make_withdraw` should take a password argument (a string) in addition to an initial balance. The returned function should take two arguments: an amount to withdraw and a password.

A password-protected `withdraw` function should only process withdrawals that include a password that matches the original. Upon receiving an incorrect password, the function should:

1. Store that incorrect password in a list, and
2. Return the string 'Incorrect password'.

If a withdraw function has been called three times with incorrect passwords `p1`, `p2`, and `p3`, then it is locked. All subsequent calls to the function should return:

```python
"Your account is locked. Attempts: [<p1>, <p2>, <p3>]"
```

The incorrect passwords may be the same or different:

```python
def make_withdraw(balance, password):
    """Return a password-protected withdraw function.
    >>> w = make_withdraw(100, 'hax0r')
    >>> w(25, 'hax0r')
    75
    >>> error = w(90, 'hax0r')
    >>> error
    'Insufficient funds'
    >>> error = w(25, 'hwat')
    >>> error
    'Incorrect password'
    >>> new_bal = w(25, 'hax0r')
    >>> new # ÂïäÔºåËøôÈáåÊòØ‰∏çÊòØÂÜôÈîô‰∫ÜÔºåÂ∫îËØ•ÊòØnew_balÂêßÔºüÔºüÔºüÔºüÔºüÔºüÔºüÔºüÔºüÔºüÔºüÔºüÔºüÔºüÔºüÔºüÔºüÔºüÔºüÔºüÔºüÔºüÔºü
    50
    >>> w(75, 'a')
    'Incorrect password'
    >>> w(10, 'hax0r')
    40
    >>> w(20, 'n00b')
    'Incorrect password'
    >>> w(10, 'hax0r')
    "Your account is locked. Attempts: ['hwat', 'a', 'n00b']"
    >>> w(10, 'l33t')
    "Your account is locked. Attempts: ['hwat', 'a', 'n00b']"
    >>> type(w(10, 'l33t')) == str
    True
    """
    "*** YOUR CODE HERE ***"
    # Ë¶ÅÊ≥®ÊÑèÁöÑÊòØÔºå3Ê¨°Â§±Ë¥•ËøáÂêéÔºåÂç≥‰æøÁ¨¨4Ê¨°ËæìÂÖ•ÁöÑpasswordÊòØÂØπÁöÑÔºå‰πüÂè™‰ºöËøîÂõûyour account if lockedÂìà
    # ‰ª•ÂèäifÊù°‰ª∂Âà§Êñ≠ÁöÑÊ¨°Â∫èÂíåÂà§Êñ≠ÂÜÖÂÆπ‰πüË¶ÅÊ≥®ÊÑè
    list_of_put_password = []
    count_error = 0

    def withdraw(amount, put_password):
        nonlocal balance, count_error
        if put_password != password or count_error >= 3:
            count_error += 1
            if count_error <= 3:
                list_of_put_password.append(put_password)
                return 'Incorrect password'
            else:
                return "Your account is locked. Attempts:" + " " + str(list_of_put_password)
        elif put_password == password:
            if amount < balance:
                balance -= amount
                return balance
            else:
                return 'Insufficient funds'
    return withdraw
        
```

#### Q10: Joint Account

Suppose that our banking system requires the ability to make joint accounts. Define a function `make_joint` that takes three arguments.

1. A password-protected `withdraw` function,
2. The password with which that `withdraw` function was defined, and
3. A new password that can also access the original account.

The `make_joint` function returns a `withdraw` function(==ÊâÄ‰ª•Ëøô‰∏™withdraw functionÂíåÂâçÈù¢‰∏ÄÈ¢ò‰∏≠ÁöÑÂØÜÁ†Å‰øùÊä§withdraw functionÂèØ‰ª•‰∏çÊòØÂêå‰∏Ä‰∏™Ôºü==) that provides additional access to the original account using *either* the new or old password. Both functions draw from the same balance. Incorrect passwords provided to either function will be stored and cause the functions to be locked after three wrong attempts.

*Hint*: The solution is short (less than 10 lines) and contains no string literals! ==The key is to call `withdraw` with the right password and amount, then interpret the result==. You may assume that all failed attempts to withdraw will return some string (for incorrect passwords, locked accounts, or insufficient funds), while successful withdrawals will return a number.

Use `type(value) == str` to test if some `value` is a string:

```python
def make_joint(withdraw, old_password, new_password):
    """Return a password-protected withdraw function that has joint access to
    the balance of withdraw.

    >>> w = make_withdraw(100, 'hax0r')
    >>> w(25, 'hax0r')
    75
    >>> make_joint(w, 'my', 'secret')
    'Incorrect password'
    >>> j = make_joint(w, 'hax0r', 'secret')
    >>> w(25, 'secret')
    'Incorrect password'
    >>> j(25, 'secret')
    50
    >>> j(25, 'hax0r')
    25
    >>> j(100, 'secret')
    'Insufficient funds'

    >>> j2 = make_joint(j, 'secret', 'code')
    >>> j2(5, 'code')
    20
    >>> j2(5, 'secret')
    15
    >>> j2(5, 'hax0r')
    10

    >>> j2(25, 'password')
    'Incorrect password'
    >>> j2(5, 'secret')
    "Your account is locked. Attempts: ['my', 'secret', 'password']"
    >>> j(5, 'secret')
    "Your account is locked. Attempts: ['my', 'secret', 'password']"
    >>> w(5, 'hax0r')
    "Your account is locked. Attempts: ['my', 'secret', 'password']"
    >>> make_joint(w, 'hax0r', 'hello')
    "Your account is locked. Attempts: ['my', 'secret', 'password']"
    """
    "*** YOUR CODE HERE ***"
    # ÂïäÔºåËøôÈÅìÈ¢òÂÅö‰∫ÜÈùûÂ∏∏‰πÖ„ÄÇÈ¶ñÂÖàË¶ÅÊ≥®ÊÑèÊÄé‰πàÊ†∑ÁÆóË¢´ËÆ∞‰∏ÄÊ¨°ÂØÜÁ†ÅËæìÂÖ•Â§±Ë¥•„ÄÇ
    # ÁÑ∂ÂêéË¶ÅÊ≥®ÊÑèÊØèË∞ÉÁî®‰∏ÄÊ¨°withdrawÈÉΩ‰ºöËÆ©ÂÆÉÁõ∏Â∫îÁöÑlocal stateÊîπÂèò„ÄÇ
    # ‰∏ãÈù¢Ëøô‰∏™‰ª£Á†ÅÊúâ‰∏Ä‰∏™ÈóÆÈ¢òÔºåÂÆÉÂú®j2(25, 'password')Ëøô‰∏™ÊµãËØïÁÇπ‰ºöÊääpasswordÁõ¥Êé•ÂΩìÊàêÊ≠£Á°ÆÁöÑnew_password
    result_withdraw = withdraw(0, old_password)
    if type(result_withdraw) == str:
        return result_withdraw
    def two_password(amount, new_password):
        only_new = new_password
        if type(result_withdraw) == int:
            return withdraw(amount, old_password)
    return two_password
	# Ëß£ÂÜ≥ÂäûÊ≥ïÊòØÔºö
    # ÊÄª‰πãÔºå‰ªéËøôÈÅìÈ¢òÁõÆÈáåÂ≠¶Âà∞ÁöÑÊòØÔºåË¶ÅÂú®ÂºÄÂßãÂÜô‰πãÂâçÂ∞±ÊääÊâÄÊúâÂèØËÉΩÁöÑÊÉÖÂÜµÊÉ≥ÊòéÁôΩ„ÄÇÔºÅÔºÅÔºÅÔºÅÔºÅÔºÅÔºÅÔºÅÔºÅÔºÅÔºÅÔºÅÔºÅ
    result_withdraw = withdraw(0, old_password)
    if type(result_withdraw) == str:
        return result_withdraw
    def two_password(amount, new_put):
        if new_put in [old_password, new_password]:
            return withdraw(amount, old_password)
        else:
            return withdraw(amount, new_put)
    return two_password    
```

### Extra questions

**Acknowledgements.** This interval arithmetic example is based on a classic problem from Structure and Interpretation of Computer Programs, [Section 2.1.4](http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-14.html#%_sec_2.1.4).

**Introduction.** Alyssa P. Hacker is designing a system to help people solve engineering problems. One feature she wants to provide in her system is the ability to manipulate inexact quantities (such as measured parameters of physical devices) with known precision, so that when computations are done with such approximate quantities the results will be numbers of known precision.

Alyssa's idea is to implement interval arithmetic as a set of arithmetic operations for combining "intervals" (objects that represent the range of possible values of an inexact quantity). The result of adding, subracting, multiplying, or dividing two intervals is itself an interval, representing the range of the result.

Alyssa postulates the existence of an abstract object called an "interval" that has two endpoints: a lower bound and an upper bound. She also presumes that, given the endpoints of an interval, she can construct the interval using the data constructor interval. Using the constructor and selectors, she defines the following operations:

```python
def str_interval(x):
    """Return a string representation of interval x."""
    return '{0} to {1}'.format(lower_bound(x), upper_bound(x))

def add_interval(x, y):
    """Return an interval that contains the sum of any value in interval x and
    any value in interval y."""
    lower = lower_bound(x) + lower_bound(y)
    upper = upper_bound(x) + upper_bound(y)
    return interval(lower, upper)
```

#### Q11: Interval Abstraction 

Alyssa's program is incomplete because she has not specified the implementation of the interval abstraction. She has implemented the constructor for you; fill in the implementation of the selectors.

```python
def interval(a, b):
    """Construct an interval from a to b."""
    return [a, b]

def lower_bound(x):
    """Return the lower bound of interval x."""
    "*** YOUR CODE HERE ***"
    return x[0]

def upper_bound(x):
    """Return the upper bound of interval x."""
    "*** YOUR CODE HERE ***"
    return x[1]
```

Louis Reasoner has also provided an implementation of interval multiplication. Beware: there are some data abstraction violations, so help him fix his code before someone [sets it on fire](https://youtu.be/QwoghxwETng). Á¨ëÊ≠ª‰∫ÜÔºåËøôÂøÖÂÆöÊòØDeNero‰∫≤Ëá™Âá∫ÁöÑÈ¢òÁõÆ„ÄÇ

‰∏çË¶ÅËøùÂèçabstraction barrierÔºÅ‰∏çË¶ÅÂØπÊï∞ÊçÆÁöÑÂΩ¢ÂºèÂÅö‰ªª‰ΩïÈ¢ÑËÆæÔºÅËøô‰∏™Á≠îÊ°àÊàë‰∏çÊîæ‰∏äÊù•ÔºåÂéªPycharmÈáåÈù¢ÁúãÂì¶ÔºÅ

```python
def mul_interval(x, y):
    """Return the interval that contains the product of any value in x and any
    value in y."""
    p1 = x[0] * y[0]
    p2 = x[0] * y[1]
    p3 = x[1] * y[0]
    p4 = x[1] * y[1]
    return [min(p1, p2, p3, p4), max(p1, p2, p3, p4)]
```

#### Q12: Sub Interval 

Using reasoning analogous to Alyssa's, define a subtraction function for intervals. Try to reuse functions that have already been implemented.

ÂïäÔºåËøô‰∏™doctstringÊúâÁÇπÊ≠ß‰πâÔºüÂ∫îËØ•ÊòØ x - yÁöÑÂÄº

```python
def sub_interval(x, y):
    """Return the interval that contains the difference between any value in x
    and any value in y."""
    "*** YOUR CODE HERE ***"
    return interval(lower_bound(x) - upper_bound(y), upper_bound(x) - lower_bound(y))    
```

#### Q13: Div Interval 

Alyssa implements division below by multiplying by the reciprocal of `y`. Ben Bitdiddle, an expert systems programmer, looks over Alyssa's shoulder and comments that it is not clear what it means to divide by an interval that spans zero. Add an `assert` statement to Alyssa's code to ensure that no such interval is used as a divisor:

```python
def div_interval(x, y):
    """Return the interval that contains the quotient of any value in x divided by
    any value in y. Division is implemented as the multiplication of x by the
    reciprocal of y."""
    "*** YOUR CODE HERE ***"
    assert lower_bound(y) * upper_bound(y) > 0
    reciprocal_y = interval(1/upper_bound(y), 1/lower_bound(y))
    return mul_interval(x, reciprocal_y)
```

#### Q14: Par Diff 

#### Q15: Multiple References 

#### Q16: Quadratic 

#### Q17: Polynomical

## ÂÖ≥‰∫éTreesÁöÑÈ¢òÁõÆÂêàÈõÜ

#### Q1ÔºöÂæóÂà∞ÊâÄÊúânodeÁöÑÂêàÔºö

```python
def sum_of_nodes(t):
    if is_leaf(t):
        return label(t)
    else:
        s = 0
        for b in branches(t):
            s += sum_of_nodes(b)
        return label(t) + s
        
def sum_nodes(t):
    if is_leaf(t):
        return label(t)
    else:
        return sum([label(t)] + [sum_nodes(b) for b in branches(t)])        

```



## Project: Ants

#### Core Concepts

**The Colony**. This is where the game takes place. The colony consists of several *places* that are chained together to form a tunnel where bees can travel through. The colony has some quantity of food that can be expended to deploy ant troops.

**Places**. A place links to another place to form a tunnel. The player can place a single ant into each place. However, there can be many bees in a single place.

**The Hive**. This is the place where bees originate. Bees exit the hive to enter the ant colony.

**Ants**. Ants are the usable troops in the game that the player places into the colony. Each type of ant takes a different action and requires a different amount of food to place. The two most basic ant types are the `HarvesterAnt`, which adds one food to the colony during each turn, and the `ThrowerAnt`, which throws a leaf at a bee each turn. You will be implementing many more.

**Bees**. Bees are the antogonistic troops in the game that the player must defend the colony from. Each turn, a bee either advances to the next place in the tunnel if no ant is in its way, or it stings the ant in its way. Bees win when at least one bee reaches the end of a tunnel.

**Queen Ant**: There is one queen ant in the whole colony. She is able to attack bees but she also has a special ability of fortifying the other ant troops. Bees can also win if they destroy the queen ant.

#### Core Classes

The concepts described above each have a corresponding class that encapsulates the logic for that concept. Here is a summary of the main classes involved in this game:

- `AntColony`: Represents the colony and some state information about the game, including how much food is available, how much time has elapsed, where the `QueenAnt` resides, and all the `Place`s in the game.
- `Place`: Represents a single place that holds insects. At most one `Ant` can be in a single place, but there can be many `Bee`s. `Place` objects have an `exit` and an `entrance` which are also places. Bees travel through a tunnel tunnel by moving to a `Place`'s `exit`. ==placeÊú¨Ë∫´ÊòØÂÆπÁ∫≥insectÁöÑÂú∞ÊñπÔºåÂπ∂‰∏îÂÆÉ‰πüÂíåÂè¶Â§ñÁöÑplaceÁõ∏Ëøû==
- `Hive`: Represents the hive where `Bee`s start out.
- `Insect`: A superclass for `Ant` and `Bee`. All insects have an `armor` attribute, their remaining health, and a `place` attribute, the `Place` where they are currently located. Each turn, every active `Insect` in the game performs its `action`.
- `Ant`: Represents ants. Each `Ant` subclass has special attributes or a special `action` that distinguish it from other `Ant` types. For example, a `HarvesterAnt` gets food for the colony and a `ThrowerAnt` attacks `Bee`s. Each ant type also has a `food_cost` attribute that indicates how much it costs to deploy one unit of that type of ant.
- `Bee`: Represents bees. Each turn, a bee either moves to the `exit` of its current `Place` if no ant blocks its path, or stings an ant that blocks its path.

### Phase 1: Basic gameplay

In the first phase you will complete the implementation that will allow for basic gameplay with the two basic `Ant`s: the `HarvesterAnt` and the `ThrowerAnt`.

#### Problem 0 (0 pt)

Answer the following questions with your partner after you have read the *entire* `ants.py` file. If you cannot answer these questions, read the file again, consult the core concepts/classes sections above, or ask a question in the Question 0 thread on Piazza.

1. What is the significance of an insect's `armor` attribute? Does this value change? If so, how?

   ==It represents the amount of health the insect has left, so the insect is eliminated when it reaches 0==

   ÁÑ∂ÂêéÂú®ËøôÈáåÔºå‰∏çÂæó‰∏çÊèêÁöÑÊòØÔºåÁ™ÅÁÑ∂ÂèëÁé∞‰πãÂâçËá™Â∑±ÂØπ‰∫é‰ªÄ‰πàÊòØattributeÁöÑÁêÜËß£Êúâ‰∏ÄÁÇπËØØÂå∫Ôºö

   <img src="C:\Users\cyc\AppData\Roaming\Typora\typora-user-images\image-20220202135343178.png" alt="image-20220202135343178" style="zoom:50%;" />

   ‰πãÂâçËá™Â∑±ËßâÂæó1ÔºâÂíå 3ÔºâÈÉΩÊòØÔºå‰ΩÜÊòØÁ≠îÊ°àÊòØ3ÔºâÂì¶ÔºåÂõ†‰∏∫1ÔºâÊòØ‰∏Ä‰∏™methodÔºåmethodÂπ∂‰∏çÁÆóÊòØÂåÖÂê´Âú®attributeÈáåÈù¢ÁöÑ‰∏úË•ø„ÄÇÂéªÁúãÁ¨îËÆ∞Êú¨‰∏äLooking up Attributes by NameÁöÑÂá†‰∏™Ê≠•È™§Â§ßÊ¶ÇÂ∞±ÊòéÁôΩ‰∫ÜÔºåmethodËôΩÁÑ∂‰∏çÁÆóattributeÔºå‰ΩÜÊòØ‰πüÊúâÂêçÂ≠óÔºåÊâÄ‰ª•‰πãÂêé‰∏çËÉΩÂÜçÊúâ‰∏é‰πãÈáçÂêçÁöÑattributeÂì¶„ÄÇ

2. What are all of the attributes of the `Ant` class?

   ==ÁÑ∂ÂêéÊòØ‰∏Ä‰∫õÂÖ≥‰∫éAntÂÜÖattributeÁöÑÈóÆÈ¢ò~==

   <img src="C:\Users\cyc\AppData\Roaming\Typora\typora-user-images\image-20220202144539103.png" alt="image-20220202144539103" style="zoom:50%;" />

   

3. Is the `armor` attribute of the `Ant` class an instance attribute or class attribute? Why?

    ==class, when one Ant gets damaged, all ants receive the same amount of damage==

4. Is the `damage` attribute of an `Ant` subclass (such as ThrowerAnt) an instance attribute or class attribute? Why?

   ==class, all Ants of the same subclass deal the same damage==

5. Which class do both `Ant` and `Bee` inherit from?

6. What do instances of Ant and instances of Bee have in common?

   ==Ants and Bees both have the attributes armor, damage, and place and the methods reduce_armor and action==

7. How many insects can be in a single Place at any given time (until Phase 6 is complete)?

<img src="C:\Users\cyc\AppData\Roaming\Typora\typora-user-images\image-20220202145255384.png" alt="image-20220202145255384" style="zoom:50%;" />

#### Problem 1 (1 pt)

First, add food costs and implement harvesters. Currently, there is no cost for deploying any type of `Ant`, and so there is no challenge to the game. You'll notice that `Ant` starts out with a base `food_cost` of zero. Override this value in each of the subclasses listed below with the correct costs.

<img src="C:\Users\cyc\AppData\Roaming\Typora\typora-user-images\image-20220202150901241.png" alt="image-20220202150901241" style="zoom:50%;" />

<img src="C:\Users\cyc\AppData\Roaming\Typora\typora-user-images\image-20220202150932663.png" alt="image-20220202150932663" style="zoom:50%;" />

<img src="C:\Users\cyc\AppData\Roaming\Typora\typora-user-images\image-20220202151747600.png" alt="image-20220202151747600" style="zoom:50%;" />

Now that deploying `Ant`s cost food, we need to be able gather more food! To fix this issue, implement the `HarvesterAnt` class. A `HarvesterAnt` is a type of `Ant` that adds one food to the `colony.food` total as its `action`.

<font color = pink>ÁÆÄÂçïÔºåone line</font>

ÂÅöÂÆå‰ª•‰∏äÊõ¥Êîπ‰πãÂêéÔºåTry playing the game again (`python3 gui.py`). Once you have placed a `HarvesterAnt`, you should accumulate food each turn. You can also place `ThrowerAnt`s, but you'll see that they can only attack bees that are in their `Place`, so it'll be a little difficult to win.<font color = pink>ÂïäÔºåÂ§™‰∏çÁàΩ‰∫ÜÔºåËµ¢‰∏ç‰∫ÜÂïäÂïäÂïäÂïäÂïä</font>

#### Problem 2 (2 pt)

Complete the `Place` constructor by adding code that tracks entrances. Right now, a `Place` keeps track only of its `exit`. We would like a `Place` to keep track of its entrance as well. A `Place` needs to track only one `entrance`  (<font color = pink>‰ªÄ‰πàÂè´only oneÔºü ÊÄé‰πàÁêÜËß£ÔºüÔºü</font>). Tracking entrances will be useful when an `Ant` needs to see what `Bee`s are in front of it in the tunnel.<font color = pink>Ê≤°ÁúãÊáÇËøôÂè•ËØùÔºå‰ªÄ‰πàÂè´in front ofÔºå‰∏∫Âï•ÊòØÂú®ÂâçÈù¢Ôºü</font>

However, simply passing an entrance to a `Place` constructor will be problematic; we would need to have both the exit and the entrance before creating a `Place`! (It's a [chicken or the egg](https://secure.wikimedia.org/wikipedia/en/wiki/Chicken_or_the_egg) problem.) To get around this problem, we will keep track of entrances in the following way instead. The `Place` constructor should specify that:

- A newly created `Place` always starts with its `entrance` as `None`.
- If the `Place` has an `exit`, then the `exit`'s `entrance` is set to that `Place`.

> *Hint:* Remember that when inside the definition of an `__init__` method, the name `self` is bound to the newly created object.

> *Hint:* Try drawing out two `Place`s next to each other if things get confusing. In the GUI, a place's `entrance` is to its right while the exit is to its left.

<font color = pink>Ê≤°Â§™ÁúãÊáÇÔºå‰∏∫‰ªÄ‰πàÈúÄË¶ÅexitÔºå‰∏∫‰ªÄ‰πàÈúÄË¶ÅentranceÔºü</font>

<img src="C:\Users\cyc\AppData\Roaming\Typora\typora-user-images\image-20220202162636305.png" alt="image-20220202162636305" style="zoom:50%;" />



<font color = pink>‰∏ãÈù¢ËøôÈ¢òÁöÑÁ≠îÊ°àÊòØ2ÔºâÔºå‰∏çÁü•ÈÅì‰∏∫‰ªÄ‰πàÔºåÁúã‰∏çÊáÇ</font>

<img src="C:\Users\cyc\AppData\Roaming\Typora\typora-user-images\image-20220202165710751.png" alt="image-20220202165710751" style="zoom:50%;" />

<font color = pink>Â¶àÂëÄÔºåÁúã‰∫Ü‰∏ãÈù¢ÁöÑ‰∏Ä‰∏™case‰ª•ÂêéÊâçÁÆóÊòéÁôΩÂÆÉÊòØ‰ªÄ‰πàÊÑèÊÄù‰∫Ü</font> Â§ßÊ¶ÇÂ∞±ÊòØÊåáÔºåÂâçÂêéÁöÑ‰∏§‰∏™placeÔºåÂâçÈù¢ÊòØÂêéÈù¢ÁöÑÂÖ•Âè£ÔºåÂêéÈù¢ÊòØÂâçÈù¢ÁöÑÂá∫Âè£„ÄÇÂèØ‰ª•Âú®Á∫∏‰∏ä‰ªéÂ∑¶ÂæÄÂè≥ÁîªplaceËØïËØïÁúãÔºåÁ¨¨‰∏Ä‰∏™palceÂÆÉÊ≤°ÊúâexitÔºàÂõ†‰∏∫Âà∞Â§¥‰∫ÜÂòõÔºâÔºåÁÑ∂ÂêéÂú®Âè≥ËæπÊ∑ª‰∏Ä‰∏™placeÔºåÂ∞±ÊòéÁôΩ‰∫Ü„ÄÇIf the `Place` has an `exit`, then the `exit`Ôºà==ËøôÈáåÁöÑexitÔºåÊú¨Ë∫´Â∞±ÊòØ‰∏Ä‰∏™placeÔºåÂè™‰∏çËøáÂÆÉÊòØÂè¶‰∏Ä‰∏™placeÁöÑÂá∫Âè£ÁΩ¢‰∫Ü==Ôºâ's `entrance` is set to that `Place`.

<img src="C:\Users\cyc\AppData\Roaming\Typora\typora-user-images\image-20220202170602877.png" alt="image-20220202170602877" style="zoom:50%;" />

<img src="C:\Users\cyc\AppData\Roaming\Typora\typora-user-images\image-20220202170644902.png" alt="image-20220202170644902" style="zoom:50%;" />



Ê†πÊçÆHintÁöÑÂÜÖÂÆπÂ∞±ËÉΩÂ§üÈ°∫Âà©ÂÜôÂá∫ÔºåÊÑüËßâÂ•ΩÂ¶ôÂïäÔºåÂÖ≥‰∫é‰ªÄ‰πàÊòØËæìÂÖ•ÁöÑÂèÇÊï∞Ôºå‰ªÄ‰πàÊòØself„ÄÇ(‡∏á ‚Ä¢_‚Ä¢)‡∏á

#### Problem 3 (1 pt)

In order for a `ThrowerAnt` to attack, it must know which bee it should hit. The provided implementation of the `nearest_bee` method in the `ThrowerAnt` class only allows them to hit bees in the same `Place`. Your job is to fix it so that a `ThrowerAnt` will `throw_at` the nearest bee in front of it that is not still in the `Hive`.

The `nearest_bee` method returns a random `Bee` from the nearest place that contains bees. Places are inspected in order by following their `entrance` attributes.

- Start from the current `Place` of the `ThrowerAnt`.
- For each place, return a random bee if there is any, or consider the next place that is stored as the current place's `entrance`.
- If there is no bee to attack, return `None`.

> *Hint*: The `random_or_none` function provided in `ants.py` returns a random element of a sequence or `None` if the sequence is empty.

After implementing `nearest_bee`, a `ThrowerAnt` should be able to `throw_at` a `Bee` in front of it that is not still in the `Hive`. Make sure that your ants do the right thing! To start a game with ten food (for easy testing):

```python
python3 gui.py --food 10
```

==ÂÖàÁúã‰∏Ä‰∏ãÁõ∏ÂÖ≥ÁöÑÁêÜËß£È¢ò==Ôºö

<img src="C:\Users\cyc\AppData\Roaming\Typora\typora-user-images\image-20220202172750798.png" alt="image-20220202172750798" style="zoom:50%;" />

<img src="C:\Users\cyc\AppData\Roaming\Typora\typora-user-images\image-20220202172832712.png" alt="image-20220202172832712" style="zoom:50%;" />

<img src="C:\Users\cyc\AppData\Roaming\Typora\typora-user-images\image-20220202173000267.png" alt="image-20220202173000267" style="zoom:50%;" />

ËøôÈÅìÈ¢òÁõÆÊØîËæÉÈöæÁöÑÂú∞ÊñπÂú®‰∫éÔºö‰∏çËÉΩÊîπÂèòself.placeÔºåÈÇ£Ë¶ÅÊÄé‰πàÂÜôÂë¢ÔºåÁÉ¶Ê≠ª‰∫ÜÔºàÂÜôÂá∫Êù•‰∫ÜÔºåÂæÆÁ¨ëÔºå‰ΩÜÊòØ‰∏çÁü•ÈÅìÊòØÊÄé‰πàÂõû‰∫ã„ÄÇÔºâ

![image-20220202183703801](C:\Users\cyc\AppData\Roaming\Typora\typora-user-images\image-20220202183703801.png)

Âè¶‰∏Ä‰∏™Âç°‰Ωè‰∫ÜÁöÑÂú∞ÊñπÊòØÔºåÊÄé‰πàÂà§Êñ≠‰∏ã‰∏Ä‰∏™placeÊòØ‰∏çÊòØHive„ÄÇÊàëÊúÄÂºÄÂßãÂÜôÁöÑÊòØÔºàxxxx == HiveÔºåÂêéÊù•ÂèëÁé∞hiveÊòØ‰∏Ä‰∏™classÔºåÂ∫îËØ•ÊòØxxxÁöÑÂêçÂ≠óÊòØ‰∏çÊòØ‚ÄôHive‚ÄòÔºâ

### Phase 2: Ants Attack

Now that you've implemented basic gameplay with two types of `Ant`s, let's add some flavor to the ways ants can attack bees. In this phase, you'll be implementing several different `Ant`s with different offensive capabilities.

After you implement each `Ant` subclass in this section, you'll need to set its `implemented` attribute to `True` so that that type of ant will show up in the GUI. Feel free to try out the game with each new ant to test the functionality!

With your Phase 2 ants, try `python3 ants_gui.py -d easy` to play against a full swarm of bees in a multi-tunnel layout and try `-d normal`, `-d hard`, or `-d insane` if you want a real challenge! If the bees are too numerous to vanquish, you might need to create some new ants.

#### Problem 4 (2 pt)

The `ThrowerAnt` is a great offensive unit, but it'd be nice to have a cheaper unit that can throw. Implement two subclasses of `ThrowerAnt` that are less costly but have constraints on the distance they can throw:

- The `LongThrower` can only `throw_at` a `Bee` that is found after following at least 5 `entrance` transitions. It cannot hit `Bee`s that are in the same `Place` as it or the first 4 `Place`s in front of it. If there are two `Bees`, one too close to the `LongThrower` and the other within its range, the `LongThrower` should throw past the closer `Bee`, instead targeting the farther one, which is within its range.
- The `ShortThrower` can only `throw_at` a `Bee` that is found after following at most 3 `entrance` transitions. It can only hit `Bee`s in the same `Place` as it and 3 `Place`s in front of it.

Neither of these specialized throwers can `throw_at` a `Bee` that is exactly 4 `Place`s away. Placing a single one of these (and no other ants) should never win a default gameÔºà‰∏∫Âï•Â∞±‰∏ÄÂÆö‰∏ç‰ºöËµ¢ÊçèÔºüÔºüÔºüÔºâ.

<img src="C:\Users\cyc\AppData\Roaming\Typora\typora-user-images\image-20220202224620184.png" alt="image-20220202224620184" style="zoom:50%;" />

A good way to approach the implementation to `ShortThrower` and `LongThrower` is to have it inherit the `nearest_bee` method from the base `ThrowerAnt` class. The logic of choosing which bee a thrower ant will attack is essentially the same, except the `ShortThrower` and `LongThrower` ants have maximum and minimum ranges, respectively.

To implement these behaviors, you may need to modify the `nearest_bee` method to reference `min_range` and `max_range` attributes, and only return a bee that is in range.

The original `ThrowerAnt` has no minimum or maximum range, so make sure that its `min_range` and `max_range` attributes should reflect that. Then, implement the subclasses `LongThrower` and `ShortThrower` with appropriately constrained ranges and correct food costs.

> *Hint:* `float('inf')` returns an infinite positive value represented as a float that can be compared with other numbers.

Don't forget to set the `implemented` class attribute of `LongThrower` and `ShortThrower` to `True`.

Before writing any code, test your understanding of the problem:

```
python3 ok -q 04 -u
```

After writing code, test your implementation:

```
python3 ok -q 04
```

#### Problem 5 (2 pt)

Implement the `FireAnt`. A `FireAnt` has a special `reduce_armor` method: when the `FireAnt`'s armor reaches zero or lower, it will reduce the armor of *all* `Bee`s in the same `Place` as the `FireAnt` by its `damage` attribute (defaults to `3`).

<img src="C:\Users\cyc\AppData\Roaming\Typora\typora-user-images\image-20220202224741999.png" alt="image-20220202224741999" style="zoom:50%;" />

> *Hint:* Damaging a bee may cause it to be removed from its place. If you iterate over a list, but change the contents of that list at the same time, you may not visit all the elements. As the [Python tutorial](https://docs.python.org/3/tutorial/controlflow.html#for-statements) suggests, "If you need to modify the sequence you are iterating over while inside the loop (for example to duplicate selected items), it is recommended that you first make a copy." You can copy a list by calling the `list` constructor or slicing the list from the beginning to the end.

Once you've finished implementing the `FireAnt`, give it a class attribute `implemented` with the value `True`.

Before writing any code, test your understanding of the problem:

```
python3 ok -q 05 -u
```

==‰∏äÈù¢ÁöÑÈóÆÈ¢òÂ¶Ç‰∏ãÔºö==

<img src="C:\Users\cyc\AppData\Roaming\Typora\typora-user-images\image-20220203113659772.png" alt="image-20220203113659772" style="zoom:50%;" />

<img src="C:\Users\cyc\AppData\Roaming\Typora\typora-user-images\image-20220203113828779.png" alt="image-20220203113828779" style="zoom:50%;" />

<img src="C:\Users\cyc\AppData\Roaming\Typora\typora-user-images\image-20220203113920547.png" alt="image-20220203113920547" style="zoom:50%;" />

After writing code, test your implementation:

```
python3 ok -q 05
```

You can also test your program by playing a game or two! A `FireAnt` should destroy all co-located Bees when it is stung. To start a game with ten food (for easy testing):

```
python3 gui.py --food 10
```

<font color = pink>ËøôÈ¢ò‰∏çÊòØÂæàÈöæÔºåÂÅöÁöÑÊå∫Âø´ÁöÑ</font>

#### Problem 6 (2 pt)

Implement the `HungryAnt`, which will select a random `Bee` from its `place` and eat it whole. After eating a `Bee`, it must spend 3 turns digesting before eating again.

<img src="C:\Users\cyc\AppData\Roaming\Typora\typora-user-images\image-20220203124809882.png" alt="image-20220203124809882" style="zoom:50%;" />

Give `HungryAnt` a `time_to_digest` class attribute that holds the number of turns that it takes a `HungryAnt` to digest (default to 3). Also, give each `HungryAnt` an instance attribute `digesting` that counts the number of turns it has left to digest (default is 0, since it hasn't eaten anything at the beginning).

Implement the `action` method of the `HungryAnt` to check if it's digesting; if so, decrement its `digesting` counter. Otherwise, eat a random `Bee` in its `place` by reducing the `Bee`'s armor to 0 and restart the `digesting` timer.

Before writing any code, test your understanding of the problem:

```
python3 ok -q 06 -u
```

==ÂÖàÊù•Áúã‰∏Ä‰∏ãËøô‰∫õÈóÆÈ¢òÔºö==

<img src="C:\Users\cyc\AppData\Roaming\Typora\typora-user-images\image-20220203124847314.png" alt="image-20220203124847314" style="zoom:50%;" />

<img src="C:\Users\cyc\AppData\Roaming\Typora\typora-user-images\image-20220203124922745.png" alt="image-20220203124922745" style="zoom:50%;" />

<img src="C:\Users\cyc\AppData\Roaming\Typora\typora-user-images\image-20220203124946293.png" alt="image-20220203124946293" style="zoom:50%;" />



After writing code, test your implementation:

```
python3 ok -q 06
```

<font color = pink>ÂïäÔºåËøôÈÅìÈ¢òÁõÆÂÅöÂæóÁ®çÂæÆÊúâÁÇπ‰πÖÔºå‰∏ÄÊòØÈ¢òÁõÆË¶ÅÊ±ÇÊõ¥Â§ö‰∫ÜÔºå‰∫åÊòØÂèëÁé∞‰∫Ü‰∏Ä‰∫õOOPÂÜôÊ≥ï‰∏≠ÈúÄË¶ÅÂ∞èÂøÉÊ≥®ÊÑèÁöÑÁªÜËäÇÔºåÈÉΩÂÜôÂú®PycharmÊ≥®ÈáäÈáå‰∫Ü</font>

#### Problem 7 (2 pt)

Implement the `NinjaAnt`, which damages all `Bee`s that pass by, but can never be stung.

<img src="C:\Users\cyc\AppData\Roaming\Typora\typora-user-images\image-20220203131802480.png" alt="image-20220203131802480" style="zoom:50%;" />

A `NinjaAnt` does not block the path of a `Bee` that flies by. To implement this behavior, first modify the `Ant` class to include a new class attribute `blocks_path` that is `True` by default. Set the value of `blocks_path` to `False` in the `NinjaAnt` class.

Second, modify the `Bee`'s method `blocked` to return `False` if either there is no `Ant` in the `Bee`'s `place` or if there is an `Ant`, but its `blocks_path` attribute is `False`. Now `Bee`s will just fly past `NinjaAnt`s.

Finally, we want to make the `NinjaAnt` damage all `Bee`s that fly past. Implement the `action` method in `NinjaAnt` to reduce the armor of all `Bee`s in the same `place` as the `NinjaAnt` by its `damage` attribute. Similar to the `FireAnt`, you must iterate over a list of bees that may change.

Before writing any code, test your understanding of the problem:

```
python3 ok -q 07 -u
```

==ÂÖàÁúã‰∏Ä‰∏ãËøô‰∫õÈ¢òÁõÆÂìàÔºö==

<img src="C:\Users\cyc\AppData\Roaming\Typora\typora-user-images\image-20220203133131203.png" alt="image-20220203133131203" style="zoom:50%;" />

Á≠îÊ°àÂ∫îËØ•ÊòØ2Ôºâ

<img src="C:\Users\cyc\AppData\Roaming\Typora\typora-user-images\image-20220203133227213.png" alt="image-20220203133227213" style="zoom:50%;" />

<img src="C:\Users\cyc\AppData\Roaming\Typora\typora-user-images\image-20220203133337184.png" alt="image-20220203133337184" style="zoom:50%;" />



After writing code, test your implementation:

```
python3 ok -q 07
```

For a challenge, try to win a game using only `HarvesterAnt` and `NinjaAnt`.

<font color = pink>ÂÅöÂæó‰πüÊå∫Âø´ÁöÑÔºåË¶ÅÊ≥®ÊÑèÁöÑÊòØÂ¶ÇÊûú‰Ω†Ë¶ÅÂ§çÂà∂‰∏Ä‰∏™ÂàóË°®Ôºå‰∏çÂ∫îËØ•Áî®ËµãÂÄºÔºåËÄåÊòØË¶ÅÁî®ÂàáÁâáÊàñËÄÖÂú®construct‰∏Ä‰∏™ÂêåÊ†∑ÁöÑ</font>



### Phase 3: But They Also Protect

We now have some great offensive troops to help vanquish the bees, but let's make sure we're also keeping our defensive efforts up. In this phase you will implement ants that have special defensive capabiltities such as increased armor and the ability to protect other ants.

#### Problem 8 (1 pt)

We are going to add some protection to our glorious `AntColony` by implementing the `WallAnt`, which is an ant that does nothing each turn. A `WallAnt` is useful because it has a large `armor` value.

| **Class**                                                    | **Food Cost** | **Armor** |
| ------------------------------------------------------------ | ------------- | --------- |
| ![img](https://inst.eecs.berkeley.edu/~cs61a/sp18/proj/ants/assets/insects/ant_wall.gif) `WallAnt` | 4             | 4         |

Unlike with previous ants, we have not provided you with a class header. Implement the `WallAnt` class from scratch. Give it a class attribute `name` with the value `'Wall'` (so that the graphics work) and a class attribute `implemented` with the value `True` (so that you can use it in a game).

Before writing any code, test your understanding of the problem:

```
python3 ok -q 08 -u
```

<img src="C:\Users\cyc\AppData\Roaming\Typora\typora-user-images\image-20220203160316106.png" alt="image-20220203160316106" style="zoom:50%;" />

<img src="C:\Users\cyc\AppData\Roaming\Typora\typora-user-images\image-20220203160328348.png" alt="image-20220203160328348" style="zoom:50%;" />

<img src="C:\Users\cyc\AppData\Roaming\Typora\typora-user-images\image-20220203160415937.png" alt="image-20220203160415937" style="zoom:50%;" />

<img src="C:\Users\cyc\AppData\Roaming\Typora\typora-user-images\image-20220203160444676.png" alt="image-20220203160444676" style="zoom:50%;" />



After writing code, test your implementation:

```
python3 ok -q 08
```

<font color = pink>ËôΩÁÑ∂Ë¶Åstart from scratch,‰ΩÜÊòØÁÆÄÂçïÂì¶„ÄÇ</font>

#### Problem 9 (4 pt)

Right now, our ants are quite frail. We'd like to provide a way to help them last longer against the onslaught of the bees. Enter the `BodyguardAnt`.

| **Class**                                                    | **Food Cost** | **Armor** |
| ------------------------------------------------------------ | ------------- | --------- |
| ![img](https://inst.eecs.berkeley.edu/~cs61a/sp18/proj/ants/assets/insects/ant_bodyguard.gif) `BodyguardAnt` | 4             | 2         |

A `BodyguardAnt` differs from a normal ant because it is a `container`; it can contain another ant and protect it, all in one `Place`. When a `Bee` stings the ant in a `Place` where one ant contains another, only the container is damaged. The ant inside the container can still perform its original action. If the container perishes, the contained ant still remains in the place (and can then be damaged).

Each `BodyguardAnt` has an instance attribute `ant` that stores the ant it contains. It initially starts off as `None`, to indicate that no ant is being protected. Implement the `contain_ant` method so that it sets the bodyguard's `ant` instance attribute to the passed in `ant` argument. Also implement the `BodyguardAnt`'s `action` method to perform its `ant`'s action if it is currently containing an ant.

In addition, you will need to make the following modifications throughout your program so that a container and its contained ant can both occupy a place at the same time (a maximum of two ants per place), but only if exactly one is a `container`:

1. Add an `Ant.container` class attribute that indicates whether a subclass of `Ant` is a container. For all `Ant` instances, except for `BodyguardAnt` instances, `container` should be `False`. The `BodyguardAnt.container` attribute should be `True`.
2. Implement the method `Ant.can_contain` which takes an `other` ant as an argument and returns `True` if:
   - This ant is a container.
   - This ant does not already contain another ant.
   - The other ant is not a container.
3. Modify `Place.add_insect` to allow a container and a non-container ant to occupy the same place according to the following rules:
   - If the `ant` currently occupying a `Place` can contain the `insect` (an `Ant`) passed to `add_insect`, then it does.
   - If the `insect` (an `Ant`) passed to `add_insect` can contain the `ant` currently occupying a `Place`, then it does. Also, set the `Place`'s `ant` to be the container insect.
   - If neither `Ant` can contain the other, raise the same `AssertionError` as before (the one already present in the starter code).

Before writing any code, test your understanding of the problem:

```
python3 ok -q 09 -u
```

<img src="C:\Users\cyc\AppData\Roaming\Typora\typora-user-images\image-20220203162329258.png" alt="image-20220203162329258" style="zoom:50%;" />

<img src="C:\Users\cyc\AppData\Roaming\Typora\typora-user-images\image-20220203162612965.png" alt="image-20220203162612965" style="zoom:50%;" />

<img src="C:\Users\cyc\AppData\Roaming\Typora\typora-user-images\image-20220203162925026.png" alt="image-20220203162925026" style="zoom:50%;" />





After writing code, test your implementation:

```
python3 ok -q 09
```

<font color = pink>ÂïäÊú¨Ë∫´ÊòØ4ÂàÜÁöÑÈ¢òÁõÆÊâÄ‰ª•ÂÜôÂæó‰πÖ‰∫Ü‰∏ÄÁÇπ„ÄÇ‰ΩÜÊòØËøòËä±‰∫ÜÂæàÂ§öÊó∂Èó¥Âú®Êâæbug‰∏äÔºåÊúÄÂêéÂèëÁé∞ÊòØÊãºÂÜôÈîôËØØÔºåÈ¢ùÔºåÊó†ËØ≠„ÄÇÂ¶Ç‰∏ãÂõæÔºö</font>

<img src="C:\Users\cyc\AppData\Roaming\Typora\typora-user-images\image-20220203190721272.png" alt="image-20220203190721272" style="zoom:80%;" />

#### Problem 10 (1 pt)

The `BodyguardAnt` provides great defense, but they say the best defense is a good offense. The `TankAnt` is a container that protects an ant in its place and also deals 1 damage to all bees in its place each turn.

| **Class**                                                    | **Food Cost** | **Armor** |
| ------------------------------------------------------------ | ------------- | --------- |
| ![img](https://inst.eecs.berkeley.edu/~cs61a/sp18/proj/ants/assets/insects/ant_tank.gif) `TankAnt` | 6             | 2         |

You should not need to modify any code outside of the `TankAnt` class. If you find yourself needing to make changes elsewhere, look for a way to write your code for the previous question such that it applies not just to `BodyguardAnt` and `TankAnt` objects, but to `container` ants in general.

Before writing any code, test your understanding of the problem:

```
python3 ok -q 10 -u
```

After writing code, test your implementation:

```
python3 ok -q 10
```

<font color = pink>Â§ßÈÉ®ÂàÜÁöÑÂ∑•‰ΩúÂú®Ââç‰∏ÄÈ¢òÂ∑≤ÁªèÂÜôÂ•Ω‰∫ÜÔºåÊâÄ‰ª•Ëøô‰∏ÄÈ¢òË¶ÅÊ∑ªÂä†ÁöÑÂ∞±Âá†Ë°å</font>

### Phase 4: Water and Might

In the final phase, you're going to add one last kick to the game by introducing a new type of place and new ants that are able to occupy this place. One of these ants is the most important ant of them all: the queen of the colony

#### Problem 11 (1 pt)

Let's add water to the colony! Currently there are only two types of places, the `Hive` and a basic `Place`. To make things more interesting, we're going to create a new type of `Place` called `Water`.

Only an ant that is `watersafe` can be deployed to a `Water` place. In order to determine whether an `Insect` is `watersafe`, add a new attribute to the `Insect` class named `watersafe` that is `False` by default. Since bees can fly, make their `watersafe` attribute `True`, overriding the default.

Now, implement the `add_insect` method for `Water`. First call `Place.add_insect` to add the insect, regardless of whether it is watersafe. Then, if the insect is not watersafe, reduce the insect's armor to 0 by invoking `reduce_armor`. *Do not copy and paste code.* Instead, use methods that have already been defined and make use of inheritance to reuse the functionality of the `Place` class.

Before writing any code, test your understanding of the problem:

```
python3 ok -q 11 -u
```

After writing code, test your implementation:

```
python3 ok -q 11
```

<img src="C:\Users\cyc\AppData\Roaming\Typora\typora-user-images\image-20220203192154945.png" alt="image-20220203192154945" style="zoom:50%;" />

<img src="C:\Users\cyc\AppData\Roaming\Typora\typora-user-images\image-20220203192220805.png" alt="image-20220203192220805" style="zoom:50%;" />

<img src="C:\Users\cyc\AppData\Roaming\Typora\typora-user-images\image-20220203192432154.png" alt="image-20220203192432154" style="zoom:50%;" />

==‰∏äÂõæÈóÆÈ¢òÁ≠îÊ°àÊòØ3ÔºâÂì¶„ÄÇ==

Once you've finished this problem, play a game that includes water. To access the `wet_layout` which includes water, add the `--water` option (or `-w` for short) when you start the game.

```
python3 gui.py --water
```

<font color = pink>ËøôÈáåÊúâ‰∏™ÁñëÈóÆÊ≤°ÊúâÊáÇÔºåÂÜôÂú®PycharmÈáåÈù¢‰∫Ü</font>

#### Problem 12 (1 pt)

Currently there are no ants that can be placed on `Water`. Implement the `ScubaThrower`, which is a subclass of `ThrowerAnt` that is more costly and `watersafe`, but otherwise identical to its base class. A `ScubaThrower` should not lose its armor when placed in `Water`.

| **Class**                                                    | **Food Cost** | **Armor** |
| ------------------------------------------------------------ | ------------- | --------- |
| ![img](https://inst.eecs.berkeley.edu/~cs61a/sp18/proj/ants/assets/insects/ant_scuba.gif) `ScubaThrower` | 6             | 1         |

We have not provided you with a class header. Implement the `ScubaThrower` class from scratch. Give it a class attribute `name` with the value `'Scuba'` (so that the graphics work) and remember to set the class attribute `implemented` with the value `True` (so that you can use it in a game).

Before writing any code, test your understanding of the problem:

```
python3 ok -q 12 -u
```

After writing code, test your implementation:

```
python3 ok -q 12
```

<font color = pink>Âõ†‰∏∫‰∏ÄÂ§ßÈÉ®ÂàÜÈÉΩÊòØ‰ªéThrowerÁªßÊâøÁöÑÔºåÊâÄ‰ª•ÂæàÁÆÄÂçïÂì¶„ÄÇ</font>

#### Problem 13 (4 pt)

Finally, implement the `QueenAnt`. The queen is a waterproof `ScubaThrower` that inspires her fellow ants through her bravery. The `QueenAnt` doubles the damage of all the ants behind her each time she performs an action. Once an ant's damage has been doubled, it is *not* doubled again for subsequent turns.

| **Class**                                                    | **Food Cost** | **Armor** |
| ------------------------------------------------------------ | ------------- | --------- |
| ![img](https://inst.eecs.berkeley.edu/~cs61a/sp18/proj/ants/assets/insects/ant_queen.gif) `QueenAnt` | 7             | 1         |

However, with great power comes great responsibility. The `QueenAnt` is governed by three special rules:

1. If the queen ever has its armor reduced to 0, the bees win. The bees also still win if any bee reaches the end of a tunnel. You can call `bees_win()` to signal to the simulator that the game is over.
2. There can be only one true queen. Any queen instantiated beyond the first one is an impostor, and should have its armor reduced to 0 upon taking its first action, without doubling any ant's damage or throwing anything. If an impostor dies, the game should still continue as normal.
3. The true (first) queen cannot be removed. Attempts to remove the queen should have no effect (but should not cause an error). You will need to modify the `remove_insect` method of `Place` to enforce this condition.

Some hints:

- All instances of the same class share the same class attributes. How can you use this information to tell whether a QueenAnt instance is the true QueenAnt?

- You can find each `Place` in a tunnel behind the `QueenAnt` by starting at the ant's `place.exit` and then repeatedly following its `exit`. To detect whether a `Place` is at the end of a tunnel, check whether its `exit` is `None`.

- To make sure that you don't double the damage of the same ant twice, maintain a list of all the ants that have been doubled.

- Remember that there can be two ants in the same place; if this is the case, make sure to double both their damage attributes.

- You may find the `isinstance` function useful for checking if something is an instance of an object. For example:

  ```
  >>> a = Foo()
  >>> isinstance(a, Foo)
  True
  ```

Before writing any code, test your understanding of the problem:

```
python3 ok -q 13 -u
```

<img src="C:\Users\cyc\AppData\Roaming\Typora\typora-user-images\image-20220203204102306.png" alt="image-20220203204102306" style="zoom:50%;" />

Á≠îÊ°àÊòØ1ÔºâÂìàÔºÅ

After writing code, test your implementation:

```
python3 ok -q 13
```

<font color = pink>Âïä~~ËøôÈ¢òÂÅö‰∫ÜÈùûÂ∏∏‰πÖÔºåÂõ†‰∏∫ÊÄé‰πàÂà§Êñ≠containerÈÇ£ÁßçantÂç°‰∫ÜÂæà‰πÖÔºåÂÖ∂‰ΩôËøòÊúâ‰∏Ä‰∫õÁªÜËäÇ‰∏äÁöÑÈîôËØØÔºå‰ΩÜÊòØÁúã‰∫ÜtracebackÂ∑Æ‰∏çÂ§öÈÉΩËÉΩÊØîËæÉÂø´Âú∞ÊîπÂá∫Êù•„ÄÇÊÑüËßâÂ∞±ÊòØÂØπ‰∫éclassÂíåclass‰πãÈó¥ÁöÑÂêà‰Ωú„ÄÅ‰ª•Âèäclass attributeÁöÑÊÄßË¥®Ëøò‰∏çÂ§üÁÜüÁªÉ„ÄÇ</font>

#### Extra Credit (2 pt)

Implement two final thrower ants that do zero damage, but instead produce a temporary "effect" on the `action` method of a `Bee` instance that they `throw_at`. This effect is an alternative action that lasts for a certain number of `.action(colony)` calls, after which the `Bee`'s action reverts to its original behavior.

We will be implementing two new ants that subclass `ThrowerAnt`.

- `SlowThrower` applies a slow effect for 3 turns.
- `StunThrower` applies a stun effect for 1 turn.

| **Class**                                                    | **Food Cost** | **Armor** |
| ------------------------------------------------------------ | ------------- | --------- |
| <img src="https://inst.eecs.berkeley.edu/~cs61a/sp18/proj/ants/assets/insects/ant_slow.gif" alt="img" style="zoom:50%;" /> `SlowThrower` | 4             | 1         |
| <img src="https://inst.eecs.berkeley.edu/~cs61a/sp18/proj/ants/assets/insects/ant_stun.gif" alt="img" style="zoom: 33%;" /> `StunThrower` | 6             | 1         |

In order to complete the implementations of these two ants, you will need to set their class attributes appropriately and implement the following three functions:

1. `make_slow` is an effect that takes an `action` method and returns a new `action` method that performs the original action on turns where `colony.time` is even and does nothing on other turns.
2. `make_stun` is an effect that takes an `action` method and returns a new `action` method that does nothing.
3. `apply_effect` takes an `effect` (either `make_slow` or `make_stun`), a `Bee`, and a `duration`. It uses the effect on the `Bee`'s `.action` method to produce a new `action` method, and then arranges to have the new method become the bee's action method for the next `duration` times that `.action` is called, after which the previous `.action` method is restored.

You can run some provided tests, but they are not exhaustive:

```
python3 ok -q EC -u
python3 ok -q EC
```

Make sure to test your code! Your code should be able to apply multiple effects on a target; each new effect applies to the current (possibly affected) action method of the bee.

## Lab 06: Object Oriented Programming

### Topics

#### Nonlocal

We say that a variable defined in a frame is ==*local*== to that frame. A variable is **nonlocal** to a frame if it is defined in the environment that the frame belongs to but not the frame itself, i.e. in its parent or ancestor frame.

So far, we know that we can access variables in parent frames:

```python
def make_adder(x):
    """ Returns a one-argument function that returns the result of
    adding x and its argument. """
    def adder(y):
        return x + y
    return adder
```

Here, when we call `make_adder`, we create a function `adder` that is able to look up the name `x` in `make_adder`'s frame and use its value.

==However, we haven't been able to *modify* variable in parent frames==. Consider the following function:

```python
def make_counter():
    """Makes a counter function.

    >>> counter = make_counter()
    >>> counter()
    1
    >>> counter()
    2
    """
    count = 0
    def counter():
        count = count + 1
        return count
    return counter
```

The inner function `counter` attempts to update the vairable `count` in its parent frame. Running this function's doctests, we find that it causes the following error:

```python
UnboundLocalError: local variable 'count' referenced before assignment
```

Why does this happen? When we execute an assignment statement, remember that we are either creating a new binding in our current frame or we are updating an old one in the current frame. For example, the line `count = ...` in `counter`, is creating the local variable `count` inside `counter`'s frame. This assignment statement tells Python to expect a variable called `count` inside `counter`'s frame, so Python will not look in parent frames for this variable. However, notice that we tried to compute `count + 1` before the local variable was created! That's why we get the `UnboundLocalError`. <font color =pink>ËøôÈáåÁöÑÈîôËØØÂéüÂõ†ÂíåÊàë&ÁªôÁªô‰∏ÄÂºÄÂßãÊÉ≥ÁöÑ‰∏ç‰∏ÄÊ†∑Ôºå‰ΩÜÊòØÂèçÊ≠£ËøôÊ†∑Â∞±ÊòØ‰∏çÂØπÁöÑÔºåÊÆäÈÄîÂêåÂΩíÂìà„ÄÇ</font>

To avoid this problem, we introduce the `nonlocal` keyword. It allows us to update a variable in a parent frame!

> Some important things to keep in mind when using `nonlocal`
>
> - `nonlocal` cannot be used with global variables (names defined in the global frame). <font color = pink>Ë¶ÅÊ≥®ÊÑèËøô‰∏ÄÁÇπÂì¶ÔºÅ</font>
> - If no nonlocal variable is found with the given name, a `SyntaxError` is raised.
> - A name that is already local to a frame cannot be declared as nonlocal.

Consider this improved example:

```python
 def make_counter():
    """Makes a counter function.

    >>> counter = make_counter()
    >>> counter()
    1
    >>> counter()
    2
    """
    count = 0
    def counter():
        nonlocal count
        count = count + 1
        return count
    return counter
```

The line `nonlocal count` tells Python that `count` will not be local to this frame, so it will look for it in parent frames. Now we can update `count` without running into problems.

#### Object-Oriented Programming

In this lab we'll be diving into **object-oriented programming** (OOP), a model of programming that allows you to think of data in terms of "objects" with their own characteristics and actions, just like objects in real life! This is very powerful and allows you to create objects that are specific to your program -- you can read up on all the details [here](http://composingprograms.com/pages/25-object-oriented-programming.html).

#### OOP Example: Car Class

Professor Hilfinger is running late, and needs to get from San Francisco to Berkeley before lecture starts. He'd take BART, but that will take too long. It'd be great if he had a car. A monster truck would be best, but a car will do -- for now...

In `car.py`, you'll find a class called `Car`. A **class** is a blueprint for creating objects of that type. In this case, the `Car` class statement tells us how to create `Car` objects.

##### Constructor

Let's build Professor Hilfinger a car! Don't worry, you won't need to do any physical work -- the **constructor** will do it for you. The **constructor** of a class is a function that creates an **instance**, or one single occurrence, of the object outlined by the class. In Python, the constructor method is named `__init__`. Note that there must be two underscores on each side of `init`. The `Car` class' constructor looks like this:

```python
def __init__(self, make, model):
    self.make = make
    self.model = model
    self.color = 'No color yet. You need to paint me.'
    self.wheels = Car.num_wheels
    self.gas = Car.gas
```

The `__init__` method for `Car` has three parameters. The first one, `self`, is automatically bound to the newly created `Car` object. The second and third parameters, `make` and `model`, are bound to the arguments passed to the constructor, meaning when we make a `Car` object, we must provide two arguments. Don't worry about the code inside the body of the constructor for now.

Let's make our car. Professor Hilfinger would like to drive a Tesla Model S to lecture. We can construct an instance of `Car` with `'Tesla'` as the `make` and `'Model S'` as the `model`. Rather than calling `__init__` explicitly, Python allows us to make an instance of a class by using the name of the class.

```
>>> hilfingers_car = Car('Tesla', 'Model S')
```

Here, `'Tesla'` is passed in as the `make`, and 'Model S' as the `model`. Note that we don't pass in an argument for `self`, since its value is always the object being created. An **object** is an instance of a class. In this case, `hilfingers_car` is now bound to a `Car` object or, in other words, an instance of the `Car` class.

##### Attributes

So how are the `make` and `model` of Professor Hilfinger's car actually stored? Let's talk about **attributes** of instances and classes. Here's a snippet of the code in `car.py` of the instance and class attributes in the `Car` class:

```python
class Car(object):
    num_wheels = 4
    gas = 30
    headlights = 2
    size = 'Tiny'

    def __init__(self, make, model):
        self.make = make
        self.model = model
        self.color = 'No color yet. You need to paint me.'
        self.wheels = Car.num_wheels
        self.gas = Car.gas

    def paint(self, color):
        self.color = color
        return self.make + ' ' + self.model + ' is now ' + color
```

In the first two lines of the constructor, the name `self.make` is bound to the first argument passed to the constructor and `self.model` is bound to the second. These are two examples of instance attributes. An **instance attribute** is a quality that is specific to an instance, and thus can only be accessed using *dot notation* (separating the instance and attribute with a period) on an instance. In this case, `self` is bound to our instance, so `self.model` references our instance's model.

Our car has other instance attributes too, like `color` and `wheels`. As instance attributes, the make, model, and color of `hilfingers_car` do not affect the make, model, and color of other cars.

On the other hand, a **class attribute** is a quality that is shared among *all* instances of the class. For example, the `Car` class has four class attributes defined at the beginning of a class: `num_wheels = 4`, `gas = 30`, `headlights = 2` and `size = 'Tiny'`. The first says that all cars have `4` wheels.

You might notice in the `__init__` method of the `Car` class, the instance attribute `gas` is initialized to the value of `Car.gas`, the class attribute. Why don't we just use the class attribute, then? The reason is because each `Car`'s `gas` attribute needs to be able to change independently of each other. If one `Car` drives for a while, it should use up some `gas`, and that `Car` instance should reflect that by having a lower `gas` value. However, all other `Car`s shouldn't lose any `gas`, and changes to a class attribute will affect all instances of the class.

###### Dot Notation

Class attributes can also be accessed using *dot notation*, both on an instance and on the class name itself. For example, we can access the class attribute `size` of `Car` like this:

```
>>> Car.size
'Tiny'
```

And in the following line, we access `hilfingers_car`'s `color` attribute:

```
>>> hilfingers_car.color
'No color yet. You need to paint me.'
```

Looks like we need to paint `hilfingers_car`!

##### Methods

Let's use the `paint` method from the `Car` class. **Methods** are functions that are specific to a class; only an instance of the class can use them. We've already seen one method: `__init__`! Think of methods as actions or abilities of objects. How do we call methods on an instance? You guessed it, dot notation!

```
>>> hilfingers_car.paint('black')
'Tesla Model S is now black'
>>> hilfingers_car.color
'black'
```

Awesome! But if you take a look at the `paint` method, it takes two parameters. So why don't we need to pass two arguments? Just like we've seen with `__init__`, all methods of a class have a `self` parameter to which Python automatically binds the instance that is calling that method. Here, `hilfingers_car` is bound to `self` so that the body of `paint` can access its attributes!

You can also call methods using the class name and dot notation; for example,

```
>>> Car.paint(hilfingers_car, 'red')
'Tesla Model S is now red'
```

Notice that unlike when we painted Professor Hilfinger's car black, this time we had to pass in two arguments: one for `self` and one for `color`. This is because when you call a method using dot notation from an instance, ==Python knows what instance to automatically bind to `self`. However, when you call a method using dot notation from the class, Python doesn't know which instance of `Car` we want to paint, so we have to pass that in as well.==

##### Inheritance

Professor Hilfinger's red Tesla is pretty cool, but it has to sit in traffic. How about we create a monster truck for him instead? In `car.py`, we've defined a `MonsterTruck` class. Let's look at the code for `MonsterTruck`:

```python
class MonsterTruck(Car):
    size = 'Monster'

    def rev(self):
        print('Vroom! This Monster Truck is huge!')

    def drive(self):
        self.rev()
        return Car.drive(self)
```

Wow! The truck may be big, but the source code is tiny! Let's make sure that the truck still does what we expect it to do. Let's create a new instance of Professor Hilfinger's monster truck:

```
>>> hilfingers_truck = MonsterTruck('Monster Truck', 'XXL')
```

Does it behave as you would expect a `Car` to? Can you still paint it? Is it even drivable?

Well, the class `MonsterTruck` is defined as `class MonsterTruck(Car):`, meaning its *superclass* is `Car`. Likewise, the class `MonsterTruck` is a *subclass* of the `Car` class. That means the `MonsterTruck` class *inherits all the attributes and methods* that were defined in `Car`, including its constructor!

**Inheritance** makes setting up a hierarchy of classes easier because the amount of code you need to write to define a new class of objects is reduced. You only need to add (or *override*) new attributes or methods that you want to be unique from those in the superclass.

```
>>> hilfingers_car.size
'Tiny'
>>> hilfingers_truck.size
'Monster'
```

Wow, what a difference in size! This is because the class attribute `size` of `MonsterTruck` overrides the `size` class attribute of `Car`, so all `MonsterTruck` instances are `'Monster'`-sized.

In addition, the `drive` method in `MonsterTruck` overrides the one in `Car`. To show off all `MonsterTruck` instances, we defined a `rev` method specific to `MonsterClass`. Regular `Car`s cannot `rev`! Everything else -- the constructor `__init__`, `paint`, `num_wheels`, `gas` -- are inherited from `Car`.

### Required Questions

#### WWPD

#### Q1: Using the Car class

‰∏ÄÂ§ßÂ†ÜÈ¢òÁõÆÔºå‰ΩÜÊòØÈÉΩÁÆóÊòØOOPÁõ∏ÂÖ≥ÁöÑÂü∫Á°ÄÁü•ËØÜÂì¶„ÄÇ

#### Adventure Game!

In the next part of this lab, we will be implementing a text-based adventure game! You can start the game by typing:

```
python3 adventure.py
```

To exit the game and return to the command line, type `Ctrl-C` or `Ctrl-D`.

#### Q2: Who am I?

It is time for you to enter a world of adventure! First, you need to create yourself as a `Player` object in `data.py`. Take a look at the `Player` class in `classes.py` and create a `Player` object at the bottom of `data.py`.

The `Player` constructor takes two arguments:

- `name` should be your preferred name (as a string)
- the starting `place`

Your `Player` should start at `sather_gate`.

```python
# Player:
# The Player should start at sather_gate.
me = None
```

Use Ok to test your code:

```
python3 ok -q me
```

Once you've created your player, you can start the adventure game:

```
python3 adventure.py
```

You will see the following output (though the commands may be in a different order):

```python
Welcome to the adventure game!

It's a bright sunny day.
You are a bright and eager CS 61A student named [your name],
wandering around Berkeley campus looking for some snacks
before the study party.

Let's go to FSM (Free Speech Movement Cafe)
and see what we can find there!

There are 7 possible commands:
    talk to [character]
    unlock [place]
    help
    take [thing]
    go to [place]
    look
    check backpack

adventure>
```

All you're able to do right now is look around, but let's change that!

#### Q3: Where do I go?

First, we need to be able to go to places. If you try the `go to` command, you'll notice it doesn't do anything.

In `classes.py`, complete the `go_to` method in the `Player` class by updating your `place` attribute to `destination_place` if it is not locked, and printing the name of the current place.

```python
    def go_to(self, location):
        """Go to a location if it's among the exits of player's current place.

        >>> sather_gate = Place('Sather Gate', 'Sather Gate', [], [])
        >>> gbc = Place('GBC', 'Golden Bear Cafe', [], [])
        >>> sather_gate.add_exits([gbc])
        >>> sather_gate.locked = True
        >>> gbc.add_exits([sather_gate])
        >>> me = Player('player', sather_gate)
        >>> me.go_to('GBC')
        You are at GBC
        >>> me.place is gbc
        True
        >>> me.place.name
        'GBC'
        >>> me.go_to('GBC')
        Can't go to GBC from GBC.
        Try looking around to see where to go.
        You are at GBC
        >>> me.go_to('Sather Gate')
        Sather Gate is locked! Go look for a key to unlock it
        You are at GBC
        """
        destination_place = self.place.get_neighbor(location)
        if destination_place.locked:
            print(destination_place.name, 'is locked! Go look for a key to unlock it')
        "*** YOUR CODE HERE ***"
        else:
            self.place = destination_place
        print('You are at', self.place.name)
```

Use Ok to test your code:

```
python3 ok -q Player.go_to
```

After you complete this problem, you'll be able to move to different places and look around there. To complete the functionality of the game, including talking to characters and picking up items, finish Questions 5-8 under the Optional Questions section!

### Optional Questions

#### Nonlocal Practice

#### Q4: Vending Machine

Implement the function `vending_machine`, which takes in a sequence of snacks (as strings) and returns a zero-argument function. This zero-argument function will cycle through the sequence of snacks, returning one element from the sequence in order.

```python
def vending_machine(snacks):
    """Cycles through sequence of snacks.

    >>> vender = vending_machine(('chips', 'chocolate', 'popcorn'))
    >>> vender()
    'chips'
    >>> vender()
    'chocolate'
    >>> vender()
    'popcorn'
    >>> vender()
    'chips'
    >>> other = vending_machine(('brownie',))
    >>> other()
    'brownie'
    >>> vender()
    'chocolate'
    """
    "*** YOUR CODE HERE ***"
    count = 0

    def give_one():
        nonlocal count
        count += 1
        return snacks[count % len(snacks) - 1]
    return give_one
```

Use Ok to test your code:

```
python3 ok -q vending_machine
```

#### More Adventure!

#### Q5: How do I talk?

Now you can go wherever you want! Try going to Wheeler. There, you'll find Jerry. Try talking to him with the `talk to` command. This also doesn't work :(

Next, implement the `talk_to` method in `Player`. `talk_to` takes in the name of a `Character` object, and prints out the `Character`'s response. Take a look at the doctest for more details.

> *Hint*: `talk_to` takes in an argument `person`, which is a string. The `characters` instance attribute in `self.place` is a dictionary mapping `Character` names (strings) to `Character` objects.
>
> Once you've got the `Character` object, what method in the `Character` class will make them talk?

```python
def talk_to(self, person):
    """Talk to person if person is at player's current place.

    >>> jerry = Character('Jerry', 'I am not the Jerry you are looking for.')
    >>> wheeler = Place('Wheeler', 'You are at Wheeler', [jerry], [])
    >>> me = Player('player', wheeler)
    >>> me.talk_to(jerry)
    Person has to be a string.
    >>> me.talk_to('Jerry')
    Jerry says: I am not the Jerry you are looking for.
    >>> me.talk_to('Tiffany')
    Tiffany is not here.
    """
    if type(person) != str:
        print('Person has to be a string.')
    "*** YOUR CODE HERE ***"
    else:
        where_to_find = self.place.characters
        if person in where_to_find:
            m = where_to_find[person].talk()  # ÂéüÊù•talkÂêéÈù¢Ë¶ÅÂä†‰∏ä()!ÊÄé‰πà‰πãÂâçantsÈáåÂÜô‰∫ÜÈÇ£‰πàÂ§öÈÉΩÊ≤°ÊÑüËßâÔºü
            print(person, 'says:', m)
        else:
            print(person, 'is not here.')
```

Use Ok to test your code:

```
python3 ok -q Player.talk_to
```

<font color = pink>ÊÑüËßâÊòØ‰∏™ÂæàÂ•ΩÁöÑÈ¢òÁõÆÔºåÁ∫†Ê≠£‰∫ÜËá™Â∑±invoke methodÊó∂ÁöÑËØØÂå∫ÔºÅ</font>

#### Q6: How do I take items?

Now you can talk to people in adventure world! To make it even better, let's implement the `take` method in the `Player` class so you can put things in your `backpack`. Currently, you don't have a backpack, so let's create an instance variable `backpack` and initialize it to an empty list(==Â∫îËØ•Â∞±ÊòØÊåáÂú®__init__ÈáåÈù¢Âä†‰∏Ä‰∏™Ëøô‰∏™Â±ûÊÄß==).

After you've initialized your empty `backpack`, implement `take`, which takes in a name of an object as a name, checks if the `Place` you are at contains the `Thing` object corresponding to the input name, and then puts it into your `backpack`. Take a look at the doctests for more details.

> **Hint**: the `things` instance attribute in the `Place` class is a dictionary that maps `Thing` names (strings) to `Thing` objects.
>
> The `take` method in the `Place` class will also come in handy.

```python
def take(self, thing):
    """Take a thing if thing is at player's current place

    >>> lemon = Thing('Lemon', 'A lemon-looking lemon')
    >>> gbc = Place('GBC', 'You are at Golden Bear Cafe', [], [lemon])
    >>> me = Player('Player', gbc)
    >>> me.backpack
    []
    >>> me.take(lemon)
    Thing should be a string.
    >>> me.take('orange')
    orange is not here.
    >>> me.take('Lemon')
    Player takes the Lemon
    >>> me.take('Lemon')
    Lemon is not here.
    >>> isinstance(me.backpack[0], Thing)
    True
    >>> len(me.backpack)
    1
    """
    if type(thing) != str:
        print('Thing should be a string.')
    "*** YOUR CODE HERE ***"
    else:
        thing_place = self.place.things # this is a dictionaryÂì¶
        if thing in thing_place:
            self.backpack.append(thing_place[thing])
            self.place.take(thing)
            print('Player takes the', thing)
        else:
            print(thing, 'is not here.')    

```

Use Ok to test your code:

```
python3 ok -q Player.take
```

<font color = pink>ÊÑüËßâÊòØÁ®çÂæÆÊúâ‰∏ÄÁÇπtrickyÁöÑÈóÆÈ¢òÔºåÂ∞±ÊòØË¶ÅÂæàÊ∏ÖÈÜíÁöÑÂÅöÔºåÂ∞±ÂÉèÂú®Áé∞ÂÆû‰∏ñÁïåÂÅö‰∏Ä‰ª∂‰∫ãÊÉÖÈÇ£Ê†∑„ÄÇ</font>

#### Q7: No door can hold us back!

<font color = pink>ËøôÈ¢òÂç°‰∫Ü‰∏Ä‰ºöÂÑøÔºå‰ΩÜÊòØÂ≠¶Âà∞‰∫ÜÂæàÂ§öÔºÅÂ¶ÇÊûú‰Ω†ÈúÄË¶ÅÊ†πÊçÆÊüêÁßçÂØπÂ∫îÁöÑÂÖ≥Á≥ªÊù•ËøîÂõûÊüê‰∏™ÂÄºÔºåÂèØ‰ª•ÂàõÂª∫‰∏Ä‰∏™Â≠óÂÖ∏Áî®Êù•Êò†Â∞ÑÔºÅÂïäÔºåÂø´‰πêÔºåÂ≠¶Âà∞‰∫ÜÂ•ΩÂ§öÂëÄ„ÄÇ</font>

FSM is locked! There's no way for us to get in, and you're getting pretty desperate for that sweet, delicious, caffeinated nectar of the gods.

We'll need to do two things in order to get into FSM and get our caffeine fix.

Firstly, define a new class `Key`, that is a subclass of `Thing`, but overwrites the `use` method to unlock the door to FSM.

> **Hint 1**: Refer back to the `MonsterTruck` example if you need a refresher on how to define a subclass and overwrite methods. Make sure you define Key after you've defined Thing.
>
> **Hint 2**: Place has a `locked` instance attribute that you may need to change.

```python
class Thing(object):
    def __init__(self, name, description):
        self.name = name
        self.description = description

    def use(self, place):
        print("You can't use a {0} here".format(self.name))

""" Implement Key here! """
```

You'll also need to finish the implementation of `unlock` in `Player`. It takes a string `place` that you want to unlock, and if you have a key, call the key's `use` method to unlock the place. If you have no key, then the method should print that the place can't be unlocked without a key.

You'll need to implement both `Key` and `unlock` for the doctests to pass.

```python
def unlock(self, place):
    """If player has a key, unlock a locked neighboring place.

    >>> key = Key('SkeletonKey', 'A Key to unlock all doors.')
    >>> gbc = Place('GBC', 'You are at Golden Bear Cafe', [], [key])
    >>> fsm = Place('FSM', 'Home of the nectar of the gods', [], [])
    >>> gbc.add_exits([fsm])
    >>> fsm.locked = True
    >>> me = Player('Player', gbc)
    >>> me.unlock(fsm)
    Place must be a string
    >>> me.go_to('FSM')
    FSM is locked! Go look for a key to unlock it
    You are at GBC
    >>> me.unlock(fsm)
    Place must be a string
    >>> me.unlock('FSM')
    FSM can't be unlocked without a key!
    >>> me.take('SkeletonKey')
    Player takes the SkeletonKey
    >>> me.unlock('FSM')
    FSM is now unlocked!
    >>> me.unlock('FSM')
    FSM is already unlocked!
    >>> me.go_to('FSM')
    You are at FSM
    """
    if type(place) != str:
        print("Place must be a string")
        return
    key = None
    for item in self.backpack:
        if type(item) == Key:
            key = item
    "*** YOUR CODE HERE ***"
```

Use Ok to test your code:

```
python3 ok -q Player.unlock
```

#### Q8: Win the game!

Good job! Now you can explore around campus and try to win the game. Talk to the people at different places in order to get hints. Can you save the day and make it to the 61A project party in time?

```
python3 adventure.py
```

Enjoy!

## hw06 

#### Q1: Next Fibonacci Object

Implement the `next` method of the `Fib` class. For this class, the `value` attribute is a Fibonacci number. ==The `next` method returns a `Fib` instance whose `value` is the next Fibonacci number.== The `next` method should take only constant time.

*Hint*: Assign `value` and `previous` attributes within `next`.

<font color = pink>Ensure start isn't changed ÁöÑÊÑèÊÄùÊòØÔºåÊØèÊ¨°ÈÉΩË¶Å‰ªéÂ§¥Êù•ËøáÔºå‰∏çËÉΩÁ¥ØÁßØ</font>

```python
class Fib():
    """A Fibonacci number.

    >>> start = Fib()
    >>> start
    0
    >>> start.next()
    1
    >>> start.next().next()
    1
    >>> start.next().next().next()
    2
    >>> start.next().next().next().next()
    3
    >>> start.next().next().next().next().next()
    5
    >>> start.next().next().next().next().next().next()
    8
    >>> start.next().next().next().next().next().next() # Ensure start isn't changed
    8
    """

    def __init__(self, value=0):
        self.value = value

    def next(self):
        "*** YOUR CODE HERE ***"

    def __repr__(self):
        return str(self.value)
```

Use Ok to test your code:

```
python3 ok -q Fib
```

#### Q2: Vending Machine

Create a class called `VendingMachine` that represents a vending machine for some product. A `VendingMachine` object returns strings describing its interactions. See the doctest below for examples:

```python
class VendingMachine:
    """A vending machine that vends some product for some price.

    >>> v = VendingMachine('candy', 10)
    >>> v.vend()
    'Machine is out of stock.'
    >>> v.deposit(15)
    'Machine is out of stock. Here is your $15.'
    >>> v.restock(2)
    'Current candy stock: 2'
    >>> v.vend()
    'You must deposit $10 more.'
    >>> v.deposit(7)
    'Current balance: $7'
    >>> v.vend()
    'You must deposit $3 more.'
    >>> v.deposit(5)
    'Current balance: $12'
    >>> v.vend()
    'Here is your candy and $2 change.'
    >>> v.deposit(10)
    'Current balance: $10'
    >>> v.vend()
    'Here is your candy.'
    >>> v.deposit(15)
    'Machine is out of stock. Here is your $15.'

    >>> w = VendingMachine('soda', 2)
    >>> w.restock(3)
    'Current soda stock: 3'
    >>> w.restock(3)
    'Current soda stock: 6'
    >>> w.deposit(2)
    'Current balance: $2'
    >>> w.vend()
    'Here is your soda.'
    """
    "*** YOUR CODE HERE ***"
```



> You may find [Python string formatting syntax](https://docs.python.org/2/library/stdtypes.html#str.format) useful. A quick example:

```python
>>> ten, twenty, thirty = 10, 'twenty', [30]
>>> '{0} plus {1} is {2}'.format(ten, twenty, thirty)
'10 plus twenty is [30]'
```

Use Ok to test your code:

```
python3 ok -q VendingMachine
```

<font color = pink>ÂïäÔºå‰∏çÁü•ÈÅì‰∏∫‰ªÄ‰πàÂÜôËøôÈÅìÈ¢òÁöÑÊó∂ÂÄôÁâπÂà´ÂºÄÂøÉ„ÄÇÁ¨¨‰∏ÄÊ¨°ÂÆåÊï¥ÂÜô‰∫Ü‰∏Ä‰∏™class„ÄÇËôΩÁÑ∂Á¨¨‰∏ÄÊ¨°ÂÜôÁöÑÁâàÊú¨ÊúâÂæàÂ§öÁªÜËäÇÊ≤°ÊúâËÄÉËôëÂà∞ÔºåÊØîÂ¶ÇdepositÁöÑÂêÑÁßçÂèçÂ∫îÔºåÂçñÂá∫Ë¥ßÁâ©‰ª•ÂêéÊï∞ÈáèË¶ÅÂáèÊéâËøô‰∫õetcÔºåÊúÄÂêéËøòÊòØpass‰∫Ü„ÄÇ‰∏çÁü•ÈÅì‰∏∫‰ªÄ‰πàÂÜôËøôÈÅìÈ¢òÁõÆÁöÑÊó∂ÂÄôÈùûÂ∏∏Ëá™Ë±™ÔºåÊàëÂ•ΩÊ£íÂïäÔºåÂùöÊåÅ‰∏ãÂéªÊàë‰∏ÄÂÆöÂèØ‰ª•Â≠¶Â•ΩËõáËõáÔºÅ</font>

## Disc05:

![image-20220209162848599](C:\Users\cyc\AppData\Roaming\Typora\typora-user-images\image-20220209162848599.png)



```python
# ÁªôÁªôÊïôÊàëÂÜôÁöÑÔºö
class Yolo:
    def __init__(self, motto=0):
        self.motto = motto

    def g(self, amount):
        return amount + self.motto
# Ëá™Â∑±Á¨¨‰∏ÄÊ¨°ÂÜôÁöÑÈ∫ªÁÉ¶ÁâàÊú¨ÔºåÊ†πÊú¨Ê≤°ÊÉ≥Âà∞defaultËøôÁßçÂ¶ôÂ¶ô 
class Yolo:
    def __init__(self, n):
        self.n = n

    def g(self, m):
        return self.n + m

    @property
    def motto(self):
        return

    @motto.setter
    def motto(self, amount):
        self.n = amount
```

## Lab 07: Recursive Objcets

### Topics

#### ÂÖàÊù•‰∏Ä‰∏™Motivation: Why linked lists

Since you are already familiar with Python's built-in lists, you might be wondering why we are teaching you another list representation. There are historical reasons, along with practical reasons. Later in the course, you'll be programming in Scheme, which is a programming language that uses linked lists for almost everything.

For now, let's compare linked lists and Python lists by looking at two common sequence operations: inserting an item and indexing.

Python's built-in list is like a sequence of containers with indices on them:

![image-20220209171612805](C:\Users\cyc\AppData\Roaming\Typora\typora-user-images\image-20220209171612805.png)

Linked lists are a list of items pointing to their neighbors. Notice that there's no explicit index for each item.

![linkedlist](https://inst.eecs.berkeley.edu//~cs61a/sp19/lab/lab07/assets/linkedlist.png)

Suppose we want to add an item at the head of the list.

- With Python's built-in list, if you want to put an item into the container labeled with index 0, you must move **all the items** in the list into its neighbor containers to make room for the first item;

![arraylist](https://inst.eecs.berkeley.edu//~cs61a/sp19/lab/lab07/assets/arraylist_insert.png)

- With a linked list, you tell Python that the neighbor of the new item is the old beginning of the list.

![arraylist](https://inst.eecs.berkeley.edu//~cs61a/sp19/lab/lab07/assets/linkedlist_insert.png)

We can compare the speed of this operation by timing how long it takes to insert a large number of items to the beginning of both types of lists. Enter the following command in your terminal to test this:

```
python3 timing.py insert 100000
```

Now, let's take a look at indexing. Say we want the item at index 3 from a list.

- In the built-in list, you can use Python list indexing, e.g. `lst[3]`, to easily get the item at index 3.
- In the linked list, you need to start at the first item and repeatedly follow the `rest` attribute, e.g. `link.rest.rest.first`. How does this scale if the index you were trying to access was very large?

To test this, enter the following command in your terminal

```
python3 timing.py index 10000
```

This program compares the speed of randomly accessing 10,000 items from both a linked list and a built-in Python list (each with length 10,000).

What conclusions can you draw from these tests? Can you think of situations where you would want to use one type of list over another? In this class, we aren't too worried about performance. However, in future computer science courses, you'll learn how to make performance tradeoffs in your programs by choosing your data structures carefully

#### Linked Lists

We've learned that a Python list is one way to store sequential values. Another type of list is a linked list. A Python list stores all of its elements in a single object, and each element can be accessed by using its index. A linked list, on the other hand, is a recursive object that only stores two things: its first value and a reference to the rest of the list, which is another linked list.

We can implement a class, `Link`, that represents a linked list object. Each instance of `Link` has two instance attributes, `first` and `rest`.

```python
class Link:
    """A linked list.

    >>> s = Link(1)
    >>> s.first
    1
    >>> s.rest is Link.empty
    True
    >>> s = Link(2, Link(3, Link(4)))
    >>> s.second
    3
    >>> s.first = 5
    >>> s.second = 6
    >>> s.rest.rest = Link.empty
    >>> s                                    # Displays the contents of repr(s)
    Link(5, Link(6))
    >>> s.rest = Link(7, Link(Link(8, Link(9))))
    >>> s
    Link(5, Link(7, Link(Link(8, Link(9)))))
    >>> print(s)                             # Prints str(s)
    <5 7 <8 9>>
    """
    empty = ()

    def __init__(self, first, rest=empty):
        assert rest is Link.empty or isinstance(rest, Link)
        self.first = first
        self.rest = rest

    @property
    def second(self):
        return self.rest.first

    @second.setter
    def second(self, value):
        self.rest.first = value

    def __repr__(self):
        if self.rest is not Link.empty:
            rest_repr = ', ' + repr(self.rest)
        else:
            rest_repr = ''
        return 'Link(' + repr(self.first) + rest_repr + ')'

    def __str__(self):
        string = '<'
        while self.rest is not Link.empty:
            string += str(self.first) + ' '
            self = self.rest
        return string + str(self.first) + '>'
```

A valid linked list can be one of the following:

1. An empty linked list (`Link.empty`)
2. A `Link` object containing the first value of the linked list and a reference to the rest of the linked list

What makes a linked list recursive is that the `rest` attribute of a single `Link` instance is another linked list! In the big picture, each `Link` instance stores a single value of the list. When multiple `Link`s are linked together through each instance's `rest` attribute, an entire sequence is formed.

> *Note*: This definition means that the `rest` attribute of any `Link` instance *must* be either `Link.empty` or another `Link` instance! This is enforced in `Link.__init__`, which raises an `AssertionError` if the value passed in for `rest` is neither of these things.

We've also defined a pseudo-attribute `second` with the `@property` decorator that will return the second element in the linked list as well as a corresponding setter. Note that the second element of a linked list is really just the `first` attribute of the `Link` instance stored in `rest`. Don't worry too much about the syntax of the setter function for now. See the docstring for a closer look at how to use this property.

To check if a linked list is empty, compare it against the class attribute `Link.empty`. For example, the function below prints out whether or not the link it is handed is empty:

```python
def test_empty(link):
    if link is Link.empty:
        print('This linked list is empty!')
    else:
        print('This linked list is not empty!'
```

#### Trees  (agian üòÜ)

We've already seen trees as abstract data types. Recall that a tree is a recursive data type that has a `label` (the value stored in the root of the tree) and `branches` (a list of trees directly underneath the root).

The tree data type that we studied was simply an abstract representation of a tree structure. Behind the scenes, the tree ADT was implemented using Python lists.

Now, we'll be working with trees as actual objects with attributes and methods! Here is the class definition:

```python
class Tree:
    def __init__(self, label, branches=[]):
        for c in branches:
            assert isinstance(c, Tree)
        self.label = label
        self.branches = list(branches)

    def __repr__(self):
        if self.branches:
            branches_str = ', ' + repr(self.branches)
        else:
            branches_str = ''
        return 'Tree({0}{1})'.format(self.label, branches_str)

    def is_leaf(self):
        return not self.branches

    def __eq__(self, other):
        return type(other) is type(self) and self.label == other.label \
               and self.branches == other.branches

    def __str__(self):
        def print_tree(t, indent=0):
            tree_str = '  ' * indent + str(t.label) + "\n"
            for b in t.branches:
                tree_str += print_tree(b, indent + 1)
            return tree_str
        return print_tree(self).rstrip()

    def copy_tree(self):
        return Tree(self.label, [b.copy_tree() for b in self.branches])
```

‚Äã	You'll see that the `Tree` class is pretty similar to the tree ADT, namely because the class is simple a formalization of the abstract data type into a real, user-defined data type. Here is a summary of the differences:

| -                            | Tree ADT                                                     | Tree class                                                   |
| :--------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| Constructing a tree          | Calling the constructor function `tree(...)` returns a tree ADT | Calling the class constructor `Tree(...)` (which calls `Tree.__init__(...)`) returns a `Tree` object |
| Label and branches           | Returned by selector functions `label(...)` and `branches(...)` | Stored in instance attributes `label` and `branches`         |
| Mutability                   | The tree ADT is immutable                                    | The `label` and `branches` attributes of a `Tree` instance can be reassigned, mutating the tree |
| Checking if a tree is a leaf | The convenience function `is_leaf(...)` returns whether or not a tree ADT is a leaf. | The bound method `t.is_leaf()` returns whether or not a `Tree` object is a leaf. This method can only be called on `Tree` objects. |

### Required Questions:

#### What Would Python Display?

#### Q1: WWPD: Linked Lists

<font color = pink>ËøôÊ¨°ÁöÑwwpdÂèØ‰ª•ÂÜçÂÅöÔºÅÊòØÊúâÁÇπÁªïËÉΩÂ§üÂä†Ê∑±OOPÁêÜËß£ÁöÑÈ¢òÁõÆ</font>

Read over the `Link` class in `lab07.py`. Make sure you understand the doctests.

> Use Ok to test your knowledge with the following "What Would Python Display?" questions:
>
> ```
> python3 ok -q link -u
> ```
>
> Enter `Function` if you believe the answer is `<function ...>`, `Error` if it errors, and `Nothing` if nothing is displayed.
>
> If you get stuck, try drawing out the box-and-pointer diagram for the linked list on a piece of paper or loading the `Link` class into the interpreter with `python3 -i lab07.py`.

#### Q2: WWPD: Trees

> Use Ok to test your knowledge with the following "What Would Python Display?" questions:
>
> ```
> python3 ok -q trees -u
> ```
>
> Enter `Function` if you believe the answer is `<function ...>`, `Error` if it errors, and `Nothing` if nothing is displayed.

#### Coding Practice

#### Q3: Link to List

Write a function `link_to_list` that takes in a linked list and returns the sequence as a Python list. You may assume that the input list is shallow; none of the elements is another linked list Ôºà<font color = pink>ÂïäÔºådocstringÈáåÁöÑÈöæÈÅìÁÆóÊòØshallowÔºüÂìàÂìà</font>Ôºâ.

Try to find ==both== an iterative and recursive solution for this problem!

```python
def link_to_list(link):
    """Takes a linked list and returns a Python list with the same elements.

    >>> link = Link(1, Link(2, Link(3, Link(4))))
    >>> link_to_list(link)
    [1, 2, 3, 4]
    >>> link_to_list(Link.empty)
    []
    """
    "*** YOUR CODE HERE ***"
    # iterative version
    if link is Link.empty:
        return []
    lst = []
    while link.rest is not link.empty:
        lst.append(link.first)
        link = link.rest
    lst.append(link.first)
    return lst
    # recursive version
    if link is Link.empty:
        return []
    elif link.rest is Link.empty:
        return [link.first]
    else:
        return [link.first] + link_to_list(link.rest)
```

Use Ok to test your code:

```py
python3 ok -q link_to_list
```



#### Q4: Store Digits

Write a function `store_digits` that takes in an integer `n` and returns a linked list where each element of the list is a digit of `n`.

```python
def store_digits(n):
    """Stores the digits of a positive number n in a linked list.

    >>> s = store_digits(1)
    >>> s
    Link(1)
    >>> store_digits(2345)
    Link(2, Link(3, Link(4, Link(5))))
    >>> store_digits(876)
    Link(8, Link(7, Link(6)))
    """
    "*** YOUR CODE HERE ***"
    rest = ()
    while n > 10:
        end_digit = n % 10
        rest = Link(end_digit, rest)
        n = n // 10
        # for_now = Link(n % 10, rest)
        # rest = for_now
    # print(rest)
    return Link(n, rest)
```

Use Ok to test your code:

```
python3 ok -q store_digits
```

#### Q5: Cumulative Sum

Write a function `cumulative_sum` that mutates the Tree `t`, where each node's label becomes the sum of all entries in the subtree rooted at the node.

```python
def cumulative_sum(t):
    """Mutates t where each node's root becomes the sum of all entries in the
    corresponding subtree rooted at t.

    >>> t = Tree(1, [Tree(3, [Tree(5)]), Tree(7)])
    >>> cumulative_sum(t)
    >>> t
    Tree(16, [Tree(8, [Tree(5)]), Tree(7)])
    """
    "*** YOUR CODE HERE ***"
    for b in t.branches:
        if len(b.branches) > 0:
            sum_node = sum([bb.label for bb in b.branches])
            b.label += sum_node
        t.label += b.label
```

Use Ok to test your code:

```
python3 ok -q cumulative_sum
```



### Optional  Questions

#### Linked List Practice

#### Q6: Remove All

Implement a function `remove_all` that takes a `Link`, and a `value`, and remove any linked list node containing that value. ==You can assume the list already has at least one node containing `value` and the first element is never removed==. Notice that you are not returning anything, so you should mutate the list.

```python
def remove_all(link , value):
    """Remove all the nodes containing value. Assume there exists some
    nodes to be removed and the first element is never removed.

    >>> l1 = Link(0, Link(2, Link(2, Link(3, Link(1, Link(2, Link(3)))))))
    >>> print(l1)
    <0 2 2 3 1 2 3>
    >>> remove_all(l1, 2)
    >>> print(l1)
    <0 3 1 3>
    >>> remove_all(l1, 3)
    >>> print(l1)
    <0 1>
    """
    "*** YOUR CODE HERE ***"
    if link.rest is Link.empty:
        return
    elif link.second == value:
        link.rest = link.rest.rest
        return remove_all(link, value)
    elif link.second != value:
        return remove_all(link.rest, value)
```

Use Ok to test your code:

```
python3 ok -q remove_all
```

<font color = pink>ÂÜô‰∫ÜÈùûÂ∏∏‰πÖÔºåÊÑüËßâÈóÆÈ¢òÂú®‰∫éÔºå‰∏ÄÂºÄÂßãÂ∞±Ë¶ÅÊääËá™Â∑±Ë¶ÅÂÅö‰ªÄ‰πàÊÉ≥ÊòéÁôΩÔºõbase caseÊòØ‰ªÄ‰πà/Âà∞Â∫ï‰∫ÜË¶ÅÊÄé‰πàÂÅö„ÄÇÂÖ∂ÂÆûÂπ∂‰∏çÊòØÂæàÈöæÁöÑÈ¢òÁõÆÂì¶</font>

#### Q7: Mutable Mapping

Implement `deep_map_mut(fn, link)`, which applies a function `fn` onto all elements in the given linked list `link`. If an element is itself a linked list, apply `fn` to each of its elements, and so on.

Your implementation should mutate the original linked list. Do not create any new linked lists.

> **Hint**: The built-in `isinstance` function may be useful.
>
> ```
> >>> s = Link(1, Link(2, Link(3, Link(4))))
> >>> isinstance(s, Link)
> True
> >>> isinstance(s, int)
> False
> ```

```python
def deep_map_mut(fn, link):
    """Mutates a deep link by replacing each item found with the
    result of calling fn on the item.  Does NOT create new Links (so
    no use of Link's constructor)

    Does not return the modified Link object.

    >>> link1 = Link(3, Link(Link(4), Link(5, Link(6))))
    >>> deep_map_mut(lambda x: x * x, link1)
    >>> print(link1)
    <9 <16> 25 36>
    """
    "*** YOUR CODE HERE ***"
    if link.rest is Link.empty:
        if isinstance(link.first, Link):
            return deep_map_mut(fn, link.first)
        else:
            link.first = fn(link.first)
    else:
        if isinstance(link.first, Link):
            deep_map_mut(fn, link.first)
        else:
            link.first = fn(link.first)
        return deep_map_mut(fn, link.rest)
```

Use Ok to test your code:

```
python3 ok -q deep_map_mut
```

<font color = pink>ÂæàÂ§öcodeÈÉΩÊòØÈáçÂ§çÁöÑÔºåÂ∫îËØ•ÊÄé‰πàÁÆÄÂåñÂë¢Ôºü</font>



#### Q8: Cycles ‚≠ê‚≠ê‚≠ê

The `Link` class can represent lists with cycles. ==That is, a list may contain itself as a sublist.==

==‰πãÂâç‰∏ÄÁõ¥‰ª•‰∏∫ÊòØ s.rest = s ÊúâÈóÆÈ¢òÔºå‰ΩÜÂÖ∂ÂÆûÊ≤°ÊúâÈóÆÈ¢òÔºåÂ∞±ÊòØ‰∏Ä‰∏™ÊµÖÊã∑Ë¥ù„ÄÇ‰ΩÜÊòØÂõ†‰∏∫Êúâ_ _repr_ _ ÔºåÊâç‰ºö‰∏ÄÁõ¥ÁªïÂúàÊúÄÂêéÊä•Èîô„ÄÇ==

```
>>> s = Link(1, Link(2, Link(3)))
>>> s.rest.rest.rest = s
>>> s.rest.rest.rest.rest.rest.first
3
```

Implement `has_cycle`,that returns whether its argument, a `Link` instance, contains a cycle.

> *Hint*: Iterate through the linked list and try ==keeping track of== which `Link` objects you've already seen.

```python
def has_cycle(link):
    """Return whether link contains a cycle.

    >>> s = Link(1, Link(2, Link(3)))
    >>> s.rest.rest.rest = s
    >>> has_cycle(s)
    True
    >>> t = Link(1, Link(2, Link(3)))
    >>> has_cycle(t)
    False
    >>> u = Link(2, Link(2, Link(2)))
    >>> has_cycle(u)
    False
    """
    "*** YOUR CODE HERE ***"
    current_pos = link
    check_seen = []
    while current_pos.rest is not Link.empty:
        if current_pos in check_seen:
            return True
        else:
            check_seen.append(current_pos)
            current_pos = current_pos.rest
    return False
    
    
```

<font color = pink>ÊÄùË∑ØÂ∞±ÊòØÔºåÁî®‰∏Ä‰∏™ÊåáÈíàÊåáÂêë‰ΩçÁΩÆÔºå‰∏çÊîπÂèòobjectÊú¨Ë∫´ÔºåÂ§ßÊ¶ÇÊòØËøôÊ†∑„ÄÇÊ≠§Â§ÑÁöÑÊµÖÊã∑Ë¥ùÔºåÊòØÊåáÂêëÂêå‰∏Ä‰∏™‰∏úË•øÁöÑ„ÄÇ</font>

Use Ok to test your code:

```
python3 ok -q has_cycle
```

As an extra challenge, implement `has_cycle_constant` with only [constant space](http://composingprograms.com/pages/28-efficiency.html#growth-categories). (If you followed the hint above, you will use linear space.) The solution is short (less than 20 lines of code), but ==requires a clever idea==. Try to discover the solution yourself before asking around:

```python
def has_cycle_constant(link):
    """Return whether link contains a cycle.

    >>> s = Link(1, Link(2, Link(3)))
    >>> s.rest.rest.rest = s
    >>> has_cycle_constant(s)
    True
    >>> t = Link(1, Link(2, Link(3)))
    >>> has_cycle_constant(t)
    False
    """
    "*** YOUR CODE HERE ***"
    curr1 = link # fast one
    curr2 = link # slow one
    step = 2 # speed of curr1 is twice than curr2's
    while curr1.rest is not Link.empty:  # Âõ†‰∏∫curr1ÊòØËµ∞ÂæóÂø´ÁöÑÈÇ£‰∏™
        curr1 = curr1.rest
        step -= 1
        if step == 0:  # ‰πüÊòØÂæàÊúâÂêØÂèëÁöÑÂÜôÊ≥ï
            step = 2
            curr2 = curr2.rest
        if curr1 == curr2:
            return True
    return False
‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
	curr1, curr2 = link, link
    while curr1.rest is not Link.empty:
        curr1 = curr1.rest.rest
        curr2 = curr2.rest
        if curr1 == curr2:
            return True
    return False
        
        
    
```

<font color =pink>ÊÄùË∑ØÊòØËøôÊ†∑ÁöÑÔºöÂ¶ÇÊûúÊòØ‰∏Ä‰∏™ÂúàÔºåÈÇ£‰πà‰∏çÂêåÈÄüÂ∫¶ÁöÑ‰∏§‰∏™‰∫∫ÔºåÊÄªÊòØËÉΩÂ§üÁõ∏ÈÅáÁöÑ„ÄÇÂ¶ÇÊûúÊ≤°ÊúâÂúàËµ∞Áõ¥Á∫øÔºåÈÇ£‰πàÊ∞∏Ëøú‰πü‰∏ç‰ºöÁõ∏ÈÅá„ÄÇ</font>

Use Ok to test your code:

```
python3 ok -q has_cycle_constant
```

#### Tree Practice

#### Q9: Reverse Other

Write a function `reverse_other` that mutates the tree such that nodes on *every other* (even_indexed) level have the labels of their branches all reversed. For example `Tree(1,[Tree(2), Tree(3)])` becomes `Tree(1,[Tree(3), Tree(2)])`

```python
def reverse_other(t):
    """Mutates the tree such that nodes on every other (even_indexed) level
    have the labels of their branches all reversed.

    >>> t = Tree(1, [Tree(2), Tree(3), Tree(4)])
    >>> reverse_other(t)
    >>> t
    Tree(1, [Tree(4), Tree(3), Tree(2)])
    >>> t = Tree(1, [Tree(2, [Tree(3, [Tree(4), Tree(5)]), Tree(6, [Tree(7)])]), Tree(8)])
    >>> reverse_other(t)
    >>> t
    Tree(1, [Tree(8, [Tree(3, [Tree(5), Tree(4)]), Tree(6, [Tree(7)])]), Tree(2)])
    """
    "*** YOUR CODE HERE ***"
    this_level_nodes = []
    for b in t.branches:
        this_level_nodes.append(b.label)
    for b in t.branches:
        b.label = this_level_nodes[-1]
        del this_level_nodes[-1]
    for b in t.branches:
        for j in b.branches:
            return reverse_other(j)
```

Use Ok to test your code:

```
python3 ok -q reverse_other
```

<font color = pink>Â§ßÊ¶ÇÊòØÈù†forÁöÑËøê‰ΩúÊú∫Âà∂ÔºåËá™Âä®Âú∞Êúâ‰∫Ü‰∏Ä‰∏™base caseÔºü</font>

## hw07

#### Q1: Digits

<font color = pink>ÂïäÔºåËôΩÁÑ∂ËøôÈÅìÈ¢òÂæàÁÆÄÂçï„ÄÇ‰ΩÜÊòØÊúâ‰∏Ä‰∏™Âç°‰∫ÜÊàëÂæà‰πÖÂæà‰πÖÁöÑÂú∞Êñπ:</font> 

a = Link(3)

a.rest = a   # Êä•Â§ßÈîôÔºÅÔºÅ

a.rest = Link(3)  # ËøôÊ†∑ÊâçÂèØ‰ª•„ÄÇÂíåreprÊúâ‰ªÄ‰πàÂÖ≥Á≥ªÂêóÔºü

<font color = pink>‰∏ãÈù¢ÊòØÈ¢òÁõÆ</font>

Implement `digits`, which returns a linked list containing the digits of a non-negative integer `n`.

```python
def digits(n):
    """Return the digits of n as a linked list.

    >>> digits(0) is Link.empty
    True
    >>> digits(543)
    Link(5, Link(4, Link(3)))
    """
    s = Link.empty
    while n > 0:
        n, last = n // 10, n % 10
        "*** YOUR CODE HERE ***"
        s = Link(last, s)
    return s
```

Use Ok to test your code:

```
python3 ok -q digits
```

#### Q2: Miss Manners

Create a class called `MissManners` that promotes politeness among our objects. A `MissManners` object takes another object on construction. It has one method, called `ask`. It responds by calling methods on the object it contains, but only if the caller said please first.

We can also compose multiple instances of `MissManners` objects upon each other (see `double_fussy` in doctests). A multilevel `MissManners` object must be politely requested to ask its own `MissManners` object. This continues until we reach the bottom level `MissManners` object.

> *Hint*: Use `getattr` [(Python docs)](https://docs.python.org/3/library/functions.html#getattr) and `hasattr` [(Python docs)](https://docs.python.org/3/library/functions.html#hasattr) to access methods using strings. You may want to search online for some examples of their usage.
>
> *Hint*: Your implementation will need to use the `*args` notation that allows functions to take a flexible number of arguments. If you need a refresher, take a look at your implementation of `make_averaged` in the Hog project.

```python
class MissManners:
    """A container class that only forwards messages that say please.

    >>> v = VendingMachine('teaspoon', 10)
    >>> v.restock(2)
    'Current teaspoon stock: 2'

    >>> m = MissManners(v)
    >>> m.ask('vend')
    'You must learn to say please first.'
    >>> m.ask('please vend')
    'You must deposit $10 more.'
    >>> m.ask('please deposit', 20)
    'Current balance: $20'
    >>> m.ask('now will you vend?')
    'You must learn to say please first.'
    >>> m.ask('please hand over a teaspoon')
    'Thanks for asking, but I know not how to hand over a teaspoon.'
    >>> m.ask('please vend')
    'Here is your teaspoon and $10 change.'

    >>> double_fussy = MissManners(m) # Composed MissManners objects
    >>> double_fussy.ask('deposit', 10)
    'You must learn to say please first.'
    >>> double_fussy.ask('please deposit', 10)
    'Thanks for asking, but I know not how to deposit.'
    >>> double_fussy.ask('please please deposit', 10)
    'Thanks for asking, but I know not how to please deposit.'
    >>> double_fussy.ask('please ask', 'please deposit', 10)
    'Current balance: $10'
    """
    def __init__(self, obj):
        self.obj = obj

    def ask(self, message, *args):
        magic_word = 'please '
        if not message.startswith(magic_word):
            return 'You must learn to say please first.'
        "*** YOUR CODE HERE ***"
        else:  # if starts with magic_word
            real_method = message[7:]
            if hasattr(self.obj, real_method):
                return getattr(self.obj, real_method)(*args)
            else:
                return 'Thanks for asking, but I know not how to {0}.'.format(real_method)
```

Use Ok to test your code:

```
python3 ok -q MissManners
```

<font color = pink>ÂïäÔºåËôΩÁÑ∂ÂÜôËµ∑Êù•‰∏çÈöæÔºå‰ΩÜÊòØÊÑüËßâdouble_fussyËøô‰∏™ÈùûÂ∏∏Â¶ôËØ∂„ÄÇ</font>

## Lab 08:  Midterm Review

### Required Questions

#### Linked Lists

#### Q1: Deep Linked List Length

A linked list that contains one or more linked lists as elements is called ==a *deep* linked list==. Write a function `deep_len` that takes in a (possibly deep) linked list and returns the *deep length* of that linked list, which consists of the number of non-Link elements in the linked list and the sum of the deep length of all linked lists elements. See the function's doctests for examples of the deep length of linked lists.

> **Hint:** Use `isinstance` to check if something is an instance of an object.

```python
def deep_len(lnk):
    """ Returns the deep length of a possibly deep linked list.

    >>> deep_len(Link(1, Link(2, Link(3))))
    3
    >>> deep_len(Link(Link(1, Link(2)), Link(3, Link(4))))
    4
    >>> levels = Link(Link(Link(1, Link(2)), \
            Link(3)), Link(Link(4), Link(5)))
    >>> print(levels)
    <<<1 2> 3> <4> 5>
    >>> deep_len(levels)
    5
    """
    "*** YOUR CODE HERE ***"
    count = 0
    if lnk.rest is Link.empty:
        if isinstance(lnk.first, Link):
            sub_sum = deep_len(lnk.first)
            count += sub_sum
        else:
            count += 1
        return count
    while lnk.rest is not Link.empty:
        if isinstance(lnk.first, Link):
            sub_sum = deep_len(lnk.first)
            count += sub_sum
        else:
            count += 1
        lnk = lnk.rest
    return count + 1

```

Use Ok to test your code:

```
python3 ok -q deep_len
```

<font color = pink>ÂïäÔºåÊÄé‰πàÊ†∑ËÉΩÂÜôÂæóÊõ¥ÁÆÄÂçïÂë¢Ôºü</font>

#### Order of Growth

#### Q2: Finding Orders of Growth

> Use Ok to test your knowledge with the following questions:
>
> ```
> python3 ok -q growth -u
> ```
>
> Be sure to ask a lab assistant or TA if you don't understand the correct answer!

What is the order of growth of `is_prime` in terms of `n`?     ==linear/Theta(n)==

```python
def is_prime(n):
    for i in range(2, n):
        if n % i == 0:
            return False
    return True
```

What is the order of growth of `bar` in terms of `n`?           ==Theta(n^2)==

```python
def bar(n):
    i, sum = 1, 0
    while i <= n:
        sum += biz(n)
        i += 1
    return sum

def biz(n):
    i, sum = 1, 0
    while i <= n:
        sum += i**3
        i += 1
    return sum
```

What is the order of growth of `foo` in terms of `n`, where `n` is the length of `lst`? Assume that sng a list and calling `len` on a list can both be done in constant time.        ==Theta(log(n))==

```python
def foo(lst, i):
    mid = len(lst) // 2
    if mid == 0:
        return lst
    elif i > 0:
        return foo(lst[mid:], -1)
    else:
        return foo(lst[:mid], 1)
```

### Optional Questions 

#### Objects

#### Q3: WWPP: Methods

<font color = pink>Â•ΩÔºåÂèØ‰ª•ÂÜçÂÅö</font>

> Use Ok to test your knowledge with the following "What Would Python Print?" questions:
>
> ```
> python3 ok -q foobar -u
> ```
>
> *Hint*: Remember for all WWPP questions, enter `Function` if you believe the answer is `<function ...>` and `Error` if it errors.

==method must have a first parameter, usually called self==

<img src="C:\Users\cyc\AppData\Roaming\Typora\typora-user-images\image-20220221155344755.png" alt="image-20220221155344755" style="zoom:50%;" />

```python
>>> class Foo:
...     def print_one(self):
...         print('foo')
...     def print_two():
...         print('foofoo')
>>> f = Foo()
>>> f.print_one()
______
>>> f.print_two()
______
>>> Foo.print_two()
______
>>> class Bar(Foo):
...     def print_one(self):
...         print('bar')
>>> b = Bar()
>>> b.print_one()
______
>>> Bar.print_two()
______
>>> Bar.print_one = lambda x: print('new bar')
>>> b.print_one()
______
```

#### Q4: WWPP: Attributes

> Use Ok to test your knowledge with the following "What Would Python Print?" questions:
>
> ```
> python3 ok -q attributes -u
> ```
>
> *Hint*: Remember for all WWPP questions, enter `Function` if you believe the answer is `<function ...>` and `Error` if it errors.

```python
>>> class Foo:
...     a = 10
...     def __init__(self, a):
...         self.a = a
>>> class Bar(Foo):
...     b = 1
>>> a = Foo(5)
>>> b = Bar(2)
>>> a.a
______
>>> b.a
______
>>> Foo.a
______
>>> Bar.b
______
>>> Bar.a
______
>>> b.b
______
>>> Foo.c = 15
>>> Foo.c
______
>>> a.c
______
>>> b.c
______
>>> Bar.c
______
>>> b.b = 3
>>> b.b
______
>>> Bar.b
______
```

#### Q5: Keyboard

We'd like to create a `Keyboard` class that takes in an **arbitrary** number of `Button`s and stores these `Button`s in a dictionary. The keys in the dictionary will be ints that represent the postition on the `Keyboard`, and the values will be the respective `Button`. Fill out the methods in the `Keyboard` class according to each description, using the doctests as a reference for the behavior of a `Keyboard`.

```python
class Keyboard:
    """A Keyboard takes in an arbitrary amount of buttons, and has a
    dictionary of positions as keys, and values as Buttons.

    >>> b1 = Button(0, "H")
    >>> b2 = Button(1, "I")
    >>> k = Keyboard(b1, b2)
    >>> k.buttons[0].key
    'H'
    >>> k.press(1)
    'I'
    >>> k.typing([0, 1])
    'HI'
    >>> k.typing([1, 0])
    'IH'
    >>> b1.pressed
    2
    >>> b2.pressed
    3
    """

    def __init__(self, *args):
        "*** YOUR CODE HERE ***"
        self.buttons = [*args]
        self.my_dict = {a.pos: a.key for a in [*args]}

    def press(self, info):
        """Takes in a position of the button pressed, and
        returns that button's output"""
        "*** YOUR CODE HERE ***"
        self.buttons[info].pressed += 1
        return self.my_dict[info]
    
    def typing(self, typing_input):
        """Takes in a list of positions of buttons pressed, and
        returns the total output"""
        "*** YOUR CODE HERE ***"
        my_str = ''
        for i in typing_input:
            my_str += self.my_dict[i]
            self.buttons[i].pressed += 1
        return my_str
    
class Button:
    def __init__(self, pos, key):
        self.pos = pos
        self.key = key
        self.pressed = 0
```

Use Ok to test your code:

```
python3 ok -q Keyboard
```

#### Nonlocal

#### Q6: Advanced Counter

Complete the definition of `make_advanced_counter_maker`, which creates a function that creates counters. These counters can not only update their personal count, but also a shared count for all counters. They can also reset either count.

```python
def make_advanced_counter_maker():
    """Makes a function that makes counters that understands the
    messages "count", "global-count", "reset", and "global-reset".
    See the examples below:

    >>> make_counter = make_advanced_counter_maker()
    >>> tom_counter = make_counter()
    >>> tom_counter('count')
    1
    >>> tom_counter('count')
    2
    >>> tom_counter('global-count')
    1
    >>> jon_counter = make_counter()
    >>> jon_counter('global-count')
    2
    >>> jon_counter('count')
    1
    >>> jon_counter('reset')
    >>> jon_counter('count')
    1
    >>> tom_counter('count')
    3
    >>> jon_counter('global-count')
    3
    >>> jon_counter('global-reset')
    >>> tom_counter('global-count')
    1
    """
    "*** YOUR CODE HERE ***"
    global_count = 0

    def counter():
        count = 0

        def action(ipt):
            nonlocal global_count
            nonlocal count
            if ipt == 'count':
                count += 1
                return count
            elif ipt == 'global-count':
                global_count += 1
                return global_count
            elif ipt == 'reset':
                count = 0
            elif ipt == 'global-reset':
                global_count = 0
        return action

    return counter
```

Use Ok to test your code:

```
python3 ok -q make_advanced_counter_maker
```

#### Mutable Lists

#### Q7: Environment Diagram

Draw an environment diagram for the following program.

<font color = pink>‰∏ãÈù¢‰∏âÁÇπÁ°ÆÂÆûÈÉΩÊòØÂæàÈáçË¶ÅÁöÑ„ÄÅÊúâÁÇπtrickyÁöÑÁÇπÔºö</font>

> Some things to remember:
>
> - When you mutate a list, you are changing the original list.
> - When you concatenate two lists, you are creating a new list.
> - When you assign a name to an existing object, you are creating another reference to that object rather than creating a copy of that object.

```python
def got(lst, el, f):
    welcome = []
    for e in lst:
        if e == el:
            el = f(lst[1:], 2, welcome)
    return lst[3:] + welcome

def avocadis(lst, i, lst0):
    lst0.append(lst.pop(i))
    return len(lst0)

bananis = [1, 6, 1, 6]
n = bananis[3]
we = got(bananis, n, avocadis)
```

You can check your solution [here](https://goo.gl/iRnSUx). If you get stuck, ask a Lab Assistant or TA for help before checking the solution! There is nothing to submit for this problem.

#### Q8: Trade

In the integer market, each participant has a list of positive integers to trade. When two participants meet, they trade the smallest non-empty prefix of their list of integers. A prefix is a slice that starts at index 0.

Write a function `trade` that exchanges the first `m` elements of list `first` with the first `n` elements of list `second`, such that the sums of those elements are equal, and the sum is as small as possible. If no such prefix exists, return the string `'No deal!'` and do not change either list. Otherwise change both lists and return `'Deal!'`. A partial implementation is provided.

<font color = pink>ËøôÈÅìÈ¢òÔºåÂ≠¶Âà∞ÁöÑÂ∞±ÊòØËæπÁïåÁöÑÊÉÖÂÜµË¶ÅÂ§öÁïôÊÑè‰∏Ä‰∏ãÔºåÊúâÊó∂ÂÄôÁ°ÆÂÆû‰ºöÊúâ‰∏ÄÁÇπÈöæÂ§ÑÁêÜÔºåÂ§ö‰∏æÂá†‰∏™‰æãÂ≠êËØï‰∏Ä‰∏ã</font>

> **Hint:** You can mutate a slice of a list using *slice assignment*. To do so, specify a slice of the list `[i:j]` on the left-hand side of an assignment statement and another list on the right-hand side of the assignment statement. The operation will replace the entire given slice of the list ==from `i` inclusive to `j` exclusive== with the elements from the given list. ==The slice and the given list need not be the same length==.
>
> ```
> >>> a = [1, 2, 3, 4, 5, 6]
> >>> b = a
> >>> a[2:5] = [10, 11, 12, 13]
> >>> a
> [1, 2, 10, 11, 12, 13, 6]
> >>> b
> [1, 2, 10, 11, 12, 13, 6]
> ```

```python
def trade(first, second):
    """Exchange the smallest prefixes of first and second that have equal sum.

    >>> a = [1, 1, 3, 2, 1, 1, 4]
    >>> b = [4, 3, 2, 7]
    >>> trade(a, b) # Trades 1+1+3+2=7 for 4+3=7
    'Deal!'
    >>> a
    [4, 3, 1, 1, 4]
    >>> b
    [1, 1, 3, 2, 2, 7]
    >>> c = [3, 3, 2, 4, 1]
    >>> trade(b, c)
    'No deal!'
    >>> b
    [1, 1, 3, 2, 2, 7]
    >>> c
    [3, 3, 2, 4, 1]
    >>> trade(a, c)
    'Deal!'
    >>> a
    [3, 3, 2, 1, 4]
    >>> b
    [1, 1, 3, 2, 2, 7]
    >>> c
    [4, 3, 1, 4, 1]
    """
    m, n = 1, 1

    "*** YOUR CODE HERE ***"
    sum1, sum2 = first[0], second[0]
    result = 0
    while m <= len(first) and n <= len(second):
        if sum1 == sum2:
            result = 1
            break
        elif sum1 < sum2:
            if m >= len(first):
                break
            sum1 += first[m]
            m += 1
        elif sum1 > sum2:
            if n >= len(second):
                break
            sum2 += second[n]
            n += 1

    if result == 1:   # change this line!    
        first[:m], second[:n] = second[:n], first[:m]
        return 'Deal!'
    else:
        return 'No deal!'
```

Use Ok to test your code:

```
python3 ok -q trade
```

#### Recursive objects

#### Q9: Linked Lists as Strings

Kevin and Jerry like different ways of displaying the linked list structure in Python. While Kevin likes box and pointer diagrams, Jerry prefers a more futuristic way. Write a function `make_to_string` that returns a function that converts the linked list to a string in their preferred style.

*Hint*: You can convert numbers to strings using the `str` function, and you can combine strings together using `+`.

```python
>>> str(4)
'4'
>>> 'cs ' + str(61) + 'a'
'cs 61a'
def make_to_string(front, mid, back, empty_repr):
    """ Returns a function that turns linked lists to strings.

    >>> kevins_to_string = make_to_string("[", "|-]-->", "", "[]")
    >>> jerrys_to_string = make_to_string("(", " . ", ")", "()")
    >>> lst = Link(1, Link(2, Link(3, Link(4))))
    >>> kevins_to_string(lst)
    '[1|-]-->[2|-]-->[3|-]-->[4|-]-->[]'
    >>> kevins_to_string(Link.empty)
    '[]'
    >>> jerrys_to_string(lst)
    '(1 . (2 . (3 . (4 . ()))))'
    >>> jerrys_to_string(Link.empty)
    '()'
    """
    "*** YOUR CODE HERE ***"
    def trans(lst):
        trans_str = ''
        count_back = 0
        while lst is not Link.empty:
            trans_str += front + str(lst.first) + mid
            lst = lst.rest
            count_back += 1
        trans_str += empty_repr + count_back * back
        return trans_str
    return trans
```

Use Ok to test your code:

```
python3 ok -q make_to_string
```

#### Q10: Tree Map 

Define the function `tree_map`, which takes in a tree and a one-argument function as arguments and returns a new tree which is the result of mapping the function over the entries of the input tree.

```python
def tree_map(fn, t):
    """Maps the function fn over the entries of t and returns the
    result in a new tree.

    >>> numbers = Tree(1,
    ...                [Tree(2,
    ...                      [Tree(3),
    ...                       Tree(4)]),
    ...                 Tree(5,
    ...                      [Tree(6,
    ...                            [Tree(7)]),
    ...                       Tree(8)])])
    >>> print(tree_map(lambda x: 2**x, numbers))
    2
      4
        8
        16
      32
        64
          128
        256
    """
    "*** YOUR CODE HERE ***"
    if t.is_leaf():
        return Tree(fn(t.label))
    else:
        new_tree = []
        for b in t.branches:
            new_tree.append(tree_map(fn, b))
    return Tree(fn(t.label), new_tree)
```

Use Ok to test your code:

```
python3 ok -q tree_map
```

#### Q11: Long Paths   ‚≠ê‚≠ê‚≠ê

<font color = pink>ÂÅöÂÆåËøôÈÅìÈ¢òÁõÆËÉΩ‰Ωì‰ºöÂà∞recursionÁöÑÁî®Ê≥ïÔºå‰ª•ÂèäÊÄéÊ†∑Êää</font>

Implement `long_paths`, which returns a list of ==all *paths* in a tree with length at least `n`==. A path in a tree is a linked list of node values that starts with the root and ends at a leaf. Each subsequent element must be from a child of the previous value's node. ==The *length* of a path is the number of edges in the path (i.e. one less than the number of nodes in the path). Paths are listed in order from left to right==. See the doctests for some examples.

```python
def long_paths(tree, n):
    """Return a list of all paths in tree with length at least n.

    >>> t = Tree(3, [Tree(4), Tree(4), Tree(5)])
    >>> left = Tree(1, [Tree(2), t])
    >>> mid = Tree(6, [Tree(7, [Tree(8)]), Tree(9)])
    >>> right = Tree(11, [Tree(12, [Tree(13, [Tree(14)])])])
    >>> whole = Tree(0, [left, Tree(13), mid, right])
    >>> for path in long_paths(whole, 2):
    ...     print(path)
    ...
    <0 1 2>
    <0 1 3 4>
    <0 1 3 4>
    <0 1 3 5>
    <0 6 7 8>
    <0 6 9>
    <0 11 12 13 14>
    >>> for path in long_paths(whole, 3):
    ...     print(path)
    ...
    <0 1 3 4>
    <0 1 3 4>
    <0 1 3 5>
    <0 6 7 8>
    <0 11 12 13 14>
    >>> long_paths(whole, 4)
    [Link(0, Link(11, Link(12, Link(13, Link(14)))))]
    """
    "*** YOUR CODE HERE ***"
    lst = []
    if tree.is_leaf():
        if n > 0:
            return None
        else:
            return [Link(tree.label)]
    else:
        for b in tree.branches:
            paths = long_paths(b, n - 1)
            if not paths is None:
                for p in paths:
                    this_path = Link(tree.label, p)
                    lst.append(this_path)
    return lst
```

Use Ok to test your code:

```
python3 ok -q long_paths
```

#### More Orders of Growth

#### Q12: Zap (Orders of Growth)

What is the order of growth in time for the following function `zap`? Use big-Œ∏ notation.

```python
def zap(n):
    i, count = 1, 0
    while i <= n:
        while i <= 5 * n:
            count += i
            print(i / 6)
            i *= 3
    return count
```

> Use Ok to test your answer:
>
> ```
> python3 ok -q zap -u
> ```

==Á≠îÊ°àÔºö==

<img src="C:\Users\cyc\AppData\Roaming\Typora\typora-user-images\image-20220223084810386.png" alt="image-20220223084810386" style="zoom:50%;" />



#### Q13: Boom (Orders of Growth)

What is the order of growth in time for the following function boom? Use big-Œ∏ notation.

```python
def boom(n):
    sum = 0
    a, b = 1, 1
    while a <= n*n:
        while b <= n*n:
            sum += (a*b)
            b += 1
        b = 0
        a += 1
    return sum
```

> Use Ok to test your answer:
>
> ```
> python3 ok -q boom -u
> ```

==Â∫îËØ•ÊòØn^4Âìà==Ôºö

<img src="C:\Users\cyc\AppData\Roaming\Typora\typora-user-images\image-20220223085126996.png" alt="image-20220223085126996" style="zoom:50%;" />



## Chapter 3: Interpreting Computer Programs

## hw08

#### Q1: Cadr and Caddr

Define the procedures `cadr` and `caddr`, which return the second and third elements of a list, respectively:

```scheme
(define (cddr s)
  (cdr (cdr s)))

(define (cadr s)
  'YOUR-CODE-HERE
  (car (cdr s))
)

(define (caddr s)
  'YOUR-CODE-HERE
  (car (cddr s))
)
```



Use Ok to unlock and test your code:

```
python3 ok -q cadr-caddr -u
python3 ok -q cadr-caddr
```

==cadrÂíåcaddrÊòØËøîÂõûlist‰∏≠ÁöÑÂÖÉÁ¥†==Ôºö

<img src="C:\Users\cyc\AppData\Roaming\Typora\typora-user-images\image-20220220102235419.png" alt="image-20220220102235419" style="zoom:50%;" />

### Conditional expressions

The `cond` special form is a general conditional expression, similar to a multi-clause conditional statement in Python. The general form of a conditional expression is:

```
(cond
    (<p1> <el1>)
    (<p2> <el2>)
    ...
    (<pn> <eln>)
    (else <else-expressions>))
```

This consists of the symbol `cond` followed by sequences of expressions `(<p> <el>)` called *clauses*.

The first expression in each pair is a *predicate*: an expression whose value is interpreted as either being true or false.

In Scheme, *all* values except the special boolean value `#f` are interpreted as true values (unlike Python). (Our particular version of the Scheme interpreter allows you to write `True` and `False` in place of `#t` and `#f`, and prints boolean values as `True` and `False`. This is not standard.)

Conditional expressions are evaluated as follows:

- The predicate `<p1>` is evaluated first. If its value is `#f`, then `<p2>` is evaluated.

- If `<p2>`'s value is also `#f`, then `<p3>` is evaluated.

- This process continues until the first predicate `<pi>` is found whose value is true, in which case the interpreter returns the result of evaluating each of the corresponding list of consequent expressions `<eli>` and returning the last value as the value of the whole conditional expression.

  **Note:** Unless some of the expressions have side-effects, there is no point in having more than one expression in an expression list `<eli>`.

- The `else` keyword, if present, is taken to be true, so that if none of the `<p>`'s is found to be true, the interpreter evaluates the `else-expressions` and returns the last value.

- If no clause has a true predicate, the result is an "unspecified value".

This is a somewhat simplified version of the semantics of `cond`, covering the cases we usually encounter.

==Â¢ûÊ∑ªÁêÜËß£Ôºö==

<img src="C:\Users\cyc\AppData\Roaming\Typora\typora-user-images\image-20220220104344466.png" alt="image-20220220104344466" style="zoom:50%;" />



#### Q2: Sign

Using `cond`, define a procedure `sign` that returns `-1` for negative arguments, `0` for zero, and `1` for positive arguments:

```scheme
(define (sign x)  
  'YOUR-CODE-HERE
  (cond ((> x 0) 1) ((= x 0) 0) ((< x 0) -1)
   )
)
```

Use Ok to unlock and test your code:

```
python3 ok -q sign -u
python3 ok -q sign
```

#### Q3: Pow

Implement a procedure `pow` for raising the number `b` to the power of a nonnegative integer `n` that runs in Œò(log n) time.

> *Hint:* Consider the following observations:
>
> <img src="C:\Users\cyc\AppData\Roaming\Typora\typora-user-images\image-20220220104821466.png" alt="image-20220220104821466" style="zoom:80%;" />
>
> You may use the built-in predicates `even?` and `odd?`.

```scheme
(define (square x) (* x x))

(define (pow b n)
  'YOUR-CODE-HERE
    (if (= n 0) 1
      (* b (pow b (- n 1)))
   )
  ____________
  (cond ((= n 0) 1)
      	((= 0 (remainder n 2)) (square (pow b (// n 2)))) 
        (else (* b (pow b (- n 1))))
   )
)
```

Use Ok to unlock and test your code:

```
python3 ok -q pow -u
python3 ok -q pow
```

#### Q4: Ordered

Implement a procedure called `ordered?`, which takes a list of numbers and returns `True` if the numbers are in nondescending order, and `False` otherwise. Numbers are considered nondescending if they are in a monotonically increasing sequence, that is:

```
1 2 3 3 4
```

Is nondescending, but:

```
1 2 3 3 2
```

Is not.

> *Hint*: The built-in `null?` function returns whether its argument is `nil`.

```scheme
(define (ordered? s)
  'YOUR-CODE-HERE
    (if (null? (cdr s)) 'True
        (cond ((< (cadr s) (car s)) 'False)
              (else (ordered? (cdr s))))
    )
)
```

Use Ok to unlock and test your code:

```
python3 ok -q ordered -u
python3 ok -q ordered
```

<font color = pink>ÊÑüËßâÂ∞±ÊòØÔºå‰∏ÄÂÆöË¶Å‰øùËØÅÊã¨Âè∑ÊòØÂØπÁöÑÔºåÁÑ∂ÂêéÂÜçÊâæÂà´ÁöÑbug</font>

#### Q5: No Dots! 

Implement the procedure `nodots`, which takes a nested list of numbers that may not be well-formed and returns a nested list with the same content and structure, but which does not have any dots when displayed. Lists are not well-formed if they do not properly terminate in a null list. ==In such cases, the list will print with a dot before the final item to indicate that its last two items are contained in a single pair.== For example,

```
(cons 1 (cons 2 3))
```

would print as

```
(1 2 . 3)
```

for which `nodots` should substitute

```
(1 2 3)
```

> ==You may find the built-in `null?` and `pair?` predicates useful.==

```
(define (nodots s)
    (cond ((null? s) s)
          ((not (pair? s)) s)
          ((and (not(pair? (cdr s)))(not (null? (cdr s)))) (nodots (list (car s) (cdr s))))
          (else (append (list (nodots (car s))) (nodots (cdr s))))
    )
)
```

Use Ok to unlock and test your code:

```
python3 ok -q nodots -u
python3 ok -q nodots
```

==ÊòØËøôÊ†∑ÁöÑÔºö==

<img src="C:\Users\cyc\AppData\Roaming\Typora\typora-user-images\image-20220220153221749.png" alt="image-20220220153221749" style="zoom:50%;" />

<img src="C:\Users\cyc\AppData\Roaming\Typora\typora-user-images\image-20220220154028760.png" alt="image-20220220154028760" style="zoom:50%;" />

<font color = pink>ÊòØÊúâÁÇπÊäòÁ£®ÁöÑÈ¢òÔºå‰ΩÜÊòØÊÉ≥‰∏ÄÊÉ≥‰∏çÂêåÊÉÖÂÜµÁöÑcaseÊúÄÂêéËøòÊòØÂèØ‰ª•ÂÖ®Èù¢Âú∞ÂÜôÂá∫Êù•„ÄÇüòÜ</font>

### Sets as Ordered Lists

One way to represent a set is by using an ordered list, where the ordering is used to speed up search (although only by a constant factor). The following few questions explore this idea, ==assuming a "set" is a Scheme list with no repeated elements that is already ordered from least to greatest==.

#### Q6: Contains

Define `contains?`, which returns whether a set `s` contains value `v`. The Python implementation of this procedure is provided for your reference.

```scheme
; Sets as sorted lists

(define (empty? s) (null? s))

(define (contains? s v)
    (cond ((empty? s) #f)
          'YOUR-CODE-HERE
          ((> (car s) v) False)
          ((= (car s) v) True)
          (else (contains? (cdr s) v)) ; replace this line
          ))

; Equivalent Python code, for your reference:
;
; def empty(s):
;     return s is Link.empty
;
; def contains(s, v):
;     if empty(s):
;         return False
;     elif s.first > v:
;         return False
;     elif s.first == v:
;         return True
;     else:
;         return contains(s.rest, v)
```

Use Ok to unlock and test your code:

```
python3 ok -q contains -u
python3 ok -q contains
```

#### Q7: Add

Define `add`, which takes a set `s` and a value `v` as arguments. It returns a representation of a set containing the values in `s` and the value `v`. There should be no repeated elements in the return value.

```scheme
(define (add s v)
    (cond ((empty? s) (list v))
          ((> (car s) v) (append (list v) s))
          ((= (car s) v) s)
          (else (append (list (car s)) (add (cdr s) v))) ; replace this line
          ))
```

Use Ok to unlock and test your code:

```
python3 ok -q add -u
python3 ok -q add
```

#### Q8: Intersect and Union

Define `intersect`, which returns a set containing only values that appear in both sets `s` and `t`. Your implementation should ==run in linear time in the length of the input sets==. A Python implementation of this procedure is provided for your reference.

Also, define `union`, which returns a set containing all values that appear in either set `s` or `t`.

```scheme
(define (intersect s t)
    (cond ((or (empty? s) (empty? t)) nil)
          ((= (car s) (car t)) (append (list (car s)) (intersect (cdr s) (cdr t))))
          ((< (car s) (car t)) (intersect (cdr s) t))
          (else (intersect s (cdr t))); replace this line
          ))

; Equivalent Python code, for your reference:
;
; def intersect(set1, set2):
;     if empty(set1) or empty(set2):
;         return Link.empty
;     else:
;         e1, e2 = set1.first, set2.first
;         if e1 == e2:
;             return Link(e1, intersect(set1.rest, set2.rest))
;         elif e1 < e2:
;             return intersect(set1.rest, set2)
;         elif e2 < e1:
;             return intersect(set1, set2.rest)

(define (union s t)
    (cond ((empty? s) t)
          ((empty? t) s)
          ((= (car s) (car t)) (append (list (car s)) (union (cdr s) (cdr t))))
          ((< (car s) (car t)) (append (list (car s)) (union (cdr s) t)))
          (else (append (list (car t)) (union s (cdr t)))); replace this line
          ))
```

Use Ok to unlock and test your code:

```
python3 ok -q intersect -u
python3 ok -q intersect
python3 ok -q union -u
python3 ok -q union
```



## lab09: Scheme

### Topics 

> **Note:** We're diving into **a new programming language** today! As such, the Topics section is lengthier than usual and covers a lot of fundamentals that will help you build a good foundation for understanding the Scheme material in this course. We recommend that you thoroughly read this section before beginning the problems.

#### Scheme

Scheme is a famous functional programming language from the 1970s. ==It is a dialect of Lisp (which stands for LISt Processing)==. The first observation most people make is the unique syntax, which uses a prefix notation and (often many) nested parentheses (see http://xkcd.com/297/). ==Scheme features first-class functions and optimized tail-recursion, which were relatively new features at the time==. (<font color = pink>ËÇæ‰πàÊòØfirst-class functions and optimized tail-recursion?</font>)

> Our course uses a custom version of Scheme (which you will build for Project 4) included in the starter ZIP archive. To start the interpreter, type `python3 scheme`. To run a Scheme program interactively, type `python3 scheme -i <file.scm>`. To exit the Scheme interpreter, type `(exit)`.

You may find it useful to try [scheme.cs61a.org](https://scheme.cs61a.org/) when working through problems, as it can draw environment and box-and-pointer diagrams and it lets you walk your code step-by-step (similar to Python Tutor). Don't forget to submit your code through Ok though!

#### Expressions

##### Primitives

Just like in Python, primitive, or atomic, expressions in Scheme **take a single step to evaluate**. ==These include numbers, booleans, names, and symbols==.

**Out of these, the symbol type is the only one we didn't encounter in Python.** ==A **symbol** acts a lot like a Python string, but not exactly==. For now, just be aware that you can represent a string of valid Scheme characters as a symbol.

In Scheme, *all* values except the special boolean value `#f` are interpreted as true values (unlike Python, where there are some false-y values like `0`). Our particular version of the Scheme interpreter allows you to write `True` and `False` in place of `#t` and `#f`. This is not standard.

```
scm> 1234    ; integer
1234
scm> 123.4   ; real number
123.5
scm> true    ; alias for built-in true value
#t
scm> 'a      ; symbol
a
scm> 'hello-world!
hello-world!
```

##### Call expressions

==All expressions that aren't atomic expressions are either call expressions or special forms==. Both are written as Scheme [lists](https://inst.eecs.berkeley.edu//~cs61a/sp18/lab/lab09/#list)(<font color = pink>ÂÖ≥‰∫éScheme listsËßÅ‰∏ã</font>). A call expression has the following syntax:

```
(<operator> <operand1> <operand2> ...)
```

Like Python, the operator comes before all the operands. Unlike Python, the operator is included within the parentheses and the operands are separated by spaces rather than with commas. **However, evaluation of a Scheme call expression follows the exact same rules as in Python:**

1. Evaluate the operator. It should evaluate to a procedure.
2. Evaluate the operands, left to right.
3. Apply the procedure to the evaluated operands.

Here are some examples using mathematical operators:

```
scm> (+ 1 2)
3
scm> (* 3 4)
12
scm> (- 10 (/ 6 2))
7
```

##### Special forms

A special form in Scheme has the exact same syntax as a call expression:

```
(<special-form> <operand1> <operand2> ...)
```

What makes them "special" is that **they do not follow the three rules of evaluation stated in the previous section.** Instead, each special form follows its own special rules for execution, **such as short-circuiting before evaluating all the operands**.

==Some examples of special forms that we'll study today are the `if`, `cond`, `define`, and `lambda` forms==. Read their corresponding sections below to find out what their rules of evaluation are!

#### Control Structures

##### `if` Expressions

In Scheme, an `if` expression is a special form with the following syntax:

```
(if <condition> <true-result> <false-result>)
```

Note the similar syntax to a call expression: the `if` keyword precedes the 3 operands in a space separated list. The rules for evaluating the `if` special form are as follows:

1. Evaluate `<condition>`.
2. If `<condition>` evaluates to a truth-y value, the whole `if` expression evaluates to the value of `<true-result>`. Otherwise, it evaluates to the value of `<false-result>`.

Can you see why this expression is a special form? Compare the rules between a regular call expression and an `if` expression. What is the difference? 

The following blocks of code written in Scheme and Python are roughly equivalent:

![image-20220223100620601](C:\Users\cyc\AppData\Roaming\Typora\typora-user-images\image-20220223100620601.png)

The reason these blocks of code are not exactly equivalent is that ==a Scheme `if` expression actually evaluates to a value whereas a Python `if` statement simply directs the flow of the program==. In this case, the Scheme code actually evaluates to `1` or `2`, while the Python code just prints the values.

Moreover, it's possible to add even more lines of code into the suites of the Python `if` statement besides the print statements, while a Scheme `if` expression expects just a single expression for each of the true result and the false result.

Another difference is that in Scheme, you cannot write `elif` cases. If you want to have multiple cases using the `if` expression, you would need multiple branched `if` expressions:

![image-20220223100638258](C:\Users\cyc\AppData\Roaming\Typora\typora-user-images\image-20220223100638258.png)

##### `cond` Expressions

Using nested `if` expressions doesn't seem like a very practical way to take care of multiple cases. Instead, ==we can use the `cond` special form, a general conditional expression similar to a multi-clause if/elif/else conditional expression in Python==. `cond` takes in an arbitrary number of arguments known as *clauses*. A clause is written as a list containing two expressions: `(<p> <e>)`.

```
(cond
    (<p1> <e1>)
    (<p2> <e2>)
    ...
    (<pn> <en>)
    (else <else-expression>))
```

The first expression in each clause is a **predicate** -- an expression whose value is interpreted as either `True` or `False`. The second expression in the clause is the return expression corresponding to its predicate. The optional `else` clause has no predicate.

**The rules of evaluation are as follows:**

1. Evaluate the predicates `<p1>`, `<p2>`, ..., `<pn>` in order until you reach one that evaluates to a truth-y value.
2. The `cond` expression evaluates to the value of the `<ei>` corresponding to the first true `<pi>` expression.
3. If none of the predicates are truth-y and there is an `else` clause, evaluate and return `<else-expression>`.

As you can see, `cond` is a special form because it does not evaluate its operands in their entirety; the predicates are evaluated separately from their corresponding return expression. In addition, **the expression short circuits upon reaching the first predicate that evaluates to a truth-y value, leaving the remaining predicates unevaluated.**

The following code is roughly equivalent (see the explanation in the [if expression section](https://inst.eecs.berkeley.edu//~cs61a/sp18/lab/lab09/#if-expressions)):

![image-20220223100915750](C:\Users\cyc\AppData\Roaming\Typora\typora-user-images\image-20220223100915750.png)

#### Lists

> As you read through this section, it may be difficult to understand the differences between the various representations of Scheme containers. We recommend that you use [our online Scheme interpreter](http://scheme.cs61a.org/) to see the box-and-pointer diagrams of pairs and lists that you're having a hard time visualizing! (Use the command `(autodraw)` to toggle the automatic drawing of diagrams.) <font color = pink>Â•ΩÁî®ÔºåüòÄ</font>

##### Pairs

==A pair is a built-in data type in Scheme that holds two values==. To create a pair, use the `cons` procedure, which takes in two arguments:

```
scm> (cons 3 5)
(3 . 5)
```

==Elements in a pair are displayed as separated by a dot.== We can use the `car` and `cdr` procedures to retrieve the first and second elements in the pair, respectively.

```
scm> (car (cons 3 5))
3
scm> (cdr (cons 3 5))
5
```

==It's possible to nest `cons` calls such that an element within a pair is another pair!==

```
scm> (cons (cons 1 2) 3)
((1 . 2) . 3)
scm> (cons 1 (cons 2 3))
(1 2 . 3)
```

You may be wondering why the first dot disappeared in the value of the second expression (i.e., why isn't it displayed as `(1 . (2 . 3))`?). ==This is because when Scheme sees a dot followed by an open parenthesis, it will remove the dot, the open parenthesis, and the corresponding close parenthesis:==

```
(a . ( ... )) -> (a ...)
```

**Read on to find out how to make a list without any dots!**

##### Well-formed lists

==Scheme lists are very similar to the linked lists we've been working with in Python==. Just like how a linked list is constructed of a series of `Link` objects, **a Scheme list is constructed with a series of pairs**.

**A well-formed Scheme list is a list in which the `cdr` is either another well-formed list or `nil`, an empty list. A well-formed list is displayed in the interpreter with no dots.** To understand this, first observe the following pair construction:

```
scm> (cons 1 (cons 2 3))
(1 2 . 3)
```

This is what's known as a *malformed list*, one where the `cdr` is not either a well-formed list or `nil`. Note that you can still see the dot. Now, take a look at this pair construction:

```
scm> (cons 1 (cons 2 (cons 3 nil)))
(1 2 3)
```

**Here, we've created a *well-formed list* by ensuring that the second argument of each `cons` expression is another `cons` expression or `nil`.** Yay, no more dots! 

We can ==retrieve values== from our list with the `car` and `cdr` procedures, which now work similarly to the Python `Link`'s `first` and `rest` attributes. (Curious about where these weird names come from? [Check out their etymology.](https://en.wikipedia.org/wiki/CAR_and_CDR))

```
scm> (define a (cons 1 (cons 2 (cons 3 nil))))  ; Assign the list to the name a
scm> a
(1 2 3)
scm> (car a)
1
scm> (cdr a)
(2 3)
scm> (car (cdr (cdr a)))
3
```

##### `list` Procedure

There are a few other ways to create lists. The `list` procedure **takes in an arbitrary number of arguments and constructs a well-formed list with the values of these arguments:**

```
scm> (list 1 2 3)
(1 2 3)
scm> (list 1 (list 2 3) 4)
(1 (2 3) 4)
scm> (list (cons 1 2) 3 4)
((1 . 2) 3 4)
```

==Note that all of the operands in this expression are evaluated before being put into the resulting list.==

##### Quote Form

**We can also use the quote form to create a list**, which will construct the exact list that is given. Unlike with the `list` procedure, the argument to `'` is ***not* evaluated**.

```
scm> '(1 2 3)
(1 2 3)
scm> '(1 2 . 3)
(1 2 . 3)
scm> '(cons 1 2)           ; Argument to quote is not evaluated
(cons 1 2)
scm> '(1 (2 3 4))
(1 (2 3 4))
scm> '(1 . (2 3 4))        ; Removes dot/parentheses when possible
(1 2 3 4)
```

<img src="C:\Users\cyc\AppData\Roaming\Typora\typora-user-images\image-20220223102423306.png" alt="image-20220223102423306" style="zoom:67%;" />

ÂÜçÂõûÈ°æ‰∏Ä‰∏ãdotÁöÑÂ∑•‰ΩúËßÑÂàôÔºö==This is because when Scheme sees a dot followed by an open parenthesis, it will remove the dot, the open parenthesis, and the corresponding close parenthesis:==

<img src="C:\Users\cyc\AppData\Roaming\Typora\typora-user-images\image-20220223102635576.png" alt="image-20220223102635576" style="zoom:67%;" />



##### Built-In Procedures for Lists

**There are a few other built-in procedures in Scheme that are used for lists**. Try them out in the interpreter!

```
scm> (null? nil)                ; Checks if a list is empty
______
scm> (append '(1 2 3) '(4 5 6)) ; Concatenates two lists
______
scm> (length '(1 2 3 4 5))      ; Returns the number of elements in a list
______
```

##### Defining procedures

To define procedures, we use the special form `define`, which has the following syntax:

```
(define (<name> <param1> <param2> ...)
    <body>
)
```

This expression defines a function with the given parameters and body and assigns it to the given name in the current environment.

A procedure may take in any number of parameters. The `<body>` may contain multiple expressions. ==There is not an equivalent version of a Python `return` statement in Scheme. The function will return the value of the last expression in the body==.

This expression is a special form because its operands are not evaluated at all! For example, `<body>` is not evaluated when a procedure is defined, but rather when it is called. `<name>` and the parameter names are all names that should not be evaluated when executing this `define` expression.

#### Lambdas

Ah yes, you thought you were safeÔºàÂìàÂìàÔºåü§£Ôºâ, but we can also write lambda procedures in Scheme! A `lambda` expression has the following syntax:

```
(lambda (<param1> <param2> ...) <body>)
```

Notice how the only difference between this expression and a `define` expression **is the lack of procedure name**. This expression will create and return a function, **but will not alter the current environment**. This is very similar to the difference between a `def` statement and `lambda` expression in Python!

```
scm> (lambda (x y) (+ x y))        ; Returns a lambda function, but doesn't assign it to a name
(lambda (x y) (+ x y))
scm> ((lambda (x y) (+ x y)) 3 4)  ; Create and call a lambda function in one line
7
```

### Required questions:

#### What Would Scheme Display?

#### Q1: WWSD: Lists

> Use Ok to test your knowledge with the following "What Would Scheme Display?" questions:
>
> ```
> python3 ok -q wwsd-lists -u
> ```

```scheme
scm> (cons 1 2)
______
scm> (cons 1 (cons 2 nil))
______
scm> (car (cons 1 (cons 2 nil)))
______
scm> (cdr (cons 1 (cons 2 nil)))
______
scm> (list 1 2 3)
______
scm> (list 1 (cons 2 3))
______
scm> '(1 2 3)
______
scm> '(2 . 3)
______
scm> '(2 . (3))  ; Recall dot rule for pairs
______
scm> (equal? '(1 . (2 . 3)) (cons 1 (cons 2 (cons 3 nil)))) ; Recall how boolean values are displayed
______
scm> (equal? '(1 . (2 . 3)) (cons 1 (cons 2 3)))
______
scm> (equal? '(1 . (2 . 3)) (list 1 (cons 2 3))) ; Ëøô‰∏™ËøòÊå∫ÊúâÊÑèÊÄùÁöÑÔºåËßÅ‰∏ãÂõæ
______
scm> (cons 1 '(list 2 3))  ; Recall quotingÔºå Ëøô‰∏™‰πüÈùûÂ∏∏‰ª§‰∫∫ÂêÉÊÉäÂì¶
______
scm> (cons (list 2 (cons 3 4)) nil) ; Â•ΩÂïäÂ•ΩÂïä
______
scm> (car (cdr '(127 . ((131 . (137))))))
______
scm> (equal? '(1 . ((2 . 3))) (cons 1 (cons (cons 2 3) nil)))
______
scm> '(cons 4 (cons (cons 6 8) ())) ; Â§™Â§çÊùÇ‰∫Üe'e
```

<img src="C:\Users\cyc\AppData\Roaming\Typora\typora-user-images\image-20220224213528580.png" alt="image-20220224213528580" style="zoom:67%;" />

<img src="C:\Users\cyc\AppData\Roaming\Typora\typora-user-images\image-20220224213737911.png" alt="image-20220224213737911" style="zoom:67%;" />

<img src="C:\Users\cyc\AppData\Roaming\Typora\typora-user-images\image-20220224214032620.png" alt="image-20220224214032620" style="zoom:67%;" />

#### Coding Questions

#### Q2: Over or Under

Define a procedure `over-or-under` which takes in an `x` and a `y` and returns the the following:

- return -1 if `x` is less than `y`
- return 0 if `x` is equal to `y`
- return 1 if `x` is greater than `y`

```scheme
(define (over-or-under x y)
  (cond ((< x y) -1)
        ((= x y) 0)
        (else 1)
  )
)

;;; Tests
(over-or-under 1 2)
; expect -1
(over-or-under 2 1)
; expect 1
(over-or-under 1 1)
; expect 0
```

Use Ok to unlock and test your code:

```
python3 ok -q over-or-under -u
python3 ok -q over-or-under
```

#### Q3: Filter

Write a procedure `filter`, which takes a predicate `f` and a list `lst`, and returns a new list containing only elements of the list that satisfy the predicate. The output should contain the elements in the same order that they appeared in the original list.

```scheme
(define (filter f lst)
  (if (null? lst) lst
        (if (null? (cdr lst))
      (if (f (car lst)) lst nil)
        (cond ((f (car lst)) (append (list (car lst)) (filter f (cdr lst))))
        (else (filter f (cdr lst)))
        )
  )
  )
)

;;; Tests
(define (even? x)
  (= (modulo x 2) 0))
(filter even? '(0 1 1 2 3 5 8))
; expect (0 2 8)
```

Use Ok to unlock and test your code:

```
python3 ok -q filter -u
python3 ok -q filter
```

#### Q4: Make Adder

Write the procedure `make-adder` which takes in an initial number, `num`, and then returns a procedure. This returned procedure takes in a number `x` and returns the result of `x + num`.

```scheme
(define (make-adder num)
  (lambda (number)
          (+ num number)
  )
)

;;; Tests
(define adder (make-adder 5))
(adder 8)
; expect 13
```

Use Ok to unlock and test your code:

```
python3 ok -q make-adder -u
python3 ok -q make-adder
```

### Optional questions:

#### Q5: Make a List

Create the list with the following box-and-pointer diagram:

<img src="C:\Users\cyc\AppData\Roaming\Typora\typora-user-images\image-20220225160217385.png" alt="image-20220225160217385" style="zoom:67%;" />

```scheme
(define lst
  'YOUR-CODE-HERE
)
```

Use Ok to unlock and test your code:

```
python3 ok -q make-list -u
python3 ok -q make-list
```

#### Q6: Compose

Write the procedure `composed`, which takes in procedures `f` and `g` and outputs a new procedure. This new procedure takes in a number `x` and outputs the result of calling `f` on `g` of `x`.

```scheme
(define (composed f g)
  (lambda (x) (f (g x))
  )
)
```

Use Ok to unlock and test your code:

```
python3 ok -q composed -u
python3 ok -q composed
```

#### Q7: Remove

Implement a procedure `remove` that takes in a list and returns a new list with *all* instances of `item` removed from `lst`. You may assume the list will only consist of numbers and will not have nested lists.

*Hint*: You might find the `filter` procedure useful.

```scheme
(define (remove item lst)
  (filter (lambda (x) (not (= item x)) ) lst)
)


;;; Tests
(remove 3 nil)
; expect ()
(remove 3 '(1 3 5))
; expect (1 5)
(remove 5 '(5 3 5 5 1 4 5 4))
; expect (3 1 4 4)
```

Use Ok to unlock and test your code:

```
python3 ok -q remove -u
python3 ok -q remove
```

#### Q8: Greatest Common Divisor

Let's revisit a familiar problem: finding the greatest common divisor of two numbers.

Write the procedure `gcd`, which computes the gcd of numbers `a` and `b`. Recall that the *greatest common divisor* of two positive integers `a` and `b` is the largest integer which evenly divides both numbers (with no remainder). [Euclid's algorithm](http://en.wikipedia.org/wiki/Euclidean_algorithm#Description) states that ==the greatest common divisor is==

- the smaller value if it evenly divides the larger value, OR
- the greatest common divisor of the smaller value and the remainder of the larger value divided by the smaller value

In other words, if `a` is greater than `b` and `a` is not divisible by `b`, then

```
gcd(a, b) == gcd(b, a % b)
```

You may find the provided procedures `min` and `max` helpful. You can also use the built-in `modulo` procedure.

```scheme
(define (max a b) (if (> a b) a b))
(define (min a b) (if (> a b) b a))
(define (gcd a b)
        (cond ((= a b) a)
              ((= 0 (min a b)) (max a b))
              ((= 0 (modulo (max a b) (min a b) )) (min a b))
              (else (gcd (min a b) (remainder (max a b) (min a b))))
        )
)

;;; Tests
(gcd 24 60)
; expect 12
(gcd 1071 462)
; expect 21
```

Use Ok to unlock and test your code:

```
python3 ok -q gcd -u
python3 ok -q gcd
```

#### Q9: No Repeats

Implement `no-repeats`, which takes a list of numbers `s` as input and returns a list that has all of the unique elements of `s` in the order that they first appear, but no repeats. For example, `(no-repeats (list 5 4 5 4 2 2))` evaluates to `(5 4 2)`.

*Hints*: To test if two numbers are equal, use the `=` procedure. To test if two numbers are not equal, use the `not` procedure in combination with `=`. You may find it helpful to use the `filter` procedure.

==ÊÑüËßâËá™Â∑±ËÉΩÂÅöÂá∫Êù•Ëøô‰πàÂ¶ôÁöÑÈ¢òËøòÊòØÊå∫ÂéâÂÆ≥ÁöÑÔºåÊàëÁúü‰∏çÈîôÔºåÂìàÂìà==

```scheme
(define (no-repeats s)
  (cond ((eq? nil s) s)
        ((eq? nil (cdr s)) s)
        (else (append (list (car s))(filter (lambda (x) (not (eq? x (car s)))) (no-repeats (cdr s)))))
  )
)
```

Use Ok to unlock and test your code:

```
python3 ok -q no-repeats -u
python3 ok -q no-repeats
```

#### Q10: Substitute

Write a procedure `substitute` that takes three arguments: a list `s`, an `old` word, and a `new` word. It returns a list with the elements of `s`, but with every occurrence of `old` replaced by `new`, ==even within sub-lists==.

*Hint*: The built-in `pair?` predicate returns True if its argument is a `cons` pair.

*Hint*: The `=` operator will only let you compare numbers, but using `equal?` or `eq?` will let you compare symbols as well as numbers. For more information, check out the [Scheme Primitives Reference](https://inst.eecs.berkeley.edu/~cs61a/sp18/articles/scheme-primitives.html#general).

Use Ok to unlock and test your code:

```scheme
python3 ok -q substitute -u
python3 ok -q substitute
(define (substitute s old new)
        (cond ((eq? nil s) s)
              ((eq? (car s) old) (append (list new) (substitute (cdr s) old new)))
              ((pair? (car s)) (append (list (substitute (car s) old new)) (substitute (cdr s) old new)))
              (else (append (list (car s))(substitute (cdr s) old new)))
        )
)
```

#### Q11: Sub All

Write `sub-all`, which takes a list `s`, a list of `old` words, and a list of `new` words; the last two lists must be the same length. It returns a list with the elements of `s`, ==but with each word that occurs in the second argument replaced by the corresponding word of the third argument==. You may use `substitute` in your solution.

```
(define (sub-all s olds news)
  'YOUR-CODE-HERE
          (cond ((eq? nil olds) s)
              ((eq? nil (cdr olds)) (substitute s (car olds) (car news)))
              (else (sub-all s (cdr olds) (cdr news)))
        )
)
```

==È¢òÁõÆËßÑÂàôÊòØËøôÊ†∑ÁöÑÔºö== <font color = pink>ËøòÊòØË¶ÅÊúâÊ∏ÖÈÜíÁöÑÊÄùË∑Ø</font>

<img src="C:\Users\cyc\AppData\Roaming\Typora\typora-user-images\image-20220301170145535.png" alt="image-20220301170145535" style="zoom:67%;" />

Use Ok to unlock and test your code:

```
python3 ok -q sub-all -u
python3 ok -q sub-all
```

## hw09

> Our course uses a custom version of Scheme (which you will build for Project 4) included in the starter ZIP archive. To start the interpreter, type `python3 scheme`. To run a Scheme program interactively, type `python3 scheme -i <file.scm>`. To exit the Scheme interpreter, type `(exit)`.

#### Q1: How Many Dots?

Implement `how-many-dots`, which takes in a nested scheme list `s` and returns the number of dots that appear when it is displayed by the interpreter (not counting decimal points). You may assume that `s` is a nested list that contains only numbers.

*Hints*: ==A dot appears when the second element of a pair is not a well formed list==. The procedures `pair?`, `null?`, and `number?` test whether a value is a pair, `nil`, or a number, respectively.

```scheme
(define (how-many-dots s)
  'YOUR-CODE-HERE
          (cond ((eq? nil s) 0)
              ((number? s) 1)
              ((pair? (car s)) (+ (how-many-dots (car s)) (how-many-dots (cdr s))))
              ((and (pair? s) (number? (cdr s))) 1)
              (else (how-many-dots (cdr s)))
)
```

Use Ok to unlock and test your code:

<font color = pink>Â∞±ÊòØ‰∏ãÈù¢Êà™ÂõæÁöÑÊÉÖÂÜµÊúâ‰∫õÂ§çÊùÇÔºå‰ΩÜÊòØÊòØËÉΩÂÜôÊòéÁôΩÁöÑÔºåÂìàÂìà„ÄÇ</font>

==ËßÑÂàôÊòØËøôÊ†∑ÁöÑÔºö==

<img src="C:\Users\cyc\AppData\Roaming\Typora\typora-user-images\image-20220301214553360.png" alt="image-20220301214553360" style="zoom:67%;" />

```
python3 ok -q how-many-dots -u
python3 ok -q how-many-dots
```

#### Differentiation

The following problems develop a system for [symbolic differentiation](http://en.wikipedia.org/wiki/Table_of_derivatives#Elementary_rules_of_differentiation) of algebraic expressions. The `derive` Scheme procedure takes an algebraic expression and a variable and returns the ==derivative==(Ë°çÁîüÁâ©ÔºüÂØºÊï∞Ôºü) of the expression with respect to the variable. Symbolic differentiationÔºàÁ¨¶Âè∑ÂæÆÂàÜÊ≥ïÔºüÔºâ is of special historical significance in Lisp. **It was one of the motivating examples behind the development of the language.** Differentiating is a recursive process that applies different rules to different kinds of expressions.

```scheme
; derive returns the derivative of EXPR with respect to VAR
(define (derive expr var)
  (cond ((number? expr) 0)
        ((variable? expr) (if (same-variable? expr var) 1 0))
        ((sum? expr) (derive-sum expr var))
        ((product? expr) (derive-product expr var))
        ((exp? expr) (derive-exp expr var))
        (else 'Error)))
```

**To implement the system, we will use the following data abstraction.** Sums and products are lists, and they are simplified on construction:

==ÂÖ≥‰∫ésymbolÁ≠âschemeËØ≠Ë®ÄÁÇπËßÅÔºö==https://inst.eecs.berkeley.edu/~cs61a/sp18/articles/scheme-spec.html#symbols

```scheme
; Variables are represented as symbols
(define (variable? x) (symbol? x))
(define (same-variable? v1 v2)
  (and (variable? v1) (variable? v2) (eq? v1 v2)))

; Numbers are compared with =
(define (=number? expr num)
  (and (number? expr) (= expr num)))

; Sums are represented as lists that start with +.
(define (make-sum a1 a2)
  (cond ((=number? a1 0) a2)
        ((=number? a2 0) a1)
        ((and (number? a1) (number? a2)) (+ a1 a2))
        (else (list '+ a1 a2))))
(define (sum? x)
  (and (list? x) (eq? (car x) '+)))
(define (addend s) (cadr s))
(define (augend s) (caddr s))

; Products are represented as lists that start with *.
(define (make-product m1 m2)
  (cond ((or (=number? m1 0) (=number? m2 0)) 0)
        ((=number? m1 1) m2)
        ((=number? m2 1) m1)
        ((and (number? m1) (number? m2)) (* m1 m2))
        (else (list '* m1 m2))))
(define (product? x)
  (and (list? x) (eq? (car x) '*)))
(define (multiplier p) (cadr p))
(define (multiplicand p) (caddr p))
```

> Note that we will not test whether your solutions to this question correctly apply the [chain rule](https://en.wikipedia.org/wiki/Chain_rule). For more info, check out the [extensions](https://inst.eecs.berkeley.edu//~cs61a/sp18/hw/hw09/#extensions) section.

#### Q2: Derive Sum

Implement `derive-sum`, ==a procedure that differentiates a sum by summing the derivatives of the `addend` and `augend`==. Use data abstraction for a sum.

```scheme
(define (derive-sum expr var)
  'YOUR-CODE-HERE
        (make-sum (derive (addend expr) var) (derive (augend expr) var))
)
```

Use Ok to unlock and test your code:

==Êå†Â§¥ÔºåÂ§ßÊ¶ÇÂ∞±ÊòØÊ±ÇÂØºÔºü==

<img src="C:\Users\cyc\AppData\Roaming\Typora\typora-user-images\image-20220301230343803.png" alt="image-20220301230343803" style="zoom:67%;" />

```
python3 ok -q derive-sum -u
python3 ok -q derive-sum
```

#### Q3: Derive Product

Implement `derive-product`, which applies [the product rule](http://en.wikipedia.org/wiki/Product_rule) to differentiate products. ==This means taking the multiplier and multiplicand, and then summing the result of multiplying one by the derivative of the other==.

> The `ok` tests expect the terms of the result in a particular order. First, multiply the derivative of the multiplier by the multiplicand. Then, multiply the multiplier by the derivative of the multiplicand. Sum these two terms to form the derivative of the original product.

```scheme
(define (derive-product expr var)
  'YOUR-CODE-HERE
  (make-sum (make-product (derive (multiplier expr) var) (multiplicand expr)) (make-product (derive (multiplicand expr) var) (multiplier expr))) ;ËøôÊòØ‰∏ÄË°åÂìàÔºåÊúâÁÇπÈïøÁöÑ‰∏ÄË°åÁΩ¢‰∫ÜÔºåÂòø„ÄÇ
)
```

Use Ok to unlock and test your code:

```
python3 ok -q derive-product -u
python3 ok -q derive-product
```

#### Q4: Make Exp

==Implement a data abstraction for exponentiationÔºàÊåáÊï∞ËøêÁÆóÔºâ==: a `base` raised to the power of an `exponent`. The `base` can be any expression, but assume that the `exponent` is a non-negative integer. You can simplify the cases when `exponent` is `0` or `1`, or when `base` is a number, by returning numbers from the constructor `make-exp`. In other cases, you can represent the exp as a triple `(^ base exponent)`.

> You may want to use the built-in procedure `expt`, which takes two number arguments and raises the first to the power of the second.

```scheme
; Exponentiations are represented as lists that start with ^.
(define (make-exp base exponent)
  'YOUR-CODE-HERE
  (cond ((=number? exponent 0) 1)
  	    ((=number? exponent 1) base)
  	    ((number? base) (expt base exponent))
  	    (else (list '^ base exponent)))
)

(define (base exp)
  'YOUR-CODE-HERE
  (cadr exp)
)

(define (exponent exp)
  'YOUR-CODE-HERE
  (caddr exp)
)

(define (exp? exp)
  'YOUR-CODE-HERE
  (and (list? exp) (eq? (car exp) '^))
)

(define x^2 (make-exp 'x 2))
(define x^3 (make-exp 'x 3))
```

Use Ok to unlock and test your code:

```
python3 ok -q make-exp -u
python3 ok -q make-exp
```

#### Q5: Derive Exp

Implement `derive-exp`, which uses the [power rule](http://en.wikipedia.org/wiki/Power_rule) to derive exponents. Reduce the power of the exponent by one, and multiply the entire expression by the original exponent.

```
(define (derive-exp exp var)
  'YOUR-CODE-HERE
  (make-product (exponent exp) (make-exp (base exp) (- (exponent exp) 1)))
)
```

Use Ok to unlock and test your code:

<font color = pink>Âç°‰∫Ü‰∏Ä‰ºöÂÑøÔºåÊâçÂèëÁé∞ÊòØÂú®Q2 derive sumÈÇ£ÈáåÂÜôÂæóÊúâÈóÆÈ¢òÔºå‰∏çËÉΩÁî®+ÔºåËÄåË¶ÅÁî®ËøôÈáåÁöÑmake-sumÂì¶ÔºåÂõ†‰∏∫operand‰∏ç‰∏ÄÂÆöÊòØÊï∞Â≠ó</font>

```
python3 ok -q derive-exp -u
python3 ok -q derive-exp
```

#### Extensions

There are many ways to extend this symbolic differentiation system. For example, you could simplify nested exponentiation expression such as `(^ (^ x 3) 2)`, products of exponents such as `(* (^ x 2) (^ x 3))`, and sums of products such as `(+ (* 2 x) (* 3 x))`. You could apply the [chain rule](https://en.wikipedia.org/wiki/Chain_rule) when deriving exponents, so that expressions like `(derive '(^ (^ x y) 3) 'x)` are handled correctly. Enjoy!

## Project 4Ôºö SchemeÔºÅ

### Part I: The Reader

> **Important submission note:** For full credit:
>
> - submit with Part I complete by **Friday 4/6** (worth 1 pt),
> - submit again with Part II complete by **Thursday 4/12** (worth 1 pt), and
> - submit the entire project by **Tuesday 4/17**. You will get an extra credit point for submitting the entire project by Monday 4/16.

> All changes in this part should be made in `scheme_reader.py`.

The first part of this project deals with reading and parsing user input. Our reader will parse Scheme code into Python values with the following representations:

| Input Example  | Scheme Data Type      | Our Internal Representation                                  |
| :------------- | :-------------------- | :----------------------------------------------------------- |
| `scm> 1`       | Numbers               | Python's built-in `int` and `float` values                   |
| `scm> x`       | Symbols               | Python's built-in `string` values                            |
| `scm> #t`      | Booleans (`#t`, `#f`) | Python's built-in `True`, `False` values                     |
| `scm> (+ 2 3)` | Pairs                 | Instances of the `Pair` class, defined in `scheme_reader.py` |
| `scm> nil`     | `nil`                 | The `nil` object, defined in `scheme_reader.py`              |

If you haven't already, make sure to read the [Implementation overview](https://inst.eecs.berkeley.edu/~cs61a/sp18/proj/scheme/#implementation-overview) section above to understand how the reader is broken up into parts.

In our implementation, we store tokens ready to be parsed in `Buffer` instances. For example, a buffer containing the input `(+ (2 . 3))` would have the tokens `'('`, `'+'`, `'('`, `2`, `'.'`, `3`, `')'`, and `')'`. See the doctests in `buffer.py` for more examples. You do not have to understand the code in this file.

You will write the parsing functionality, which consists of two mutually recursive functions `scheme_read` and `read_tail`. These functions each take in a single parameter, `src`, which is an instance of `Buffer`.

There are two methods defined in `buffer.py` that you'll use to interact with `src`:

- `src.remove_front()`: mutates `src` by removing the **first** token in `src` and returns it. For the sake of simplicity, if we imagine `src` as a Python list such as `[4, '.', 3, ')']`, `src.remove_front()` will return `4`, and `src` will be left with `['.', 3, ')']`.
- `src.current()`: returns the **first** token in `src` without removing it. For example, if `src` currently contains the tokens `[4, '.', 3, ')']`, then `src.current()` will return `4` but `src` will remain the same.

#### Problem 1 (2 pt)

First, implement `scheme_read` and `read_tail` so that they can parse list expressions and primitive expressions. We'll take care of dotted pairs in Problem 2. The expected behavior is as follows:

- `scheme_read` removes enough tokens from `src` to form a single expression and returns that expression in the correct internal representation (see above table).
- `read_tail` expects to read the rest of a list or pair, assuming the open parenthesis of that list or pair has already been removed by `scheme_read`. It will read expressions (and thus remove tokens) until the matching closing parenthesis `)` is seen. This list of expressions is returned as nested instances of the `Pair` class.

In short, `scheme_read` returns the next single complete expression in the buffer and `read_tail` returns the rest of a list or pair in the buffer. Both functions mutate the buffer, removing the tokens that have already been processed.

The behavior of both functions depends on the first token currently in `src`. They should be implemented as follows:

`scheme_read`:

- If the current token is the string `"nil"`, return the `nil` object.
- If the current token is `(`, the expression is a pair or list. Call `read_tail` on the rest of `src` and return its result.
- If the current token is `'`, the rest of the buffer should be processed as a quoted expression. You don't have to worry about this until Problem 7.
- If the next token is not a delimiter, then it must be self-evaluating. Return it. **(provided)**
- If none of the above cases apply, raise an error. **(provided)**

`read_tail`:

- If there are no more tokens, then the list is missing a close parenthesis and we should raise an error. **(provided)**
- If the token is `)`, then we've reached the end of the list or pair. Remove this token from the buffer and return the `nil` object.
- If the token is `.`, the current expression is a dotted pair. Implement this in Problem 2.
- If none of the above cases apply, the `src` is at the beginning of an expression. Then:
  1. Read the next complete expression in the buffer. (Hint: Which function can we use to read an complete expression?)
  2. Read the rest of the original expression (i.e. not including the one found in step 1) until the matching closing parenthesis. (Hint: Which function can we use to read the rest of a list?)
  3. Return the results as a `Pair` instance.

Test your understanding and implementation before moving on:

```
python3 ok -q 01 -u
python3 ok -q 01
```

<font color = pink>Âõ†‰∏∫Êúâ3.4ÈáåÈù¢calculatorÁöÑ‰æãÂ≠êÂèÇËÄÉÔºåÊâÄ‰ª•ÂÅöÂá∫Êù•‰πüÂæàÂÆπÊòìÔºåÊòØmutual recursiveÁöÑÂΩ¢ÂºèÔºåÊÑüËßâÂæàÂ¶ô</font>

#### Problem 2 (1 pt)

Now, complete the `read_tail` function by adding support for dotted pairs. To clarify, here is how we define lists vs. dotted pairs:

- A list denotes a linked sequence of pairs in which the `second` attribute of the final pair is `nil`. For example, `(1 2 3)` should be converted to `Pair(1, Pair(2, Pair(3, nil)))`.
- A dotted pair denotes a sequence of pairs in which the `second` attribute of the final pair may be any Scheme value. For example, `(1 2 . 3)` should be converted to `Pair(1, Pair(2, 3))`

In the case of calling `scheme_read` on input "`(1 2 . 3)`", `read_tail` will be called on the suffix "`1 2 . 3)`", which is

- The pair consisting of the Scheme value `1` and the value of the tail "`2 . 3)`", which is
- The pair consisting of the Scheme value `2` and the Scheme value `3`.

Thus, `read_tail` would return `Pair(1, Pair(2, 3))`.

A dotted pair must have exactly one item after the dot; anything else is a syntax error. You should fill in `read_tail` so that if there is only one expression after the dot, return it. ==Otherwise, raise a `SyntaxError` with an appropriate error message. Don't forget to remove the close parenthesis!==

> *Hint*: In order to verify that ==only one element follows a dot==, read the expression after the `'.'` and then check if the next token is a closing parenthesis.

Test your understanding and implementation before moving on:

==‰∏ãÈù¢Ëøô‰∏™Â∞±ÊúâËØ≠Ê≥ïÈîôËØØÔºö==

![image-20220309193938741](C:\Users\cyc\AppData\Roaming\Typora\typora-user-images\image-20220309193938741.png)

<font color = pink>Âç°‰∫ÜÈùûÂ∏∏‰πÖÔºåÊúÄÂêéÊÑèËØÜÂà∞dotÂêéÈù¢Â¶ÇÊûúË∑üÁùÄ‰∏ÄÂØπ(),ÊòØ‰ºöÊää()Ê∂àÊéâÁöÑ„ÄÇ‰πãÂâçDoNero‰πüÊèêÈÜíËøáËøôÈÅìÈ¢òÈùûÂ∏∏tricky„ÄÇÊúÄÂêéÊàêÂäüÁöÑÊÄùË∑ØÊòØÔºådotÂêéÈù¢Â¶ÇÊûúÈÅáÂà∞‰∫ÜÂºÄÊã¨Âè∑ÔºåÈÇ£‰πàdotÂêéÈù¢ÊâÄÊúâÁöÑ‰∏úË•øÈÉΩÂ∫îËØ•ÂåÖÂê´Âú®Ëøô‰∏™Êã¨Âè∑ÈáåÈù¢‰∫ÜÔºå‰∏çËÉΩÊã¨Âè∑ÁªìÊùü‰πãÂêéÂêéÈù¢ËøòÊúâÂà´ÁöÑÂÖÉÁ¥†„ÄÇ</font>

```
python3 ok -q 02 -u
python3 ok -q 02
```

Now that your parser is complete, you should also test it as follows:

- Run the doctests for `scheme_reader.py`

  ```
  python3 -m doctest scheme_reader.py -v
  ```

- Test interactively by running `python3 scheme_reader.py`. Every time you type in a value into the prompt, both the `str` and `repr` values of the parsed expression are printed. You can try the following inputs:

  ```
  read> 42
  str : 42
  repr: 42
  read> nil
  str : ()
  repr: nil
  read> (1 (2 3) (4 (5)))
  str : (1 (2 3) (4 (5)))
  repr: Pair(1, Pair(Pair(2, Pair(3, nil)), Pair(Pair(4, Pair(Pair(5, nil), nil)), nil)))
  read> (1 (9 8) . 7)
  str : (1 (9 8) . 7)
  repr: Pair(1, Pair(Pair(9, Pair(8, nil)), 7))
  read> (hi there . (cs . (student)))
  str : (hi there cs student)
  repr: Pair('hi', Pair('there', Pair('cs', Pair('student', nil))))
  ```

### Part II: The Evaluator

> **Important submission note:** For full credit:
>
> - submit with Part I complete by **Friday 4/6** (worth 1 pt),
> - submit again with Part II complete by **Thursday 4/12** (worth 1 pt), and
> - submit the entire project by **Tuesday 4/17**. You will get an extra credit point for submitting the entire project by Monday 4/16. All changes in this part should be made in `scheme.py`.

In the starter implementation given to you, the evaluator can only evaluate self-evaluating expressions: numbers, booleans, and `nil`.

Read the first two sections of `scheme.py`, called Eval/Apply and Environments.

- `scheme_eval` evaluates a Scheme expression in the given environment. This function is nearly complete but is missing the logic for call expressions.
- When evaluating a special form, `scheme_eval` redirects evaluation to an appropriate `do_XXX_form` function found in the Special Forms section in `scheme.py`.
- `scheme_apply` applies a procedure to some arguments. This function is complete.
- The `.apply` methods in subclasses of `Procedure` and the `make_call_frame` function assist in applying built-in and user-defined procedures.
- The `Frame` class implements an environment frame.
- The `LambdaProcedure` class (in the Procedures section) represents user-defined procedures.

==These are all of the essential components of the interpreter; the rest of `scheme.py` defines special forms and input/output behavior.==

Test your understanding of how these components fit together by unlocking the tests for `eval_apply`.

```
python3 ok -q eval_apply -u
```

==Ëøô‰∫õtestsÂåÖÊã¨Ôºö==

1„ÄÅA Scheme expression can be either  **A primitive expression or a list expression**.

2„ÄÅWhat expression in the body of scheme_eval finds the value of a name?‚Äî‚ÄîÊòØenv.lookup(expr)Âì¶

3„ÄÅ How do we know if a given list expression is a special formÔºü ‚Äî‚Äî **Check if the first element in the list is a symbol and that that symbol is in the dictionary SPECIAL_FORMS**

4„ÄÅ

![image-20220310152335747](C:\Users\cyc\AppData\Roaming\Typora\typora-user-images\image-20220310152335747.png)



### Some Core Functionality

#### Problem 3 (1 pt)

Implement the `define` and `lookup` methods of the `Frame` class. Each `Frame` object has the following instance attributes:

- `bindings` is a dictionary representing the bindings in the frame. It maps Scheme symbols (represented as Python strings) to Scheme values.
- `parent` is the parent `Frame` instance. The parent of the Global Frame is `None`.

`define` takes a symbol (represented by a Python string) and value and binds the value to that symbol in the frame.

`lookup` takes a symbol and returns the value bound to that name in the first `Frame` of the environment in which that name is found. ==Recall that an *environment* is defined as a frame, its parent frame, and all its ancestor frames, including the Global Frame==. Therefore, if the name is not found in the `bindings` dictionary in the current frame and the frame has a parent frame, ==continue lookup== in the parent frame. If the name is not found in the current frame and there is no parent frame, raise a `SchemeError` **(provided)**.

Test your understanding and implementation before moving on:

<font  color = pink>Êå†Â§¥ÔºåËøôÈÅìÈ¢òËøòÊòØÁÆÄÂçïÁöÑ</font>

```
python3 ok -q 03 -u
python3 ok -q 03
```

After you complete this problem, you can open your Scheme interpreter (with `python3 scheme.py`). You should be able to look up built-in procedure names: <font  color = pink>ÂïäÔºå‰∏∫‰ªÄ‰πàÂ∞±ÂèØ‰ª•look upËøô‰∫õprocedure‰∫ÜÂë¢ÔºåÊÑüËßâÂØπÊï¥‰∏™ÁªìÊûÑËøò‰∏çÊòØÂ§™Ê∏ÖÊô∞</font>

```
scm> +
#[+]
scm> odd?
#[odd?]
scm> display
#[display]
```

However, your Scheme interpreter will still not be able to call these procedures. Let's fix that.

#### Problem 4 (1 pt)

To be able to call primitive procedures, such as `+`, you need to complete the `apply` method in the class `PrimitiveProcedure`. ==Primitive procedures are applied by calling a corresponding Python function that implements the procedure. For example, the `+` procedure in Scheme is implemented as the `add` function in Python.==

> To see a list of all Scheme primitive procedures used in the project, look in the `scheme_primitives.py` file. Any function decorated with `@primitive` will be **added to** the globally-defined `PRIMITIVES` list.

A `PrimitiveProcedure` has two instance attributes:

- `fn` is the *Python* function that ==implements== the primitive Scheme procedure.
- `use_env` is ==a Boolean flag== that indicates whether or not this primitive procedure will ==expect the current environment to be passed in as the last argument==. The environment is required, for instance, to implement the primitive `eval` procedure.

The `apply` method of `PrimitiveProcedure` takes a list of argument values and the current environment. Note that `args` is a Scheme list represented as a `Pair` object. Your implementation should do the following:

- Convert the Scheme list to a Python list of arguments. **(provided)**
- If `self.use_env` is `True`, then add the current environment `env` as the last argument to this Python list.
- Call `self.fn` on all of those arguments using `*args` notation. <font color = pink>Ëøô‰∏™Â∏¶ÊòüÂè∑‰º†ÂèÇ‰∏çÂ§™ÊòéÁôΩ</font>
- If calling the function results in a `TypeError` exception being raised, then the wrong number of arguments were passed. Use a `try`/`except` block to intercept the exception and raise an appropriate `SchemeError` in its place.

Test your understanding and implementation before moving on:

```
python3 ok -q 04 -u
python3 ok -q 04
```

#### Problem 5 (1 pt)

`scheme_eval` ==evaluates a Scheme expression in a given environment==. Most of `scheme_eval` has already been implemented for you. It currently looks up names in the current environment, returns self-evaluating expressions (like numbers) and evaluates special forms.

Implement the missing part of `scheme_eval`, ==which evaluates a call expression==. To evaluate a call expression, we do the following:

1. Evaluate the operator (which should evaluate to an instance of `Procedure`)
2. Evaluate all of the operands
3. Apply the procedure on the evaluated operands

You'll have to recursively call `scheme_eval` in the first two steps. Here are some other functions/methods you should use:

- The `check_procedure` function raises an error if the provided argument is not a Scheme procedure. You can use this to ==check that your operator indeed evaluates to a procedure==.
- The `map` method of `Pair` can apply ==a one-argument function== to every item in a Scheme list.
- The `scheme_apply` function applies a Scheme procedure to some arguments.

Test your understanding and implementation before moving on:

```
python3 ok -q 05 -u
python3 ok -q 05
```

<font color = pink>step1 Âç°‰∫ÜÂæà‰πÖÔºåÂõ†‰∏∫Ê≤°ÊÉ≥Âà∞ËøòË¶Åevaluate first„ÄÇÊÑüËßâÊòØÂõ†‰∏∫ÂØπÂÆÉÂ∑≤ÁªèÂÜôÂ•ΩÁöÑÊ°ÜÊû∂‰∏çÂ§™ÁÜüÊÇâ„ÄÇ</font>

Your interpreter should now be able to evaluate primitive procedure calls, giving you the functionality of the Calculator language and more.

```
scm> (+ 1 2)
3
scm> (* 3 4 (- 5 2) 1)
36
scm> (odd? 31)
True
```

**Hint**: A solution to this problem was projected in Lecture 27 ([Video](https://youtu.be/iaXaDcThTp8?t=13m40s); Berkeley login required). You should try to solve the problem yourself, but it's not cheating to use the solution from lecture.

> Now would be a good time to start adding tests to `tests.scm`. For each new problem you complete from now on, add a few tests to the top of `tests.scm` to verify the behavior of your implementation. Remember, these are worth points! See [Problem 0](https://inst.eecs.berkeley.edu/~cs61a/sp18/proj/scheme/#problem-0-2-pt).

#### Problem 6 (1 pt)

Next, we'll implement ==defining variables==. Recall that the `define` special form in Scheme can **be used to define both names and procedures:**

```
scm> (define a 3)  ; Defining a name
a
scm> (define (foo x) x)  ; Defining a procedure
foo
```

The type of the first operand tells us what is being defined:

- If it is a symbol, e.g. `a`, then the expression is defining a name
- If it is a list, e.g. `(foo x)`, then the expression is defining a procedure.

> Read the [Scheme Specifications](https://inst.eecs.berkeley.edu/~cs61a/sp18/articles/scheme-spec.html#define) to understand the behavior of the `define` special form! This problem only provides the behavior for binding expressions, not procedures, to names.

There are two missing parts in the `do_define_form` function, which handles the `(define ...)` special forms. Implement **just the first part**, which binds names to values but does not create new procedures. `do_define_form` should return the name after performing the binding.

```
scm> (define tau (* 2 3.1415926))
tau
```

Test your understanding and implementation before moving on:

==ÈóÆÈ¢òÊòØËøô‰∫õÔºö==

Q: What is the structure of the expressions argument to do_define_form? <font color = pink>Ëøô‰∏™ÁªìÊûÑÁúüÁöÑÂæàÂÖ≥ÈîÆÂì¶„ÄÇ</font>

![image-20220311152325348](C:\Users\cyc\AppData\Roaming\Typora\typora-user-images\image-20220311152325348.png)

Q: What method of a Frame instance will bind a value to a symbol in that frame?

ÊòØdefineËøô‰∏™methodÂìàÔºÅ

![image-20220311153209394](C:\Users\cyc\AppData\Roaming\Typora\typora-user-images\image-20220311153209394.png)

```
python3 ok -q 06 -u
python3 ok -q 06
```

You should now be able to give names to values and evaluate the resulting symbols. Note that `eval` takes a quoted expression and evaluates it (you can think of it as "removing" the quotes):

```scheme
scm> (eval (define tau 6.28))
6.28
scm> (eval 'tau)
6.28
scm> tau
6.28
scm> (define x 15)
x
scm> (define y (* 2 x))
y
scm> y
30
scm> (+ y (* y 2) 1)
91
scm> (define x 20)
x
scm> x
20
```

#### Problem 7 (1 pt)

To complete the core functionality, let's implement **quoting** in our interpreter. In Scheme, you can quote expressions in two ways: with the `quote` special form or with the symbol `'`. Recall that the `quote` special form **returns its operand expression without evaluating it**:

```
scm> (quote hello)
hello
scm> '(cons 1 2)  ; Equivalent to (quote (cons 1 2))
(cons 1 2)
```

> Read the [Scheme Specifications](https://inst.eecs.berkeley.edu/~cs61a/sp18/articles/scheme-spec.html#quote) to understand the behavior of the `quote` special form.

Let's take care of the `quote` special form first. ==Implement the `do_quote_form` function so that it simply returns the unevaluated operand to the special form==.

After completing this function, you should be able to evaluate quoted expressions. Try out some of the following in your interpreter!

```
scm> (quote a)
a
scm> (quote (1 . 2))
(1 . 2)
scm> (quote (1 (2 three . (4 . 5))))
(1 (2 three 4 . 5))
scm> (car (quote (a b)))
a
```

Next, complete your implementation of `scheme_read` in `scheme_reader.py` by handling the `'` case. **First**, notice that `'<expression>` translates to `(quote <expression>)`. That means that we need to wrap the expression following `'` (which you can get by recursively calling `scheme_read`) **into** a quote special form, which, like all special forms, is really just a list.

For example, `'bagel` should be represented as `Pair('quote', Pair('bagel', nil))`.

After completing your `scheme_read` implementation, the following quoted expressions should now work as well.

```
scm> 'hello
hello
scm> '(1 . 2)
(1 . 2)
scm> '(1 (2 three . (4 . 5)))
(1 (2 three 4 . 5))
scm> (car '(a b))
a
scm> (eval (cons 'car '('(1 2))))
1
```

Test your understanding and implementation before moving on:

==Ëøô‰∫õtests‰πüÊòØÂæàËÉΩÂ∏ÆÂä©ÁêÜËß£ÁöÑÔºö==

![image-20220311173041146](C:\Users\cyc\AppData\Roaming\Typora\typora-user-images\image-20220311173041146.png)

‰∏∫‰ªÄ‰πàÊòØ3Âë¢ÔºåÂõ†‰∏∫Âè™ÊúâËøô‰∏ÄÁßçÂèØËÉΩÈ∏≠„ÄÇ(quote hello) Âíå Ôºàquote (1 2)ÔºâÔºåÂú®quote‰πãÂêéÈÉΩÂè™Êúâ‰∏Ä‰∏™PairÂì¶„ÄÇ

scm> ''hello
		Choose the number of the correct choice:

![image-20220311173237603](C:\Users\cyc\AppData\Roaming\Typora\typora-user-images\image-20220311173237603.png)

![image-20220311173458992](C:\Users\cyc\AppData\Roaming\Typora\typora-user-images\image-20220311173458992.png)



```
python3 ok -q 07 -u
python3 ok -q 07
```

At this point in the project, **your Scheme interpreter should support the following features**:

- Evaluate atoms, which include numbers, booleans, nil, and symbols,
- Evaluate the `quote` special form,
- Define symbols, and
- Call primitive procedures, for example evaluating `(+ (- 4 2) 5)`.

### User-Defined Procedures

User-defined procedures are represented as instances of the `LambdaProcedure` class. A `LambdaProcedure` instance has three instance attributes:

- `formals` is a Scheme list of the formal parameters (symbols) that name the arguments of the procedure.
- `body` is a Scheme list of expressions; the body of the procedure.
- `env` is the environment in which the procedure was **defined**.

#### Problem 8 (1 pt)

> Read the [Scheme Specifications](https://inst.eecs.berkeley.edu/~cs61a/sp18/articles/scheme-spec.html#begin) to understand the behavior of the `begin` special form!

Change the `eval_all` function (which is called from `do_begin_form`) to complete the implementation of the `begin` special form. A `begin` expression is evaluated by evaluating all sub-expressions in order. The value of the `begin` expression is the value of the final sub-expression.

```
scm> (begin (+ 2 3) (+ 5 6))
11
scm> (define x (begin (display 3) (newline) (+ 2 3)))
3
x
scm> (+ x 3)
8
scm> (begin (print 3) '(+ 2 3))
3
(+ 2 3)
```

If `eval_all` is passed an empty list of expressions (`nil`), then it should return the Python value `None`, which represents an undefined Scheme value.

Test your understanding and implementation before moving on:

```
python3 ok -q 08 -u
python3 ok -q 08
```

#### Problem 9 (1 pt)

> Read the [Scheme Specifications](https://inst.eecs.berkeley.edu/~cs61a/sp18/articles/scheme-spec.html#lambda) to understand the behavior of the `lambda` special form!

Implement the `do_lambda_form` function, **which creates a `LambdaProcedure` instance**. While you cannot call a user-defined procedure yet, you can verify that you have created the procedure correctly by typing a lambda expression into the interpreter prompt:

```
scm> (lambda (x y) (+ x y))
(lambda (x y) (+ x y))
```

In Scheme, **it is legal to place more than one expression in the body of a procedure (there must be at least one expression)**. The `body` attribute of a `LambdaProcedure` instance is a Scheme list of body expressions.

Test your understanding and implementation before moving on:

==ËøôÈáåÁöÑtestÂè™Êúâ‰∏ÄÈÅìÈ¢òÔºö==

![image-20220312131747580](C:\Users\cyc\AppData\Roaming\Typora\typora-user-images\image-20220312131747580.png)

```
python3 ok -q 09 -u
python3 ok -q 09
```

#### Problem 10 (2 pt)

> Read the [Scheme Specifications](https://inst.eecs.berkeley.edu/~cs61a/sp18/articles/scheme-spec.html#define) to understand the behavior of the `define` special form! In this problem, we'll finish defining the `define` form for procedures.

==Currently, your Scheme interpreter is able to bind symbols to user-defined procedures in the following manner:==

```
scm> (define f (lambda (x) (* x 2)))
f
```

However, we'd like to be able to use **the shorthand form** of defining named procedures:

```
scm> (define (f x) (* x 2))
f
```

Modify the `do_define_form` function so that it correctly handles the shorthand procedure definition form above. **Make sure that it can handle multi-expression bodies.**

Test your understanding and implementation before moving on:

==Â∏ÆÂä©ÁêÜËß£Ôºö==

![image-20220312162434916](C:\Users\cyc\AppData\Roaming\Typora\typora-user-images\image-20220312162434916.png)

```
python3 ok -q 10 -u
python3 ok -q 10
```

You should now find that defined procedures evaluate to `LambdaProcedure` instances.

```
scm> (define (square x) (* x x))
square
scm> square
(lambda (x) (* x x))
```

#### Problem 11 (2 pt)

Implement the `make_child_frame` method of the `Frame` class, which:

- Creates a new `Frame` instance, the parent of which is `self`. **(provided)**
- If the number of argument values does not match with the number of formal parameters, raises a `SchemeError`.
- Binds formal parameters to their corresponding argument values in the newly created frame.

Test your understanding and implementation before moving on:

```
python3 ok -q 11 -u
python3 ok -q 11
```

#### Problem 12 (1 pt)

Implement the `make_call_frame` method in `LambdaProcedure`, which is needed by `scheme_apply`. It should create a new `Frame` instance using the `make_child_frame` method of the appropriate parent frame, binding formal parameters to argument values.

**Since lambdas are lexically scoped, your new frame should be a child of the frame in which the lambda is defined.** The `env` provided as an argument to `make_call_frame` is instead the frame in which the procedure is called, which will be useful when you implement dynamically scoped procedures in problem 16.

Test your understanding and implementation before moving on:

```
python3 ok -q 12 -u
python3 ok -q 12
```

At this point in the project, your Scheme interpreter should support the following features:

- Create procedures using `lambda` expressions,
- Define named procedures using `define` expressions, and
- Call user-defined procedures.

> Now is an excellent time to revisit the tests in `tests.scm` and ensure that you pass the tests that involve definition (Sections 1.1.2 and 1.1.4). To get the 2 points for Problem 0, remember to add a few of your own tests at the top.
>
> To run your tests, run the command:
>
> ```
>   python3 ok -q tests.scm
> ```

### Special Forms

Logical special forms include `if`, `and`, `or`, and `cond`. These expressions are special because **not all of their sub-expressions may be evaluated.**

In Scheme, only `False` is a false value. All other values (including `0` and `nil`) are true values. You can test whether a value is a true or false value using the provided Python functions `scheme_truep` and `scheme_falsep`, defined in `scheme_primitives.py`.

> Note: Scheme traditionally uses `#f` to indicate the false Boolean value. In our interpreter, that is equivalent to `false` or `False`. Similarly, `true`, `True`, and `#t` are all equivalent. However when unlocking tests, use `#t` and `#f`.

To get you started, we've provided an implementation of the `if` special form in the `do_if_form` function. Make sure you understand that implementation before starting the following questions.

#### Problem 13 (2 pt)

> Read the [Scheme Specifications](https://inst.eecs.berkeley.edu/~cs61a/sp18/articles/scheme-spec.html#and) to understand the behavior of the `and` and `or` special forms!

Implement `do_and_form` and `do_or_form` so that `and` and `or` expressions are evaluated correctly.

The logical forms `and` and `or` are *short-circuiting*. For `and`, your interpreter should evaluate each sub-expression from left to right, and if any of these evaluates to a false value, then `#f` is returned. Otherwise, it should return the value of the last sub-expression. If there are no sub-expressions in an `and` expression, it evaluates to `#t`.

```
scm> (and)
#t
scm> (and 4 5 6)  ; all operands are true values
6
scm> (and 4 5 (+ 3 3))
6
scm> (and True False 42 (/ 1 0))  ; short-circuiting behavior of and
#f
```

For `or`, evaluate each sub-expression from left to right. If any sub-expression evaluates to a true value, return that value. Otherwise, return `#f`. If there are no sub-expressions in an `or` expression, it evaluates to `#f`.

```
scm> (or)
#f
scm> (or 5 2 1)  ; 5 is a true value
5
scm> (or False (- 1 1) 1)  ; 0 is a true value in Scheme
0
scm> (or 4 True (/ 1 0))  ; short-circuiting behavior of or
4
```

Test your understanding and implementation before moving on:

```
python3 ok -q 13 -u
python3 ok -q 13
```

#### Problem 14 (2 pt)

> Read the [Scheme Specifications](https://inst.eecs.berkeley.edu/~cs61a/sp18/articles/scheme-spec.html#cond) to understand the behavior of the `cond` special form!

Fill in the missing parts of `do_cond_form` so that it returns the value of the first result sub-expression corresponding to a true predicate, or the result sub-expression corresponding to `else`. **Some special cases:**

- When the true predicate does not have a corresponding result sub-expression, return the predicate value.
- When a result sub-expression of a `cond` case has multiple expressions, evaluate them all and return the value of the last expression. (*Hint*: Use `eval_all`.)

Your implementation should match the following examples and the additional tests in `tests.scm`.

```
scm> (cond ((= 4 3) 'nope)
           ((= 4 4) 'hi)
           (else 'wait))
hi
scm> (cond ((= 4 3) 'wat)
           ((= 4 4))
           (else 'hm))
True
scm> (cond ((= 4 4) 'here (+ 40 2))
           (else 'wat 0))
42
```

The value of a `cond` is undefined if there are no true predicates and no `else`. In such a case, `do_cond_form` should return `None`.

```
scm> (cond (False 1) (False 2))
scm>
```

Test your understanding and implementation before moving on:

```
python3 ok -q 14 -u
python3 ok -q 14
```

#### Problem 15 (2 pt)

> Read the [Scheme Specifications](https://inst.eecs.berkeley.edu/~cs61a/sp18/articles/scheme-spec.html#let) to understand the behavior of the `let` special form!

The `let` special form **binds symbols to values locally**, giving them their initial values. For example:

```
scm> (define x 5)
x
scm> (define y 'bye)
y
scm> (let ((x 42)
           (y (* x 10)))  ; x refers to the global value of x, not 42
       (list x y))
(42 50)
scm> (list x y)
(5 bye)
```

Implement `make_let_frame`, which returns a child frame of `env` that binds the symbol in each element of `bindings` to the value of its corresponding expression. The `bindings` scheme list contains pairs that each contain a symbol and a corresponding expression.

You may find the following functions and methods useful:

- `check_form`: this function can be used to check the structure of each binding.
- `check_formals`: this function checks that formal parameters are a Scheme list of symbols for which each symbol is distinct.
- `make_child_frame`: this method (which you implemented in [Problem 11](https://inst.eecs.berkeley.edu/~cs61a/sp18/proj/scheme/#problem-11)) takes a `Pair` of formal parameters (symbols) and a `Pair` of values, and returns a new frame with all the symbols bound to the corresponding values.

Test your understanding and implementation before moving on:

```
python3 ok -q 15 -u
python3 ok -q 15
```

#### Problem 16 (1 pt)

> Read the [Scheme Specifications](https://inst.eecs.berkeley.edu/~cs61a/sp18/articles/scheme-spec.html#mu) to understand the behavior of the `mu` special form!

Implement `do_mu_form` to evaluate the `mu` special form, a non-standard Scheme expression type. A `mu` expression is similar to a `lambda` expression, but evaluates to a `MuProcedure` instance that is **dynamically scoped**. Most of the `MuProcedure` class has been provided for you.

Complete the `MuProcedure` class so that when a call on such a procedure is executed, it is dynamically scoped. Calling a `LambdaProcedure` uses lexical scoping: the parent of the new call frame is the environment in which the procedure was **defined**. Calling a `MuProcedure` created by a `mu` expression uses dynamic scoping: the parent of the new call frame is the environment in which the call expression was **evaluated**. ==As a result, a `MuProcedure` does not need to store an environment as an instance attribute.== It can **refer to names** in the environment from which it was called.

```
scm> (define f (mu (x) (+ x y)))
f
scm> (define g (lambda (x y) (f (+ x x))))
g
scm> (g 3 7)
13
```

Looking at `LambdaProcedure` should give you a clue about what needs to be done to `MuProcedure` to complete it. Test your understanding and implementation before moving on:

```
python3 ok -q 16 -u
python3 ok -q 16
```

Congratulations! Your Scheme interpreter implementation is now complete!

> The autograder tests for the interpreter are *not* comprehensive, so you may have uncaught bugs in your implementation. You should have been adding tests to the top of `tests.scm` as you did each problem, which will help you discover bugs on your own. **Writing these tests is worth [2 points](https://inst.eecs.berkeley.edu/~cs61a/sp18/proj/scheme/#part-0-testing-your-interpreter) of the project.**
>
> To run your tests, run the command:
>
> ```
>   python3 ok -q tests.scm
> ```
>
> Make sure to remove all of the `(exit)` commands, so that all the tests are run! We've provided 115 tests (not counting the extra credit tests), so if you don't see at least that many tests passed, you haven't removed all the `(exit)` commands. (Of course, you should have many more than that, since you've been writing your own as well.)

One you have completed Part II, make sure you submit using OK to receive full credit for the second checkpoint.

```
python3 ok --submit
```

## Part III: Write Some Scheme

> Not only is your Scheme interpreter itself a tree-recursive programÔºà==ÊàëÁöÑScheme interpreter‰∏∫‰ªÄ‰πàÊòØtree-recursiveÁöÑÔºüÔºüÔºüÔºü==Ôºâ, but it is flexible enough to evaluate *other* recursive programs. Implement the following procedures in Scheme in the `questions.scm` file.
>
> In addition, for this part of the project, you may find the [primitive procedure reference](https://inst.eecs.berkeley.edu/~cs61a/sp18/proj/scheme/) very helpful if you ever have a question about the behavior of a built-in Scheme procedure, like the difference between `pair?` and `list?`.

The autograder tests for the interpreter are *not* comprehensive, so you may have uncaught bugs in your implementation. Therefore, you may find it useful to test your code for these questions in the staff interpreter or the [web interpreter](http://scheme.cs61a.org/editor.html) and then try it in your own interpreter once you are confident your Scheme code is working.

### Problem 17 (1 pt)

Implement the `enumerate` procedure, which takes in a list of values and returns a list of two-element lists, where the first element is the index of the value, and the second element is the value itself.

```
scm> (enumerate '(3 4 5 6))
((0 3) (1 4) (2 5) (3 6))
scm> (enumerate '())
()
		
```

Test your implementation before moving on:

```
python3 ok -q 17
```

<font color = pink>ÂÖ∂ÂÆûÊòØÂæàÁÆÄÂçïÁöÑ‰∏ÄÈÅìÈ¢òÁõÆÔºåÁî®‰∏Ä‰∏™helper ÂáΩÊï∞~ ‰∏çË¶ÅÂÆ≥ÊÄïÔºåÂ§öÂÅöÂÅöÔºåÁî®ËÑëÂ≠êÊÉ≥‰∏ÄÊÉ≥</font>

### Problem 18 (2 pt) ‚≠ê‚≠ê‚≠ê

Implement the `list-change` procedure, which lists all of the ways to make change for a positive integer `total` amount of money, using a list of currency denominations, which is sorted in descending order. The resulting list of ways of making change should also be returned in descending order.

To make change for 10 with the denominations (25, 10, 5, 1), we get the possibliites:

<font color = pink>ÊÄùË∑ØËøòÊòØ‰∏ÄÊ†∑ÁöÑÔºåÁî®Á¨¨‰∏Ä‰∏™ & ‰∏çÁî®Á¨¨‰∏Ä‰∏™</font>„ÄÇPythonÂèØ‰ª•ËøôÊ†∑ÂÜô„ÄÇ

```python
def make_change(total, amount, list):
    if total < 0:
        return
    if total == 0:
        print(list)
        return
    if amount is None or len(amount) == 0:
        return

    make_change(total, amount[1:], list[:])
    make_change(total - amount[0], amount, list[:]+[amount[0]])


make_change(25, [10, 5, 1], [])
        
def change(total, amount):
    all_list = []
    
    def make_change(total, amount, list):
    	if total < 0:
        	return
    	if total == 0:
        	print(list)
        	all_list.append(list)
        	return
    	if amount is None or len(amount) == 0:
        	return

    	make_change(total, amount[1:], list[:])
    	make_change(total - amount[0], amount, list[:]+[amount[0]])
    
    make_change(total, amount, [])
    return all_list

```



```
10
5, 5
5, 1, 1, 1, 1, 1
1, 1, 1, 1, 1, 1, 1, 1, 1, 1
```

To make change for 5 with the denominations (4, 3, 2, 1), we get the possibilities:

```
4, 1
3, 2
3, 1, 1
2, 2, 1
2, 1, 1, 1
1, 1, 1, 1, 1
```

You may find that implementing a helper function, `cons-all`, will be useful for this problem. To implement `cons-all`, use the [built-in map procedure](https://inst.eecs.berkeley.edu/~cs61a/sp18/articles/scheme-primitives.html#map). `cons-all` takes in an element `first` and a list of lists `rests`, and adds `first` to the beginning of each list in `rests`:

```
scm> (cons-all 1 '((2 3) (2 4) (3 5)))
((1 2 3) (1 2 4) (1 3 5))
```

You may also find the built-in [append procedure](https://inst.eecs.berkeley.edu/~cs61a/sp18/articles/scheme-primitives.html#append) useful.

Test your implementation before moving on:

```
python3 ok -q 18
```

<font color = pink>ËôΩÁÑ∂PythonÁöÑÂÅöÊ≥ïÂæàÂø´Â∞±ÊáÇ‰∫ÜÔºå‰ΩÜÊòØSchemeÂÜô‰∫ÜÂø´‰∏ÄÊôö‰∏ä„ÄÇÈ¶ñÂÖàÂØπSchemeÁöÑËØ≠Ê≥ï‰∏çÂ§™ÁÜüÊÇâÔºåif/cond, Â¶ÇÊûúË¶Åreturn‰∏çË¶ÅÊâßË°åÂâ©‰∏ãÁöÑbodyÂ∫îËØ•ÊÄé‰πàÂÅöÔºõÁÑ∂ÂêéÂ∞±ÊòØÈÄíÂΩíÈáåÈù¢base caseÁöÑÈóÆÈ¢òÔºåÊúÄÂêéÂèëÁé∞ÊòØÂõ†‰∏∫cons-all Ëøô‰∏™utilityÂáΩÊï∞ÂÜôÂæóÊúâÈóÆÈ¢ò„ÄÇ</font>

### Problem 19 (2 pt) ÔºàÊú™ÂÆåÔºâ

In Scheme, **source code is data. Every non-primitive expression is written as a Scheme list**, so ==we can write procedures that manipulate other programs just as we write procedures that manipulate lists==.

**Rewriting programs can be useful:** we can write an interpreter that only handles a small core of the language, ==and then write a procedure that converts other special forms into the core language before a program is passed to the interpreter==.

For example, the `let` special form is equivalent to a call expression that begins with a `lambda` expression. Both create a new frame extending the current environment and evaluate a body within that new environment. Feel free to revisit [Problem 15](https://inst.eecs.berkeley.edu/~cs61a/sp18/proj/scheme/#problem-15-2-pt) as a refresher on how the `let` form works.

```
(let ((a 1) (b 2)) (+ a b))
;; Is equivalent to:
((lambda (a b) (+ a b)) 1 2)
```

These expressions can be represented by the following diagrams:

| Let                                                          | Lambda                                                       |
| :----------------------------------------------------------- | :----------------------------------------------------------- |
| ![let](https://inst.eecs.berkeley.edu/~cs61a/sp18/proj/scheme/images/let.png) | ![lambda](https://inst.eecs.berkeley.edu/~cs61a/sp18/proj/scheme/images/lambda.png) |

Use this rule to implement a procedure called `let-to-lambda` that ==rewrites== all `let` special forms into `lambda` expressions. If we quote a `let` expression and pass it into this procedure, an equivalent `lambda` expression should be returned: pass it into this procedure:

```
scm> (let-to-lambda '(let ((a 1) (b 2)) (+ a b)))
((lambda (a b) (+ a b)) 1 2)
scm> (let-to-lambda '(let ((a 1)) (let ((b a)) b)))
((lambda (a) ((lambda (b) b) a)) 1)
```

In order to handle all programs, ==`let-to-lambda` must be aware of Scheme syntax. Since Scheme expressions are recursively nested, `let-to-lambda` must also be recursive==. In fact, the structure of `let-to-lambda` is somewhat similar to that of `scheme_eval`--but in Scheme! As a reminder, atoms include numbers, booleans, nil, and symbols.

```
(define (let-to-lambda expr)
  (cond ((atom?   expr) <rewrite atoms>)
        ((quoted? expr) <rewrite quoted expressions>)
        ((lambda? expr) <rewrite lambda expressions>)
        ((define? expr) <rewrite define expressions>)
        ((let?    expr) <rewrite let expressions>)
        (else           <rewrite other expressions>)))
```

> *Hint*: You may want to implement `zip` at the top of `questions.scm` and also use the built-in `map` procedure.
>
> ```
> scm> (zip '((1 2) (3 4) (5 6)))
> ((1 3 5) (2 4 6))
> scm> (zip '((1 2)))
> ((1) (2))
> scm> (zip '())
> (() ())
> ```

Test your understanding and implementation before moving on:

```
python3 ok -q 19 -u
python3 ok -q 19
```

> *Note*: We used `let` while defining `let-to-lambda`. What if we want to run `let-to-lambda` on an interpreter that does not recognize `let`? We can pass `let-to-lambda` to itself to rewrite itself into an *equivalent program without* `let`:
>
> ```
> ;; The let-to-lambda procedure
> (define (let-to-lambda expr)
>   ...)
> 
> ;; A list representing the let-to-lambda procedure
> (define let-to-lambda-code
>   '(define (let-to-lambda expr)
>      ...))
> 
> ;; An let-to-lambda procedure that does not use 'let'!
> (define let-to-lambda-without-let
>   (let-to-lambda let-to-lambda-code))
> ```

## Part IV: Extra Credit

> *Note:* During regular Office Hours and Project Parties, the staff will prioritize helping students with required questions. We will not be offering help with either extra credit problems unless the [queue](https://oh.cs61a.org/) is empty.

### Problem 20 (2 pt) ÔºàÊú™ÂÆåÔºâ

Complete the function `optimize_tail_calls` in `scheme.py`. **It returns an alternative to `scheme_eval` that is properly tail recursive.** That is, the interpreter will allow an unbounded number of active [tail calls](http://en.wikipedia.org/wiki/Tail_call) in constant space.

The `Thunk` class represents a [thunk](http://en.wikipedia.org/wiki/Thunk), an expression that needs to be evaluated in an environment. When `scheme_optimized_eval` receives a non-atomic expression in a `tail` context, then it returns an `Thunk` instance. Otherwise, it should repeatedly call `original_scheme_eval` until the result is a value, rather than a `Thunk`. 

**A successful implementation will require changes to several other functions, including some functions that we provided for you.** All expressions throughout your interpreter that are in a tail context should be evaluated by calling `scheme_eval` with `True` as a third argument. Your goal is to determine which expressions are in a tail context throughout your code.

Once you finish, uncomment the following line in `scheme.py` to use your implementation:

```
scheme_eval = optimize_tail_calls(scheme_eval)
```

Test your implementation before moving on:

```
python3 ok -q 20
```

### Problem 21 (1 pt) ÔºàÊú™ÂÆåÔºâ

Macros allow the language itself to be extended by the user. Simple macros can be provided with the `define-macro` special form. This must be used like a procedure definition, and it creates a procedure just like `define`. However, this procedure has a special evaluation rule: it is applied to its arguments without first evaluating them. Then the result of this application is evaluated.

This final evaluation step takes place in the caller's frame, as if the return value from the macro was literally pasted into the code in place of the macro.

Here is a simple example:

```scheme
scm> (define (map f lst) (if (null? lst) nil (cons (f (car lst)) (map f (cdr lst)))))
scm> (define-macro (for formal iterable body)
....     (list 'map (list 'lambda (list formal) body) iterable))
scm> (for i '(1 2 3)
....     (print (* i i)))
1
4
9
(None None None)
```

The code above defines a macro `for` that acts as a `map` except that it doesn't need a lambda around the body.

In order to implement `define-macro`, implement complete the implementation for `do_define_macro`, which should create a `MacroProcedure` and bind it to the given name as in `do_define_form`. Then, update `scheme_eval` so that calls to macro procedures are evaluated correctly.

*Hint*: Use the `apply_macro` method in the `MacroProcedure` class to apply a *macro to the operands in its call expression. This procedure is written to* interact well with tail call optimization.

Test your implementation before moving on:

```
python3 ok -q 21
```

### Conclusion

**Congratulations!** You have just implemented an interpreter for an entire language! We've implemented a significant subset of Scheme in this project, but your interpreter can be extended with even more features! If you enjoyed this project, we have some suggestions in the [extension instructions](https://inst.eecs.berkeley.edu/~cs61a/sp18/proj/scheme/extensions.html).

## Lab 10: Interpreters

### Topics

Consult this section if you need a refresher on the material for this lab. It's okay to skip directly to [the questions](https://inst.eecs.berkeley.edu//~cs61a/sp18/lab/lab10/#required-questions) and refer back here should you get stuck.

#### Interpreters

**An interpreter is a program that allows you to interact with the computer in a certain language.** It understands the expressions that you type in through that language, and performs the corresponding actions in some way, usually using an underlying language.

In Project 4, you will use Python to implement an interpreter for Scheme. **The Python interpreter that you've been using all semester is written (mostly) in the C programming language.** **The computer itself uses hardware to interpret machine code (a series of ones and zeros that represent basic operations like adding numbers, loading information from memory, etc).**

When you talk about an interpreter, there are two languages at work:

1. **The language being interpreted/implemented.** In this lab, you will implement the PyCombinator language.
2. **The underlying implementation language.** In this lab, you will use Python to implement the PyCombinator language.

==Note that the underlying language need not be different from the implemented language. In fact, in this lab we are going to implement a smaller version of Python (PyCombinator) using Python! This idea is called Metacircular Evaluation.==<font color = pink>meta-circular, ÂÖÉÂæ™ÁéØ„ÄÇ‰∏∫‰ªÄ‰πàË¶ÅËøôÊ†∑ÂÅöÂë¢Ôºü</font>

Many interpreters use a Read-Eval-Print Loop (**REPL**). This loop waits for user input, and then processes it in three steps:

- **Read:** The interpreter takes the user input (a string) and passes it through a lexerÔºàËØçÊ≥ïÂàÜÊûêÁ®ãÂ∫èÔºâ and parserÔºàËØ≠Ê≥ïÂâñÊûêÁ®ãÂ∫èÔºâ.
  - The *lexer* turns the user input string into atomic pieces (tokens) that are like "words" of the implemented language.
  - The *parser* takes the tokens and organizes them into data structures that the underlying language can understand.
- **Eval:** Mutual recursion between eval and apply evaluate the expression to obtain a value.
  - *Eval* takes an expression and evaluates it according to the rules of the language. Evaluating a call expression involves calling `apply` to apply an evaluated operator to its evaluated operands.
  - *Apply* takes an evaluated operator, i.e., a function, and applies it to the call expression's arguments. Apply may call `eval` to do more work in the body of the function, so `eval` and `apply` are ==*mutually recursive*==.
- **Print:** Display the result of evaluating the user input.

Here's how all the pieces fit together:

```
         +-------------------------------- Loop -----------+
         |                                                 |
         |  +-------+   +--------+   +-------+   +-------+ |
Input ---+->| Lexer |-->| Parser |-->| Eval  |-->| Print |-+--> Output
         |  +-------+   +--------+   +-------+   +-------+ |
         |                              ^  |               |
         |                              |  v               |
         ^                           +-------+             v
         |                           | Apply |             |
         |    REPL                   +-------+             |
         +-------------------------------------------------+
```

#### PyCombinator Interpreter

Today we will build **PyCombinator**, our own basic Python interpreter. By the end of this lab, you will be able to use a bunch of primitives such as `add`, `mul`, and `sub` (you can see the entire list at the bottom of `expr.py`), and even more excitingly, we will be able to create and call lambda functions -- all through your own homemade interpreter!

You will implement some of the key parts that will allow us to evaluate the following commands and more:

```
> add(3, 4)
7
> mul(4, 5)
20
> sub(2, 3)
-1
> (lambda: 4)()
4
> (lambda x, y: add(y, x))(3, 5)
8
> (lambda x: lambda y: mul(x, y))(3)(4)
12
> (lambda f: f(0))(lambda x: pow(2, x))
1
```

You can find the Read-Eval-Print Loop code for our interpreter in `repl.py`. Here is an overview of each of the REPL components:

- **Read:** The function `read` in `reader.py` calls the following two functions to parse user input.
  - The *lexer* is the function `tokenize` in `reader.py` which splits the user input string into tokens.
  - The *parser* is the function `read_expr` in `reader.py` which parses the tokens and turns expressions into instances of subclasses of the class `Expr` in `expr.py`, e.g. `CallExpr`.
- **Eval:** Expressions (represented as `Expr` objects) are evaluated to obtain values (represented as `Value` objects, also in `expr.py`).
  - *Eval*: Each type of expression has its own `eval` method which is called to evaluate it.
  - *Apply*: Call expressions are evaluated by calling the operator's `apply` method on the arguments. For lambda procedures, `apply` calls `eval` to evaluate the body of the function.
- **Print:** The `__str__` representation of the obtained value is printed.

In this lab, **you will only be implementing the *Eval* and *Apply* steps in `expr.py`.**

You can start the PyCombinator interpreter by running the following command:

```
python3 repl.py
```

Try entering a literal (e.g. `4`) or a lambda expression, (e.g. `lambda x, y: x + y`) to see what they evaluate to. Right now, any names (e.g. `add`) and call expressions (e.g. `add(2, 3)`) will output `None`. It's your job to implement `Name.eval` and `CallExpr.eval` so that **we can look up names and call functions in our interpreter!**

If you want a better idea of how user input is read and transformed into Python code, you can use the `--read` flag when running the interpreter:

```
$ python3 repl.py --read
> lambda x: mul(x, x)
LambdaExpr(['x'], CallExpr(Name('mul'), [Name('x'), Name('x')]))
> lambda f: f(0)
LambdaExpr(['f'], CallExpr(Name('f'), [Literal(0)]))
```

To exit the interpreter, type Ctrl-C or Ctrl-D.

### Required Questions

#### Q1: Prologue

Before we write any code, let's try to understand the parts of the interpreter that are already written.

Here is the breakdown of our implementation:

- `repl.py` contains the logic for the REPL loop, which repeatedly reads expressions as user input, evaluates them, and prints out their values (you don't have to completely understand all the code in this file).
- `reader.py` contains our interpreter's reader. The function `read` calls the functions `tokenize` and `read_expr` to turn an expression string into an `Expr` object (you don't have to completely understand all the code in this file).
- `expr.py` contains our interpreter's representation of expressions and values. The subclasses of `Expr` and `Value` ==encapsulate== all the types of expressions and values in the PyCombinator language. The global environment, a dictionary containing the bindings for primitive functions, is also defined at the bottom of this file.

> Use Ok to test your understanding of the reader. It will be helpful to refer to `reader.py` to answer these questions.
>
> ```
> python3 ok -q prologue_reader -u
> ```
>
> Use Ok to test your understanding of the `Expr` and `Value` objects. It will be helpful to refer to `expr.py` to answer these questions.
>
> ```
> python3 ok -q prologue_expr -u
> ```

==testsÔºö==

![image-20220311194551930](C:\Users\cyc\AppData\Roaming\Typora\typora-user-images\image-20220311194551930.png)

What does the tokenize function in reader.py return? ‚Äî‚Äî ==Input expression represented as a list of tokens==

![image-20220311194800503](C:\Users\cyc\AppData\Roaming\Typora\typora-user-images\image-20220311194800503.png)

![image-20220311195951975](C:\Users\cyc\AppData\Roaming\Typora\typora-user-images\image-20220311195951975.png)



![image-20220311200058302](C:\Users\cyc\AppData\Roaming\Typora\typora-user-images\image-20220311200058302.png)

![image-20220311200210557](C:\Users\cyc\AppData\Roaming\Typora\typora-user-images\image-20220311200210557.png)

![image-20220311204715842](C:\Users\cyc\AppData\Roaming\Typora\typora-user-images\image-20220311204715842.png)

==Á≠îÊ°àÂ∫îËØ•ÊòØ0ÂìàÔºÅÔºÅ==

Êù•Ê¢≥ÁêÜ‰∏Ä‰∏ãÁé∞ÊúâÁöÑÊ°ÜÊû∂ÔºåÈ¶ñÂÖàÊàëÊúâ4ÁßçexpressionÔºå3ÁßçvalueÔºåÊàëËÉΩÂ§üread inÁî®Êà∑ÁöÑËæìÂÖ•ÔºåÊúÄÂêéË¶ÅÊ†πÊçÆ‰∏çÂêåÁßçÁ±ªÁöÑËæìÂÖ•Êù•evaluateÔºåÂ§ßÊ¶ÇÊòØËøôÊ†∑Âêß„ÄÇ‰ΩÜÊòØÁªÜËäÇ‰∏äÁúãÂæóËøò‰∏çÂ§™‰ªîÁªÜ„ÄÇ

#### Q2: Evaluating Names

The first type of PyCombinator expression that we want to evaluate are names. In our program, a name is an instance of the `Name` class. Each instance has a `string` attribute which is the name of the variable -- e.g. `"x"`.

**Recall that the value of a name depends on the current environment.** In our implementation, an environment is represented by a dictionary that maps variable names (strings) to their values (instances of the `Value` class).

The method `Name.eval` takes in the current environment as the parameter `env` and returns the value bound to the `Name`'s `string` in this environment. Implement it as follows:

- If the name exists in the current environment, look it up and return the value it is bound to.

- If the name does not exist in the current environment, raise a `NameError` with an appropriate error message:ÔºàÂõ†‰∏∫Ëøô‰∏™labÈáåÈù¢Ë¶ÅÂÆûÁé∞ÁöÑÂè™Â±ÄÈôê‰∫éprimitive functionÔºåÈÉΩÊòØÂÜôÂú®global frameÈáåÁöÑÔºåÊâÄ‰ª•‰∏çÂÜçÈúÄË¶ÅÂéªparentÈáåÈù¢Êâæ‰∫ÜÔºåÂ∫îËØ•ÊòØËøôÊ†∑ÁöÑ„ÄÇÔºâ

  ```
  raise NameError('your error message here (a string)')
  ```

```python
def eval(self, env):
    """
    >>> env = {
    ...     'a': Number(1),
    ...     'b': LambdaFunction([], Literal(0), {})
    ... }
    >>> Name('a').eval(env)
    Number(1)
    >>> Name('b').eval(env)
    LambdaFunction([], Literal(0), {})
    >>> try:
    ...     print(Name('c').eval(env))
    ... except NameError:
    ...     print('Exception raised!')
    Exception raised!
    """
    "*** YOUR CODE HERE ***"
    if self.string in env:
        return env[self.string]
    raise NameError("Exception raised!")
```

Use Ok to test your code:

```
python3 ok -q Name.eval
```

Now that you have implemented the evaluation of names, you can look up names in the global environment like `add` and `sub` (see the full list of primitive math operators in `global_env` at the bottom of `expr.py`). You can also try looking up undefined names to see how the `NameError` is displayed!

```
$ python3 repl.py
> add
<primitive function add>
```

Unfortunately, you still cannot call these functions. We'll fix that next!

#### Q3: Evaluating Call Expressions

Now, let's add logic for **evaluating call expressions**, such as `add(2, 3)`. Remember that a call expression consists of an operator and 0 or more operands.

In our implementation, **a call expression is represented as a `CallExpr` instance**. Each instance of the `CallExpr` class has the attributes `operator` and `operands`. `operator` is an instance of `Expr`, and, since a call expression can have multiple operands, `operands` is a *list* of `Expr` instances.

For example, in the `CallExpr` instance representing `add(3, 4)`:

- `self.operator` would be `Name('add')`
- `self.operands` would be the list `[Literal(3), Literal(4)]`

In `CallExpr.eval`, **implement the three steps to evaluate a call expression:**

1. Evaluate the *operator* in the current environment.
2. Evaluate the *operand(s)* in the current environment.
3. Apply the value of the operator, a function, to the value(s) of the operand(s).

> **Hint:** Since the operator and operands are all instances of `Expr`, ==you can evaluate them by calling their `eval` methods==. Also, you can apply a function (an instance of `PrimitiveFunction` or `LambdaFunction`) by calling its `apply` method, which takes in a list of arguments (`Value` instances).

```python
def eval(self, env):
    """
    >>> from reader import read
    >>> new_env = global_env.copy()
    >>> new_env.update({'a': Number(1), 'b': Number(2)})
    >>> add = CallExpr(Name('add'), [Literal(3), Name('a')])
    >>> add.eval(new_env)
    Number(4)
    >>> new_env['a'] = Number(5)
    >>> add.eval(new_env)
    Number(8)
    >>> read('max(b, a, 4, -1)').eval(new_env)
    Number(5)
    >>> read('add(mul(3, 4), b)').eval(new_env)
    Number(14)
    """
    "*** YOUR CODE HERE ***"
    opt = self.operator.eval(env)
    opas = [opa.eval(env) for opa in self.operands]
    return opt.apply(opas)    
```

Use Ok to test your code:

```
python3 ok -q CallExpr.eval
```

Now that you have implemented the evaluation of call expressions, we can use our interpreter for simple expressions like `sub(3, 4)` and `add(mul(4, 5), 4)`. Open your interpreter to do some cool math:

```
$ python3 repl.py
```

### Optional Questions

#### Q4: Applying Lambda Functions

We can do some basic math now, but it would be a bit more fun if we could also call our own user-defined functions. So let's make sure that we can do that!

A lambda function is represented as an instance of the `LambdaFunction` class. If you look in `LambdaFunction.__init__`, you will see that each lambda function has three instance attributes: `parameters`, `body` and `parent`. **As an example, consider the lambda function `lambda f, x: f(x)`. For the corresponding `LambdaFunction` instance, we would have the following attributes:**

- `parameters` -- a list of strings, e.g. `['f', 'x']`
- `body` -- an `Expr`, e.g. `CallExpr(Name('f'), [Name('x')])`
- `parent` -- **the parent environment in which we want to look up our variables**. **Notice that this is the environment the lambda function was defined in**. `LambdaFunction`s are created in the `LambdaExpr.eval` method, and the current environment then becomes this `LambdaFunction`'s parent environment.

If you try entering a lambda expression into your interpreter now, you should see that it outputs a lambda function. However, if you try to call a lambda function, e.g. `(lambda x: x)(3)` it will output `None`.

You are now going to implement the `LambdaFunction.apply` method so that we can call our lambda functions! This function takes a list `arguments` which contains the argument `Value`s that are passed to the function. When evaluating the lambda function, **you will want to make sure that the lambda function's formal parameters are correctly bound to the arguments it is passed.** To do this, you will have to modify the environment you evaluate the function body in.

There are three steps to applying a `LambdaFunction`:

1. Make a copy of the parent environment. You can make a copy of a dictionary `d` with `d.copy()`. 
2. Update the copy with the `parameters` of the `LambdaFunction` and the `arguments` passed into the method.
3. Evaluate the `body` using the newly created environment.

```python
def apply(self, arguments):
    """
    >>> from reader import read
    >>> add_lambda = read('lambda x, y: add(x, y)').eval(global_env)
    >>> add_lambda.apply([Number(1), Number(2)])
    Number(3)
    >>> add_lambda.apply([Number(3), Number(4)])
    Number(7)
    >>> sub_lambda = read('lambda add: sub(10, add)').eval(global_env)
    >>> sub_lambda.apply([Number(8)])
    Number(2)
    >>> add_lambda.apply([Number(8), Number(10)]) # Make sure you made a copy of env
    Number(18)
    >>> read('(lambda x: lambda y: add(x, y))(3)(4)').eval(global_env)
    Number(7)
    >>> read('(lambda x: x(x))(lambda y: 4)').eval(global_env)
    Number(4)
    """
    if len(self.parameters) != len(arguments):
        raise TypeError("Cannot match parameters {} to arguments {}".format(
            comma_separated(self.parameters), comma_separated(arguments)))
    "*** YOUR CODE HERE ***"
    new_env = self.parent.copy()
    for i in range(len(arguments)):
        new_env[self.parameters[i]] = arguments[i]
    return self.body.eval(new_env)
```

Use Ok to test your code:

```
python3 ok -q LambdaFunction.apply
```

After you finish, you should try out your new feature! Open your interpreter and try creating and calling your own lambda functions. Since functions are values in our interpreter, you can have some fun with higher order functions, too!

```
$ python3 repl.py
> (lambda x: add(x, 3))(1)
4
> (lambda f, x: f(f(x)))(lambda y: mul(y, 2), 3)
12
```

#### Q5: Handling Exceptions

The interpreter we have so far is pretty cool. It seems to be working, right? Actually, there is one case we haven't covered. Can you think of a very simple calculation that is undefined (maybe involving division)? Try to see what happens if you try to compute it using your interpreter. It's pretty ugly, right? We get a long error message and **exit our interpreter** -- but really, we want to handle this elegantly. ÂìàÂìàÔºåelegantlyÔºåÂ•ΩÂì¶ÔºåÂãáÊï¢Â§ßPieÔºåÂñúÊ¨¢coding„ÄÇ

Try opening up the interpreter again and see what happens if you do something ill defined like `add(3, x)`. We just get a nice error message saying that `x` is not defined, and we can then continue using our interpreter. ==This is because our code handles the `NameError` exception, preventing it from crashing our program==. Let's talk about how to handle exceptions:

In lecture, you learned how to raise exceptions. But it's also important to ==catch exceptions== when necessary. Instead of letting the exception propagate back to the user and crash the program, we can catch it using a `try/except` block and allow the program to continue.

```
try:
    <try suite>
except <ExceptionType 0> as e:
    <except suite 0>
except <ExceptionType 1> as e:
    <except suite 1>
...
```

We put the code that might raise an exception in the `<try suite>`. If an exception is raised, then the program will look at what type of exception was raised and look for a corresponding `<except suite>`. You can have as many except suites as you want.

```
try:
    1 + 'hello'
except NameError as e:
    print('hi')  # NameError except suite
except TypeError as e:
    print('bye') # TypeError except suite
```

In the example above, adding `1` and `'hello'` will raise a `TypeError`. Python will look for an except suite that handles `TypeError`s -- the second except suite. Generally, we want to specify exactly which exceptions we want to handle, such as `OverflowError` or `ZeroDivisionError` (or both!), rather than handling all exceptions.

Notice that we can define the exception `as e`. This assigns the exception object to the variable `e`. This can be helpful when we want to use information about the exception that was raised.

```
>>> try:
...     x = int("cs61a rocks!")
... except ValueError as e:
...     print('Oops! That was no valid number.')
...     print('Error message:', e)
```

You can see how we handle exceptions in your interpreter in `repl.py`. This might also be a really good place to handle the exception you triggered with your ill-defined arithmetic. Go ahead and try it out!

## hw 10

#### Q1: Accumulate

Fill in the definition for the procedure `accumulate`, which combines the first `n` natural numbers according to the following parameters:

1. `combiner`: a function of two arguments
2. `start`: a number with which to start combining
3. `n`: the number of natural numbers to combine
4. `term`: a function of one argument that computes the *n*th term of a sequence

For example, we can find the product of all the numbers from 1 to 5 by using the multiplication operator as the `combiner`, and starting our product at 1:

```
scm> (define (identity x) x)
scm> (accumulate * 1 5 identity)  ; 1 * 1 * 2 * 3 * 4 * 5
120
```

We can also find the sum of the squares of the same numbers by using the addition operator as the `combiner` and `square` as the `term`:

```scheme
scm> (define (square x) (* x x))
scm> (accumulate + 0 5 square)  ; 0 + 1^2 + 2^2 + 3^2 + 4^2 + 5^2
55

(define (accumulate combiner start n term)
  (if (= n 0)
      start
       (combiner (term n) (accumulate combiner start (- n 1) term))
  )
)
```

Use Ok to test your code:

<font color = pink>ÊòØÂæàÁÆÄÂçïÁöÑÈÄíÂΩí„ÄÇ‰ΩÜÊòØËá™Â∑±ÊÄªÊòØÂøòËÆ∞schemeÈáåÈù¢ifÂêéÈù¢ÁöÑ3‰∏™sub-expressionÂÖ∂ÂÆûÊòØ‰∏çÁî®Âä†Êã¨Âè∑ÁöÑÔºÅÔºÅÔºÅÔºÅ</font>

```
python3 ok -q accumulate
```

#### Q2: Tail Recursive Accumulate

Update your implementation of `accumulate` to be tail recursive. It should still pass all the tests for "regular" `accumulate`!

You may assume that the input `combiner` and `term` procedures are properly tail recursive.

> If you're running into an recursion depth exceeded error and you're using the staff interpreter, it's very likely your solution is not properly tail recursive.

```scheme
(define (accumulate-tail combiner start n term)
  (define (helper combiner now-result n term)
            (if (= n 0)
                now-result
                (helper combiner (combiner (term n) now-result) (- n 1) term)
            )
  )
  (helper combiner start n term)
)
```

<font color = pink>ÂìáÔºåÊàëÂÜô‰∫ÜËá™Â∑±ÁöÑÁ¨¨‰∏Ä‰∏™tail recursionÔºÅÊàëÁúüÁöÑÂæà‰∏çÈîôÔºÅ</font>

Use Ok to test your code:

```
python3 ok -q accumulate-tail
```

#### Q3: List Comprehensions

Recall that list comprehensions in Python had the following form:

```
[<expression> for <element> in <sequence> if <conditional>]
```

Use a macro to implement list comprehensions in Scheme. Specifically, we want a `list-of` macro that takes in the following information:

```
(list-of <expression> for <element> in <sequence> if <conditional>)
```

As an example, we could use the list comprehension macro in the following way:

```
scm> (list-of (* x x) for x in '(3 4 5) if (odd? x))
(9 25)
```

> Hint: you may use the built in `map` and `filter` procedures. Check out the [Scheme Primitives](https://inst.eecs.berkeley.edu/~cs61a/sp18/articles/scheme-primitives.html) reference for more information.

**Optional (not graded):** Recall also that the `if <conditional>` portion of the Python list comprehension was optional. Modify your macro so that the Scheme list comprehension does not require a conditional expression.

Refer to the [macro form](https://inst.eecs.berkeley.edu/~cs61a/sp18/articles/scheme-spec.html#define-x2d-macro) in the Scheme Specification for an explanation of how to do optional macro parameters.

```scheme
(define-macro (list-of expr for var in seq if filter-fn)
    `(map (lambda (,var) ,expr) (filter (lambda (,var) ,filter-fn) ,seq))
)
```

<font color = pink>‰∏ÄÂºÄÂßãfilterÂíåmapÁöÑÈ°∫Â∫èÂºÑÂèç‰∫ÜÔºåÊÉ≥‰∫ÜÂçäÂ§©ÔºÅÂèØÊÅ∂ÂèØÊÅ∂„ÄÇ‰∏ÄÂÆöË¶Å‰∏ÄÂºÄÂßãÂ∞±Â§¥ËÑëÊ∏ÖÈÜíÂú∞ÂÜô„ÄÇ</font>

Use Ok to test your code:

```
python3 ok -q list-comp
```



## hw 11

#### Q1: Find

Define a function `find` which takes in as input **a stream and a predicate**, and returns the first element in the stream satisfying the predicate. **The predicate is a one argument function** that returns either `#t` for a match or `#f` otherwise. If the item is not found, return `#f` (assume that a predicate will never match `#f`).

> *Extra note*: Is it always possible to correctly return `#f`? Can you think of a possible input `s` where we might run into issues (we won't test you on this case)?

```scheme
(define (find s predicate)
  (cond ((null? s) #f)
        ((predicate (car s)) (car s))
        (else (find (cdr-stream s) predicate))
  )
)
```

Use Ok to test your code:

```
python3 ok -q find
```

#### Q2: Scale Stream

Implement the function `scale-stream`, which takes a stream `s` and a number `k`, and returns a stream where each element is the corresponding element of `s` multiplied by `k`. For example, if `k` is 2, then all the elements in the stream are doubled. **Your solution should work even if `s` has an infinite number of items.**

```scheme
(define (scale-stream s k)
    (if (null? s) s (cons-stream (* k (car s)) (scale-stream (cdr-stream s) k)) )
)
```

Use Ok to test your code:

```
python3 ok -q scale-stream
```

#### Q3: Cycles

In Scheme, it's possible to have a stream with cycles. **That is, a stream may contain itself as part of the stream definition.**

```
scm> (define s (cons-stream 1 (cons-stream 2 s)))
scm> (car s)
1
scm> (car (cdr-stream (cdr-stream s)))
1
```

Implement `has-cycle`, that returns whether a stream contains a cycle.

> **Note:** You may assume that the input is either a stream of some unknown finite length, or contains a cycle.

```scheme
È¢ùÂïäÔºå‰∏ç‰ºöÂÜôscheme„ÄÇ‰πãÂâçÁî®pythonÂÜôËøáÔºå‰ΩÜÊòØscheme‰∏ç‰ºöÂÜôÈ∏≠„ÄÇ
‰∏çËøáÂÜôÂá∫‰∫Ü‰∏ãÈù¢constant spaceÁöÑÔºåÈÇ£ËøôÈÅìÂÖàÊîæÁùÄÂêß„ÄÇ
```

> **Hint:** `eq?` may be used to check if two items are the same stream instance.
>
> ```
>   scm> (define s (cons-stream 1 s))
>   scm> (eq? s (cdr-stream s))
>   True
> ```
>
> **It may be helpful to keep track of already seen stream instances.**

Use Ok to test your code:

```
python3 ok -q has-cycle
```

**Extra question**: *This question is not worth extra credit and is entirely optional.*

Implement `has-cycle-constant` with only [constant space](http://composingprograms.com/pages/28-efficiency.html#growth-categories). The solution is short (fewer than 20 lines of code), but requires a clever idea. Try to discover the solution yourself before asking around:

We don't directly test if your solution uses constant space, but it will likely timeout if you do not use constant space.

```scheme
(define (has-cycle-constant s)
  (define (helper fast slow)
          (cond ((null? fast) #f)
                ((eq? (cdr-stream (cdr-stream fast)) (cdr-stream slow)) #t)
                (else (helper (cdr-stream (cdr-stream fast)) (cdr-stream slow)))
          )
  )
  (helper s s)
)
```

Use Ok to test your code:

```
python3 ok -q has-cycle-constant
```

## Lab 11: Iterators and Generators

### Topics

#### Iterables and Iterators

Iterables are objects that can be iterated through. One construct that we can use to iterate through an iterable is a for loop:

```
for elem in iterable:
    # do something
```

`for` loops work on any object that is *iterable*. **We previously described it as working with any sequence -- all sequences are iterable, but there are other objects that are also iterable!** As it turns out, for loops are actually translated by the interpreter something similar to the following code:

```
iterator = iter(iterable)
try:
    while True:
        elem = next(iterator)
        # do something
except StopIteration:
    pass
```

Here's a breakdown of what's happening:

- First, the built-in `iter` function is called on the iterable to create a corresponding *iterator*, an object used to iterate through the iterable by keeping track of which element is next in the sequence.
- To get the next element in the sequence, the built-in `next` function is called on this iterator.
- When `next` is called but there are no elements left in the iterator, a `StopIteration` error is raised. In the for loop construct, this exception is caught and execution can continue.

Calling `iter` on an iterable multiple times returns a new iterator each time with distinct states (otherwise, you'd never be able to iterate through a iterable more than once). You can also call `iter` on the iterator itself, **which will just return the same iterator without changing its state**. However, note that you cannot call `next` directly on an iterable.

Let's see the `iter` and `next` functions in action with an iterable we're already familiar with -- a list.

```
>>> lst = [1, 2, 3, 4]
>>> next(lst)
TypeError: 'list' object is not an iterator
>>> list_iter = iter(lst)
>>> list_iter
<list_iterator object ...>
>>> next(list_iter)
1
>>> next(list_iter)
2
>>> next(iter(list_iter))   # Calling iter on an iterator returns itself
3
>>> list_iter2 = iter(lst)
>>> next(list_iter2)        # Second iterator has new state
1
>>> next(list_iter)         # First iterator is unaffected by second iterator
4
>>> next(list_iter)         # No elements left!
StopIteration
>>> lst                     # Original iterable is unaffected
[1, 2, 3, 4]
```

Since you can call `iter` on iterators, this tells us that that they are also iterables. You can use iterators wherever you can use iterables, but note that since iterators keep their state, they're only good to iterate through once:

```
>>> list_iter = iter([4, 3, 2, 1])
>>> for e in list_iter:
...     print(e)
4
3
2
1
>>> next(list_iter)
StopIteration
```

> **Analogy**: An iterable is like a book (one can flip through the pages) and an iterator for a book would be a bookmark (saves the position and can locate the next page). Calling `iter` on a book gives you a new bookmark independent of other bookmarks, but calling `iter` on a bookmark gives you the bookmark itself, without changing its position at all. Calling `next` on the bookmark moves it to the next page, but does not change the pages in the book. Calling `next` on the book wouldn't make sense semantically.

#### Iterable uses

We know that lists are one type of built-in iterable objects. You may have also encounter the `range(start, end)` function, which creates an iterable of ascending integers from start (inclusive) to end (exclusive).

```
>>> for x in range(2, 6):
...     print(x)
...
2
3
4
5
```

Ranges are useful for many things, including performing some operations for a particular number of iterations or iterating through the indices of a list.

There are also some built-in functions that take in iterables and return useful results:

- `map(f, iterable)` - Creates iterator over `f(x)` for `x` in iterable
- `filter(f, iterable)` - Creates iterator over `x` for `x` in iterable if `f(x)`
- `zip(iter1, iter2)` - Creates iterator over co-indexed pairs (x, y) from both input iterables
- `reversed(iterable)` - Creates iterator sequence containing elements of iterable in reverse order
- `list(iterable)` - Creates a list containing all x in iterable
- `tuple(iterable)` - Creates a tuple containing all x in iterable
- `sorted(iterable)` - Creates a sorted list containing all x in iterable

#### Generators

A ==generator function== returns a special type of iterator called a **generator**. Generator functions have `yield` statements within the body of the function instead of `return` statements. **Calling a generator function will return a generator object and will *not* execute the body of the function.**

For example, let's consider the following generator function:

```
def countdown(n):
    print("Beginning countdown!")
    while n >= 0:
        yield n
        n -= 1
    print("Blastoff!")
```

Calling `countdown` will return a generator object that counts down from `n` to 0. Since generators are iterators, we can call `iter` on the resulting object, which will simply return the same object. Note that the body is not executed at this point; nothing is printed and no numbers are output.

```
>>> c = countdown(5)
>>> c
<generator object countdown ...>
>>> c is iter(c)
True
```

So how is the counting done? Again, since generators are a type of iterator, we can also call `next` on them! The first time `next` is called, execution begins at the first line of the function body and continues until the `yield` statement is reached. The result of evaluating the expression in the `yield` statement is returned. The following interactive session continues from the one above.

```
>>> next(c)
Beginning countdown!
5
```

==Unlike functions we've seen before in this course, generator functions can remember their state==. On any consecutive calls to `next`, execution picks up from the line after the `yield` statement that was previously executed. Like the first call to `next`, execution will continue until the next `yield` statement is reached.

```
>>> next(c)
4
>>> next(c)
3
```

Can you predict what would happen if we continue to call `next` on `c` 4 more times?

Separate calls to `countdown` will create distinct generator objects with their own state. Usually, generators shouldn't restart. If you'd like to reset the sequence, create another generator object by calling the generator function again.

```
>>> c1, c2 = countdown(5), countdown(5)
>>> c1 is c2
False
>>> next(c1)
5
>>> next(c2)
5
```

Here is a summary of the above:

- A generator function has a `yield` statement and returns a generator object.
- Calling the `iter` function on a generator object returns the same object without modifying its current state.
- The body of a generator function is not evaluated until `next` is called on a resulting generator object. Calling the `next` function on a generator object computes and returns the next object in its sequence. If the sequence is exhausted, `StopIteration` is raised.
- A generator "remembers" its state for the next `next` call. Therefore,
  - the first `next` call works like this:
    1. Enter the function and run until the line with `yield`.
    2. Return the value in the `yield` statement, but remember the state of the function for future `next` calls.
  - And subsequent `next` calls work like this:
    1. ==Re-enter== the function, start at **the line after `yield`**, and run until the next `yield` statement.
    2. Return the value in the `yield` statement, but remember the state of the function for future `next` calls.
- A generator should not restart unless it's defined that way. But calling the generator function returns a brand new generator object (like calling `iter` on an iterable object).

Another useful tool for generators is the `yield from` statement (introduced in Python 3.3). `yield from` will ==yield all values from an iterator or iterable==.

```
>>> def gen_list(lst):
...     yield from lst
...
>>> g = gen_list([1, 2, 3, 4])
>>> next(g)
1
>>> next(g)
2
>>> next(g)
3
>>> next(g)
4
>>> next(g)
StopIteration
```

### Required Questions

### WWPD

#### Q1: WWPD: Iterators

> Use Ok to test your knowledge with the following "What Would Python Display?" questions:
>
> ```
> python3 ok -q iterators -u
> ```
>
> Enter `Error` if you believe an error occurs, `StopIteration` if a `StopIteration` exception is raised, and `Iterator` if the output is a iterator object.

```
>>> s = [1, 2, 3, 4]
>>> t = iter(s)
>>> next(s)
______
>>> next(t)
______
>>> next(t)
______
>>> iter(s)
______
>>> next(iter(s))
______
>>> next(iter(t))
______
>>> next(iter(s))
______
>>> next(iter(t))
______
>>> next(t)
______
>>> r = range(6)
>>> r_iter = iter(r)
>>> next(r_iter)
______
>>> [x + 1 for x in r]
______
>>> [x + 1 for x in r_iter]
______
>>> next(r_iter)
______
>>> list(range(-2, 4))   # Converts an iterable into a list
______
>>> map_iter = map(lambda x : x + 10, range(5))
>>> next(map_iter)
______
>>> next(map_iter)
______
>>> list(map_iter)
______
>>> for e in filter(lambda x : x % 2 == 0, range(1000, 1008)):
...     print(e)
...
______
>>> [x + y for x, y in zip([1, 2, 3], [4, 5, 6])]
______
>>> for e in zip([10, 9, 8], range(3)):
...   print(tuple(map(lambda x: x + 2, e)))
...
______
```

#### Q2: WWPD: Generators

> Use Ok to test your knowledge with the following What would Python Display questions:
>
> ```
> python3 ok -q generators -u
> ```
>
> Enter `Error` if you believe an error occurs, `Function` if the output is a function object, and `Generator` if the output is a generator object.

```
def gen():
    print("Starting here")
    i = 0
    while i < 6:
        print("Before yield")
        yield i
        print("After yield")
        i += 1
>>> next(gen)
______
>>> gen
______
>>> g = gen()
>>> g
______
>>> g == iter(g)
______
>>> next(g)
______
>>> next(g)
______
>>> next(g)
______
>>> g2 = gen()
>>> next(g2)
______
>>> iter(g2)
______
>>> next(iter(g))
______
>>> next(gen())
______
```

### Coding Practice

#### Q3: Scale

Implement the generator function `scale(s, k)`, which yields elements of the given iterable `s`, scaled by `k`. As an extra challenge, try writing this function using a `yield from` statement!

```python
def scale(s, k):
    """Yield elements of the iterable s scaled by a number k.

    >>> s = scale([1, 5, 2], 5)
    >>> type(s)
    <class 'generator'>
    >>> list(s)
    [5, 25, 10]

    >>> m = scale(naturals(), 2)
    >>> [next(m) for _ in range(5)]
    [2, 4, 6, 8, 10]
    """
    "*** YOUR CODE HERE ***"
    iter_s = iter(s)
    try:
        while True:
            yield next(iter_s) * k
    except StopIteration:
        pass
    # Áî®yield fromÂÜô
    yield from map(lambda x: x * k, s)
```

Use Ok to test your code:

```
python3 ok -q scale
```

<font color = pink>extra challenge ÊÉ≥‰∫Ü‰∏ÄÊÉ≥‰πüÂÜôÂá∫Êù•‰∫ÜÔºåÊàëËøòÊòØÂçÅÂàÜËÅ™ÊòéÁöÑ„ÄÇÊª°ÊÑè</font>

#### Q4: Trap

Write a generator function that yields the first `k` values in iterable `s`, but raises a `ValueError` exception if any more values are requested. You may assume that `s` has at least `k` values.

```python
def trap(s, k):
    """Return a generator that yields the first K values in iterable S,
    but raises a ValueError exception if any more values are requested.

    >>> t = trap([3, 2, 1], 2)
    >>> next(t)
    3
    >>> next(t)
    2
    >>> next(t)
    ValueError
    >>> list(trap(range(5), 5))
    ValueError
    >>> t2 = trap(map(abs, reversed(range(-6, -4))), 2)
    >>> next(t2)
    5
    >>> next(t2)
    6
    >>> next(t2)
    ValueError
    """
    "*** YOUR CODE HERE ***"
    t = 0
    new_s = iter(s)
    while t < k:
        yield next(new_s)
        t += 1
    if t >= k:
        raise ValueError
```

Use Ok to test your code:

```
python3 ok -q trap
```

### Optional Questions

#### Q5: Hailstone

Write a generator that outputs the hailstone sequence from homework 1.

Here's a quick reminder of how the hailstone sequence is defined:

1. Pick a positive integer `n` as the start.
2. If `n` is even, divide it by 2.
3. If `n` is odd, multiply it by 3 and add 1.
4. Continue this process until `n` is 1.

```python
def hailstone(n):
    """
    >>> for num in hailstone(10):
    ...     print(num)
    ...
    10
    5
    16
    8
    4
    2
    1
    """
    "*** YOUR CODE HERE ***"
    yield n
    while n != 1:
        if n % 2 == 0:
            n = n // 2
        else:
            n = (3 * n) + 1
        yield n
```

Use Ok to test your code:

```
python3 ok -q hailstone
```

#### Q6: Repeated

Implement a function (not a generator function) that returns the first value in iterable `t` that appears `k` times in a row.

```python
def repeated(t, k):
    """Return the first value in iterable T that appears K times in a row.

    >>> s = [3, 2, 1, 2, 1, 4, 4, 5, 5, 5]
    >>> repeated(trap(s, 7), 2)
    4
    >>> repeated(trap(s, 10), 3)
    5
    >>> print(repeated([4, None, None, None], 3))
    None
    """
    assert k > 1
    "*** YOUR CODE HERE ***"
    check_repeat = []
    my_iter = iter(t)
    check_repeat.append(next(my_iter))  # put the first element of t in check_repeat anyway
    try:
        while True:
            check_repeat.append(next(my_iter))
            if check_repeat[-2] != check_repeat[-1]:
                check_repeat = check_repeat[1:]
            if len(check_repeat) == k:
                return check_repeat[-1]
    except StopIteration or ValueError:
        return None
```

Use Ok to test your code:

```
python3 ok -q repeated
```

#### Q7: Merge

Implement `merge(s0, s1)`, which takes two iterables `s0` and `s1` whose elements are ordered. `merge` yields elements from `s0` and `s1` **in sorted order, eliminating repetition**. You may assume `s0` and `s1` themselves do not contain repeats, and that none of the elements of either are `None`. You may **not** assume that the iterables are finite; either may produce an infinite stream of results.

You will probably find it helpful to use the two-argument version of the built-in `next` function: `next(s, v)` is the same as `next(s)`, except that instead of raising `StopIteration` when `s` runs out of elements, it returns `v`.

See the doctest for examples of behavior.

```python
def merge(s0, s1):
    """Yield the elements of strictly increasing iterables s0 and s1, removing
    repeats. Assume that s0 and s1 have no repeats. s0 or s1 may be infinite
    sequences.

    >>> m = merge([0, 2, 4, 6, 8, 10, 12, 14], [0, 3, 6, 9, 12, 15])
    >>> type(m)
    <class 'generator'>
    >>> list(m)
    [0, 2, 3, 4, 6, 8, 9, 10, 12, 14, 15]
    >>> def big(n):
    ...    k = 0
    ...    while True: yield k; k += n
    >>> m = merge(big(2), big(3))
    >>> [next(m) for _ in range(11)]
    [0, 2, 3, 4, 6, 8, 9, 10, 12, 14, 15]
    """
    i0, i1 = iter(s0), iter(s1)
    e0, e1 = next(i0, None), next(i1, None)
    "*** YOUR CODE HERE ***"
    try:
        while (e0 is not None) or (e1 is not None):
            if e0 is None or e0 > e1:
                yield e1
                e1 = next(i1, None)
            elif e1 is None or e0 < e1:
                yield e0
                e0 = next(i0, None)
            elif e0 == e1:
                yield e0
                e0, e1 = next(i0, None), next(i1, None)

    except StopIteration:
        pass
```

Use Ok to test your code:

```
python3 ok -q merge
```

#### Q8: Remainder Generator

Like functions, generators can also be *higher-order*. For this problem, we will be writing `remainders_generator`, **which yields a series of generator objects**.

`remainders_generator` takes in an integer `m`, and yields `m` different generators. The first generator is a generator of multiples of `m`, i.e. numbers where the remainder is 0. The second, a generator of natural numbers with remainder 1 when divided by `m`. The last generator yield natural numbers with remainder `m - 1` when divided by `m`.

```python
def remainders_generator(m):
    """
    Takes in an integer m, and yields m different remainder groups
    of m.

    >>> remainders_mod_four = remainders_generator(4)
    >>> for rem_group in remainders_mod_four:
    ...     for _ in range(3):
    ...         print(next(rem_group))
    0
    4
    8
    1
    5
    9
    2
    6
    10
    3
    7
    11
    """
    "*** YOUR CODE HERE ***"
    def inner_generator():
        t = 0
        while True:
            yield m * t + count
            t += 1
    count = 0
    while count < m:
        yield inner_generator()
        count += 1
```

Note that if you have implemented this correctly, each of the generators yielded by `remainder_generator` will be *infinite* - you can keep calling `next` on them forever without running into a `StopIteration` exception.

**Hint**: Consider defining an inner generator function. What arguments should it take in? Where should you call it?

Use Ok to test your code:

```
python3 ok -q remainders_generator
```

#### Q9: Zip Generator ‚≠ê

For this problem, we will be writing `zip_generator`, which yields a series of lists, each containing the nth items of each iterable. It should stop when the smallest iterable runs out of elements.

```python
def zip_generator(*iterables):
    """
    Takes in any number of iterables and zips them together.
    Returns a generator that outputs a series of lists, each
    containing the nth items of each iterable.
    >>> z = zip_generator([1, 2, 3], [4, 5, 6], [7, 8])
    >>> for i in z:
    ...     print(i)
    ...
    [1, 4, 7]
    [2, 5, 8]
    """
    "*** YOUR CODE HERE ***"
    try:
        n = 0
        while True:
            lst = []
            n += 1
            for it in iterables:
                i = iter(it)
                for j in range(n):  
                    te = next(i)
                lst.append(te)
            yield lst
    except StopIteration:
        pass
```

<font color = pink> ÊØèÊ¨°iter‰πãÂêéÂ∞±ÊòØÊñ∞ÁöÑ‰∫Ü, ÊâÄ‰ª•Áî®for¬† j in range(n)Êù•ÊéßÂà∂ÂéªÂà∞Á¨¨Âá†‰∏™nextÔºåÂ¶ôÂ¶ôÔºåËá™Â∑±Ê≤°ÊÉ≥Âà∞„ÄÇ</font>

Use Ok to test your code:

```
python3 ok -q zip_generator
```



## Lab 12: SQL

### Topics

### SQL Basics

#### Creating Tables

You can create SQL tables either from scratch or from existing tables.

Below creates the table from scratch, **without referencing any other existing tables**.

```
CREATE TABLE [table_name] AS
  SELECT [val1] AS [column1], [val2] AS [column2], ... UNION
  SELECT [val3]             , [val4]             , ... UNION
  SELECT [val5]             , [val6]             , ...;
```

> *Note:* You do not need to repeat the `AS` keyword in subsequent SELECT statements when creating the table.

Here is an example where we construct a table with the `CREATE TABLE` statement. `UNION` is used here to join rows and `AS` assigns a table column to a new name.

```
CREATE TABLE Football AS
  SELECT 30 AS Berkeley, 7 AS Stanford, 2002 AS Year UNION
  SELECT 28,             16,            2003         UNION
  SELECT 17,             38,            2014;
```

Here we have created a table called `Football`, which has three attributes (columns): `Berkeley`, `Stanford`, and `Year`. We can later access the values from this table by referencing the table's columns.

To create tables from existing tables, the `SELECT` command references another table.

#### Selecting From Tables

More commonly, we will create new tables by selecting specific columns that we want from existing tables. `SELECT` statements can include ==optional clauses== such as:

- `FROM`: tells SQL which tables to select values from

- `WHERE`: filters by some condition

- `ORDER BY`: enforces an ordering by some attribute or attributes (usually a column or columns)

- `LIMIT`: limits the number of rows in the output table

  ```
  SELECT [columns] FROM [tables] WHERE [condition] ORDER BY [attributes] LIMIT [limit];
  ```

Notes about the arguments:

- `[columns]`: a comma separated list of the columns to select, `*` can be used to select all of them
- `[tables]`: a comma separated list of tables to select values from
- `[condition]`: a Boolean expression
- `[attributes]`: a comma separated list of attributes, which are usually columns, but could also be named aggregates (which we will learn later)
- `[limit]`: an integer

We can select all the values of an attribute from a table with the `SELECT` statement. In addition, we can apply a filter using the `WHERE` clause. Here, we filter by `Year > 2002`, which makes the `SELECT` statement keep only the rows in the table whose `Year` value is greater than 2002.

```
sqlite> SELECT Berkeley FROM Football WHERE Year > 2002;
17
28
```

Here we selected Berkeley's score for all years after 2002.

#### Expressions in SQL

Here are some fundamental operations you can perform:

- comparisons: `=`, `>`, `<`, `<=`, `>=`, `<>` ("not equal")
- booleans: `AND`, `OR`
- arithmetic: `+`, `-`, `*`, `/`

We can also perform string concatenation using `||`, **which behaves similarly to `+` on strings in Python**.

```
sqlite> SELECT "hello" || " " || "world";
hello world
```

Note we capitalize SQL syntax purely for style. It makes it much easier to read, though will work if you don't capitalize it.

### Joins

==We can use *joins* to include rows from another table that satisfy the `WHERE` predicate==. Joins can either be on different tables, or the same table if we include an alias. Here we are referencing the football table twice, using `AS` to bind the football table once as the alias `a` and once as the alias `b`.

```
sqlite> SELECT b.Berkeley - a.Berkeley, b.Stanford - a.Stanford, a.Year, b.Year
...>        FROM Football AS a, Football AS b WHERE a.Year < b.Year;
-11|22|2003|2014
-13|21|2002|2014
-2|9|2002|2003
```

What is this query asking for?

You may notice that it does not seem like we actually performed any operations to do the join. However, the join is implicit in the fact that we listed more than one table after the FROM. In this example, we joined the table `Football` with itself and gave each instance of the table an alias, `a` and `b` so that we could distinctly refer to each table's attributes and perform selections and comparisons on them, such as `a.Year < b.Year`.

**One way to think of a join is that it produces a cross-product between the two tables by matching each row from the first table with every other row in the second table, which creates a new, larger joined table.**

From here, the select statement examines the joined table and selects the values it desires: `b.Berkeley - a.Berkeley` and `b.Stanford - a.Stanford` but only from the rows `WHERE a.Year < b.Year`. This **prevents duplicate results from appearing in our output and also removes rows where the years are the same.**

### Required Questions

#### Getting to Know Your Fellow 61A Students

This past weekend, we asked you and your fellow students to complete a brief online survey through Google Forms, which involved relatively random but fun questions. In this lab, we will interact with the results of the survey by using SQL queries to see if we can find interesting things in the data.

First, take a look at `sp18data.sql` and examine the table defined in it. Note its structure. You will be working with:

- `students`: The main results of the survey. Each column represents a different question from the survey, except for the first column, which is the time of when the result was submitted. **This time is a unique identifier for each of the rows in the table.**

  | Column Name | Question                                                     |
  | :---------- | :----------------------------------------------------------- |
  | `time`      | The unique timestamp that identifies the submission          |
  | `number`    | What's your favorite number between 1 and 100?               |
  | `color`     | What is your favorite color?                                 |
  | `seven`     | Choose the number 7 below. Options: 1„ÄÅ7     2„ÄÅYou're not the boss of me!  3„ÄÅChoose this option instead       4„ÄÅseven  5„ÄÅthe number 7 below. |
  | `song`      | If you could listen to only one of these songs for the rest of your life, which would it be? Options: "Smells Like Teen Spirit" by Nirvana"The Middle" by Zedd"Fur Elise" by Ludwig van Beethoven"Finesse ft. Cardi B" by Bruno Mars"God's Plan" by Drake"Down With The Sickness" by Disturbed"Everytime We Touch" by Cascada |
  | `date`      | Pick a day of the year!                                      |
  | `pet`       | If you could have any animal in the world as a pet, what would it be? |
  | `denero`    | Choose your favorite photo of John DeNero! (Options shown under Question 2) |
  | `smallest`  | Try to guess the smallest unique positive INTEGER that anyone will put! |

- `checkboxes`: The results from the survey in which students could select more than one option from the numbers listed, which ranged from 0 to 10 and included 2018, 9000, and 9001. Each row has a time (which is again a unique identifier) and has the value `'True'` if the student selected the column or `'False'` if the student did not. The column names in this table are the following strings, referring to each possible number: `'0'`, `'1'`, `'2'`, `'4'`, `'5'`, `'6'`, `'7'`, `'8'`, `'9'`, `'10'`, `'2018'`, `'9000'`, `'9001'`.

Since the survey was anonymous, we used the timestamp that a survey was submitted as a unique identifier. A time in `students` matches up with a time in `checkboxes`. For example, the row in `students` whose `time` value is `"4/13/2018 15:25:03"` matches up with the row in `checkboxes` whose `time` value is `"4/13/2018 15:25:03"`. These entries come from the same Google form submission and thus belong to the same student.

> *Note*: If you are looking for your personal response within the data, you may have noticed that some of your answers are slightly different from what you had input. In order to make SQLite accept our data, and to optimize for as many matches as possible during our joins, we did the following things to clean up the data:
>
> - `color` and `pet`: We converted all the strings to be completely lowercase.
> - For some of the more "free-spirited" responses, we escaped the special characters so that they could be properly parsed.

You will write all of your solutions in the starter file `lab12.sql` provided. As with other labs, you can test your solutions with OK. In addition, you can use either of the following commands. You may need to refer to the Usage section to find the appropriate command for your OS:

```
sqlite3 < lab12.sql
sqlite3 --init lab12.sql
```

#### Q1: What Would SQL print?

First, load the tables into sqlite3. If you're on Windows or Mac OS X (Mavericks or older), use the following command:

```
$ ./sqlite3 --init lab12.sql
```

If you're on Ubuntu or Mac OS X (Yosemite or newer), use:

```
$ sqlite3 --init lab12.sql
```

Before we start, inspect the schema of the tables that we've created for you:

```
sqlite> .schema
```

This tells you the name of each of our tables and their attributes.

Let's also take a look at some of the entries in our table. There are a lot of entries though, so let's just output the first 20:

```
sqlite> SELECT * FROM students LIMIT 20;
```

If you're curious about some of the answers students put into the Google form, open up `sp18data.sql` in your favorite text editor and take a look!

For each of the SQL queries below, think about what the query is looking for, then try running the query yourself and see!

```
sqlite> SELECT * FROM students; -- This is a comment. * is shorthand for all columns!
______
sqlite> SELECT color FROM students WHERE number = 16;
______
sqlite> SELECT song, pet FROM students WHERE color = "blue" AND date = "12/25";
______
```

Remember, to exit out of SQLite after using the second command, type `.exit` or `.quit` or hit `Ctrl-C`. Also, if you see `...>` you probably forgot a `;`

### Q2: Obedience



To warm-up, let's ask a simple question related to our data: Is there a correlation between whether students do as they're told and their favorite images of the instructor?

<img src="C:\Users\cyc\AppData\Roaming\Typora\typora-user-images\image-20220324171046346.png" alt="image-20220324171046346" style="zoom:80%;" />

Write an SQL query to create a table that contains the columns `seven` (this column representing "obedience") and `denero` (the image of Professor DeNero students selected) from the `students` table.

You should get the following output:

```sql
sqlite> SELECT * FROM obedience LIMIT 10;
7|Image 1
7|Image 5
the number 7 below.|Image 1
7|Image 2
7|Image 2
the number 7 below.|Image 1
the number 7 below.|Image 5
7|Image 1
You're not the boss of me!|Image 4
7|Image 4

-- Q2
CREATE TABLE obedience AS
  SELECT seven, denero FROM students;
```

Use Ok to test your code:

```
python3 ok -q obedience
```

### Q3: The Smallest Unique Positive Integer

Who successfully managed to guess the smallest unique positive integer value? Let's find out!

Unfortunately we have not learned how to do aggregations in SQL, which can help us count the number of times a specific value was selected, just yet. **As such, we can only hand inspect our data to determine it.** However, an anonymous elf (==Á¨ëÈº†Ôºå‰∏çÊÑøÊÑèÈÄèÈú≤ÂßìÂêçÁöÑÂ∞èÁ≤æÁÅµÊòØÂêß==) has informed us that the smallest unique positive value is greater than 15!

Write an SQL query to create a table with the columns `time` and `smallest` that we can inspect to determine what the smallest integer value is. In order to make it easier for us to inspect these values, use `WHERE` to restrict the answers to numbers greater than 15, `ORDER BY` to sort the numerical values, and `LIMIT` your result to the first 20 values that are greater than the number 15.

The first 5 lines of your output should look like this:

```
sqlite> SELECT * FROM smallest_int LIMIT 5;
4/13/2018 15:16:12|16
4/13/2018 15:22:11|16
4/13/2018 15:15:08|17
4/13/2018 15:18:10|17
4/13/2018 15:21:43|17
4/13/2018 15:22:13|17
CREATE TABLE smallest_int AS
  SELECT "REPLACE THIS LINE WITH YOUR SOLUTION";
```

Use Ok to test your code:

```
python3 ok -q smallest-int
```

After you've successfully passed the Ok test, take a look at the table `smallest_int` that you just created and manually find the smallest unique integer value! If you're curious how to do this with aggregations, check out [Question 8](https://inst.eecs.berkeley.edu//~cs61a/sp18/lab/lab12/#q8).

To do this, try the following:

```
$ sqlite3 --init lab12.sql
sqlite> SELECT * FROM smallest_int; -- No LIMIT this time!
```

### Q4: Matchmaker, Matchmaker

Did you take 61A with the hope of finding your soul mate? Well you're in luck! With all this data in hand, it's easy for us to find your perfect match. If two students want the same pet and have the same taste in music, they are clearly meant to be together! In order to provide some more information for the potential lovebirds to converse about, let's include the favorite colors of the two individuals as well!

In order to match up students, you will have to do a join on the `students` table with itself. When you do a join, SQLite will match every single row with every single other row, **so make sure you do not match anyone with themselves, or match any given pair twice!**

> **Important Note:** When pairing the first and second person, **make sure that the first person responded first (i.e. they have an earlier `time`). This is to ensure your output matches our tests.**

> *Hint:* When joining table names where column names are the same, use dot notation to distinguish which columns are from which table: `[table_name].[column name]`. This sometimes may get verbose, so it‚Äôs stylistically better to give tables an alias using the `AS` keyword. The syntax for this is as follows:
>
> ```
> SELECT <[alias1].[column name1], [alias2].[columnname2]...>
>     FROM <[table_name1] AS [alias1],[table_name2] AS [alias2]...> ...
> ```
>
> The query in the [football example](https://inst.eecs.berkeley.edu//~cs61a/sp18/lab/lab12/#joins) from earlier uses this syntax.

Write a SQL query to create a table that has 4 columns:

- The shared preferred `pet` of the couple
- The shared favorite `song` of the couple
- The favorite `color` of the first person
- The favorite `color` of the second person

You should get the following output:

```
sqlite> SELECT * FROM matchmaker LIMIT 10;
wolf|Fur Elise|green|blue
cat|Smells Like Teen Spirit|purple|purple
cat|Smells Like Teen Spirit|purple|green
cat|Smells Like Teen Spirit|purple|blue
dog|Finesse|navy|red
dog|Finesse|navy|mint
dog|Finesse|navy|blue
dog|Finesse|navy|blue
elephant|The Middle|purple|yellow
dog|Finesse|red|mint
CREATE TABLE matchmaker AS
  SELECT "REPLACE THIS LINE WITH YOUR SOLUTION";
```

Use Ok to test your code:

```
python3 ok -q matchmaker
```

### Optional Questions

> The following questions are for **extra practice** -- they can be found in the [lab12_extra.sql](https://inst.eecs.berkeley.edu//~cs61a/sp18/lab/lab12/lab12_extra.sql) file. It is recommended that you complete these problems, but you do not need to turn them in for credit.

#### Q5: Great Students Think Alike 

We administered a similar survey for Lab 12 last semester to 61A students (see the table `fa17students` in `fa17data.sql`).

The only question that has been removed is `hilfinger`, so let's play around with this data using joins!

Great students think alike. We want to print out the information of students that have the same favorite `date`, `color` and `pet`! How do their favorite `number`s differ?

Write a SQL query to create a table that has 5 columns:

- The shared favorite `date` between semesters
- The shared favorite `color` between semesters
- The shared favorite `pet` between semesters
- The favorite `number` of this semester's student
- The favorite `number` of last semester's student

You should get the following output:

```sqlite
sqlite> SELECT * FROM greatstudents;
2/29|blue|dragon|69|12
12/25|blue|dog|17|7
12/25|blue|dog|17|15
1/1|green|dog|3|7
1/1|blue|dog|11|60
4/20|white|sloth|11|69
1/1|black|dog|1|1
12/25|blue|tiger|17|21
CREATE TABLE greatstudents AS
  SELECT a.date, a.color, a.pet, a.number, b.number FROM students as a, fa17students as b
  WHERE a.date = b.date and a.color = b.color and a.pet = b.pet;
```

Use Ok to test your code:

```
python3 ok -q greatstudents
```

After you've successfully passed the Ok test, play around some more with joins to see what cool connections you can draw between the data from both semesters!

#### Q6: Sevens

Let's take a look at data from both of our tables, `students` and `checkboxes`, to find out if students that really like the number 7 also chose `'7'` for the obedience question. **Specifically, we want to look at the students that fulfill the below conditions and see if they also chose `'7'` in the question that asked students to choose the number 7 (column `seven` in `students`).**

Conditions:

- reported that their favorite number (column `number` in `students`) was 7
- have `'True'` in column `'7'` in `checkboxes`, meaning they checked the number `7` during the survey

In order to examine rows from both the `students` and the `checkboxes` table, we will need to perform a join.

==How would you specify the `WHERE` clause to make the `SELECT` statement only consider rows in the joined table whose values all correspond to the same student?==If you find that your output is massive and overwhelming, then you are probably missing the necessary condition in your `WHERE` clause to ensure this. <font color = pink>ÂìáËøôÂ∞±ÊòØÊàëÁöÑÈîôËØØÔºåÂøòËÆ∞Ëá™Â∑±ÊòØÂú®join‰∫ÜÔºåÊâÄ‰ª•Ê≤°ÊúâÂä†‰∏äÂà§Êñ≠‰ªñ‰ª¨ÊòØÂêå‰∏Ä‰∏™‰∫∫ÁöÑÊù°‰ª∂</font>

> *Note:* The columns in the `checkboxes` table are strings with the associated number, so you must put quotes around the column name to refer to it. For example if you alias the table as `a`, to get the column to see if a student checked 9001, you must write `a.'9001'`.

Write a SQL query to create a table with just the column `seven` from `students`, filtering first for students who said their favorite number (column `number`) was 7 in the `students` table and who checked the box for seven (column `'7'`) in the `checkboxes` table.

The first 10 lines of this table should look like this:

```sqlite
sqlite> SELECT * FROM sevens LIMIT 10;
7
7
7
You're not the boss of me!
7
seven
the number 7 below.
You're not the boss of me!
7
7
CREATE TABLE sevens AS
  SELECT b.seven from students as b, checkboxes as a WHERE b.number = 7 AND a.'7' = 'True' AND b.time = a.time;
```

Use Ok to test your code:

```
python3 ok -q sevens
```

#### The COUNT Aggregator

How many people liked each pet? What is the biggest date chosen this semester? How many obedient people chose Image 1 for Professor DeNero or Professor Hilfinger? Is there a difference between last semester's average favorite number and this semester's?

To answer these types of questions, we can bring in SQL aggregation, which allows us to accumulate values across rows in our SQL database!

In order to perform SQL aggregation, we can group rows in our table by one or more attributes. Once we have groups, we can aggregate over the groups in our table and find things like:

- the maximum value (`MAX`),
- the minimum value (`MIN`),
- the number of rows in the group (`COUNT`),
- the average over all of the values (`AVG`),

and more! `SELECT` statements that use aggregation are usually marked by two things: an aggregate function (`MAX`, `MIN`, `COUNT`, `AVG`, etc.) and a `GROUP BY` clause. `GROUP BY [column(s)]` groups together rows with the same value in each column(s). In this section we will only use `COUNT`, which will count the number of rows in each group, but feel free to check out [this link](http://www.sqlcourse2.com/agg_functions.html) for more!

For example, the following query will print out the top 10 favorite numbers with their respective counts:

```
sqlite> SELECT number, COUNT(*) AS count FROM students GROUP BY number
  ORDER BY count DESC LIMIT 10;
  69|31
  7|19
  4|13
  17|13
  42|12
  1|11
  3|10
  9|10
  11|9
  12|9
```

==This `SELECT` statement first groups all of the rows in our table `students` by `number`. Then, within each group, we perform aggregation by `COUNT`ing all the rows. By selecting `number` and `COUNT(*)`, we then can see the highest `number` and how many students picked that number. We have to order by our `COUNT(*)`, which is saved in the alias `count`, by `DESC`ending order, so our highest count starts at the top, and we limit our result to the top 10.==

#### Q7: Let's Count

Let's have some fun with this! For each query below, we created its own table in `lab12_extra.sql`, so fill in the corresponding table and run it using Ok. Try working on this on your own or with a neighbor before toggling to see the solutions.

> *Hint:* You may find that there isn't a particular attribute you should have to perform the `COUNT` aggregation over. If you are only interested in counting the number of rows in a group, you can just say `COUNT(*)`.

What was the favorite number from last semester?

```sqlite
sqlite> SELECT * FROM fa17favnum;
69|66
CREATE TABLE fa17favnum AS
  SELECT max(number), count(*) FROM fa17students GROUP BY number ORDER BY count(*) DESC LIMIT 1;
```

What were the top 10 pets last semester?

```sql
sqlite> SELECT * FROM fa17favpets;
dog|57
cat|33
dragon|14
panda|14
tiger|14
lion|13
penguin|12
dolphin|10
john denero|9
elephant|8
CREATE TABLE fa17favpets AS
  SELECT pet, count(*) FROM fa17students GROUP BY pet ORDER BY count(*) DESC, pet LIMIT 10;

```

<font color = pink>ÊéíÂ∫èÂèØ‰ª•ÊúâÂ§ö‰∏™ÂèÇÁÖßÔºåËøôÈáåÂÖàÊåâÁÖßcountÊù•ÈôçÂ∫èÊéíÂàóÔºåÁÑ∂ÂêéÊåâÁÖßpetÂçáÂ∫èÊéíÂàó</font>

What are the top 10 pets this semester?

```sqlite
sqlite> SELECT * FROM sp18favpets;
dog|47
cat|20
tiger|16
panda|11
dragon|9
dolphin|5
elephant|5
hedgehog|5
monkey|5
capybara|4
CREATE TABLE sp18favpets AS
  SELECT pet, count(*) FROM students GROUP BY pet ORDER BY count(*) DESC, pet LIMIT 10;
```

How many people marked exactly the word 'dog' as their ideal pet this semester?

```sqlite
sqlite> SELECT * FROM sp18dog;
dog|47
CREATE TABLE sp18dog AS
  SELECT pet, count(*) FROM students WHERE pet = 'dog';
```

Although close, our query doesn't give us an entirely accurate picture of what people's favorite pets are. For example, `a dog` would not be counted the same as `dog`. ==Let's see how many people actually want a dog this semester by using `LIKE`, which compares substrings.== We can use it inside `WHERE`, as in `WHERE [column_name] LIKE '%[word]%'` to find how many people would like some type of dog.

```sqlite
sqlite> SELECT * from sp18alldogs;
dog|55
CREATE TABLE sp18alldogs AS
  SELECT pet, count(*) FROM students WHERE pet LIKE '%dog%';
```

We can find the student's favorite for any column (try it yourself in the interpreter), but let's go back to our Obedience question. Let's see how many obedient students this semester picked each image of Professor Denero. We can do this by selecting only the rows that have `seven = '7'` then `GROUP BY denero`, and finally we can `COUNT` them.

```sqlite
sqlite> SELECT * FROM obedienceimages LIMIT 5;
7|Image 1|24
7|Image 2|28
7|Image 3|19
7|Image 4|39
7|Image 5|12
CREATE TABLE obedienceimages AS
  SELECT seven, denero, count(*) FROM students WHERE seven = '7' GROUP BY denero;
```

The possibilities are endless, so have fun experimenting!

Use Ok to test your code:

```
python3 ok -q lets-count
```

#### Q8: The Smallest Unique Positive Integer (Part 2)

Now, let's revisit the previous problem of finding the smallest positive integer that anyone chose, and take a closer look at the `COUNT` aggregate.

Write a SQL query that uses the `COUNT` aggregate to create a table that pairs the attribute `smallest` with the number of times it was chosen by a student (this is the aggregation part).

> *Hint:* Think about what attribute you need to `GROUP BY`.

After you've defined your table, you should get something like:

```sqlite
sqlite> SELECT * FROM smallest_int_count LIMIT 25;
1|101
2|13
3|10
4|9
5|5
6|7
7|6
8|3
9|4
10|6
11|5
12|7
13|5
14|3
15|2
16|2
17|11
18|1
19|3
20|1
21|2
22|6
23|12
24|1
25|3
CREATE TABLE smallest_int_count AS
  SELECT smallest, count(*) FROM students GROUP BY smallest ORDER BY smallest;
```

Use Ok to test your code:

```
python3 ok -q smallest-int-count
```

It looks like the number `18` only had one person choose it! Were you the lucky student that put it down?

## hw 12

### Dog Data

In each question below, you will define a new table based on the following tables.

```
CREATE TABLE parents AS
  SELECT "abraham" AS parent, "barack" AS child UNION
  SELECT "abraham"          , "clinton"         UNION
  SELECT "delano"           , "herbert"         UNION
  SELECT "fillmore"         , "abraham"         UNION
  SELECT "fillmore"         , "delano"          UNION
  SELECT "fillmore"         , "grover"          UNION
  SELECT "eisenhower"       , "fillmore";

CREATE TABLE dogs AS
  SELECT "abraham" AS name, "long" AS fur, 26 AS height UNION
  SELECT "barack"         , "short"      , 52           UNION
  SELECT "clinton"        , "long"       , 47           UNION
  SELECT "delano"         , "long"       , 46           UNION
  SELECT "eisenhower"     , "short"      , 35           UNION
  SELECT "fillmore"       , "curly"      , 32           UNION
  SELECT "grover"         , "short"      , 28           UNION
  SELECT "herbert"        , "curly"      , 31;

CREATE TABLE sizes AS
  SELECT "toy" AS size, 24 AS min, 28 AS max UNION
  SELECT "mini"       , 28       , 35        UNION
  SELECT "medium"     , 35       , 45        UNION
  SELECT "standard"   , 45       , 60;
```

Your tables should still perform correctly even if the values in these tables change. For example, if you are asked to list all dogs with a name that starts with h, you should write:

```
SELECT name FROM dogs WHERE "h" <= name AND name < "i";
```

Instead of assuming that the `dogs` table has only the data above and writing

```
SELECT "herbert";
```

The former query would still be correct if the name `grover` were changed to `hoover` or a row was added with the name `harry`.

#### Q1: Size of Dogs

The F√©d√©ration Cynologique Internationale classifies a standard poodle as over 45 cm and up to 60 cm. The `sizes` table describes this and other such classifications, where a dog must be over the `min` and less than or equal to the `max` in height to qualify as a `size`.

Create a `size_of_dogs` table with two columns, one for each dog's `name` and another for its `size`.

```sqlite
-- The size of each dog
CREATE TABLE size_of_dogs AS
  SELECT name, size from dogs, sizes
  WHERE height <= max and height > min;

-- Example:
SELECT name FROM size_of_dogs WHERE size="toy" OR size="mini";
-- Expected output:
--   abraham
--   eisenhower
--   fillmore
--   grover
--   herbert
```

Use Ok to test your code:

```
python3 ok -q small
```

#### Q2: By Height

Create a table `by_height` that has a column of the names of all dogs that have a `parent`, ordered by the height of the parent from tallest parent to shortest parent.

```sqlite
-- All dogs with parents ordered by decreasing height of their parent
CREATE TABLE by_height AS
  SELECT child FROM parents, dogs WHERE parent = name ORDER BY -height;
```

For example, `fillmore` has a parent (`eisenhower`) with height 35, and so should appear before `grover` who has a parent (`fillmore`) with height 32. The names of dogs with parents of the same height should appear together in any order. For example, `barack` and `clinton` should both appear at the end, but either one can come before the other.

```
-- Example:
SELECT * FROM by_height;
-- Expected output:
--   herbert
--   fillmore
--   abraham
--   delano
--   grover
--   barack
--   clinton
```

Use Ok to test your code:

```
python3 ok -q parent-height
```

#### Q3: Sentences

Create a single string for every pair of siblings that have the same size. Each value should be a sentence describing the siblings by their size, as shown in the expected output below.

```sqlite
CREATE TABLE siblings AS
  SELECT a.child as s1, b.child as s2, c.size FROM parents as a, parents as b, size_of_dogs as c, size_of_dogs as d
   WHERE a.parent = b.parent AND a.child < b.child and c.name = a.child and d.name = b.child and c.size = d.size;

-- Sentences about siblings that are the same size
CREATE TABLE sentences AS
  SELECT s1 || " " || "and" || " " ||  s2 || " " || "are" || " " || size || " " || "siblings" FROM siblings;
```

Each sibling pair should appear only once in the output.

Make sure to list the siblings in each row in alphabetical order (that is, "barack and clinton..." instead of "clinton and barack..." for example).

```
-- Example:
SELECT * FROM sentences;
-- Expected output:
--   barack and clinton are standard siblings
--   abraham and grover are toy siblings
```

> **Hint**: First create a table of siblings (we have provided a basic skeleton for you). Comparing the size of siblings will be simplified.
>
> **Hint**: If you join a table with itself, use `AS` within the `FROM` clause to give each table an alias.
>
> **Hint**: In order to concatenate two strings into one, use the `||` operator.

Use Ok to test your code:

```
python3 ok -q size-siblings
```

#### Q4: Stacks ‚≠ê

<font color = pink>ÊòØÊö¥ÂäõÂÅöÊ≥ïÔºåÁõ¥Êé•Âõõ‰∏™joinÁÑ∂ÂêéÊåëÁ¨¶ÂêàÊù°‰ª∂ÁöÑ„ÄÇÊ≤°ÁúãÊáÇÈ¢òÁõÆÁªôÁöÑhintÊòØ‰ªÄ‰πàÊÑèÊÄù„ÄÇ</font>

Sufficiently sure-footed dogs can stand on either other's backs to form a stack (up to a point). We'll say that the total height of such a stack is the sum of the heights of the dogs.

Create a two-column table describing **all stacks of up to four dogs at least 170 cm high.** The first column should contain a comma-separated list of dogs in the stack, and the second column should contain the total height of the stack. Order the stacks in increasing order of total height.

```sqlite
-- Ways to stack 4 dogs to a height of at least 170, ordered by total height
CREATE TABLE stacks_helper(dogs, stack_height, last_height);

-- Add your INSERT INTOs here

CREATE TABLE stacks AS
  SELECT a.name || "," || " " || b.name || "," || " " || c.name || "," || " " || d.name, (a.height + b.height + c.height + d.height) AS stack_height FROM dogs AS a, dogs AS b, dogs AS c, dogs AS d
  WHERE a.height < b.height AND b.height < c.height AND c.height < d.height AND stack_height >= 170 ORDER BY stack_height;
```

A valid stack of dogs includes each dog only once, and the dogs should be listed in increasing order of height within the stack. **Assume that no two dogs have the same height**.

```
-- Example:
SELECT * FROM stacks;
-- Expected output:
--   abraham, delano, clinton, barack|171
--   grover, delano, clinton, barack|173
--   herbert, delano, clinton, barack|176
--   fillmore, delano, clinton, barack|177
--   eisenhower, delano, clinton, barack|180
```

We recommend using the following procedure to create your table:

1. Start with the provided empty `stack_helper` table. This will store all the stacks of dogs as a comma separated list, **along with the total height and the height of the last dog added in order to ensure we have the right order in the stack**.

2. Use an `INSERT INTO` to initialize `stack_helper` with stacks of just one dog. You may find the following syntax helpful for inserting rows into a table from another table:

   ```
   sqlite> CREATE TABLE ints AS
      ...>   SELECT 1 AS n UNION
      ...>   SELECT 2      UNION
      ...>   SELECT 3;
   sqlite> INSERT INTO ints(n) SELECT n+3 FROM ints;
   sqlite> SELECT * FROM ints;
   1
   2
   3
   4
   5
   6
   ```

3. Now, use the stacks of one dog to insert stacks of two dogs. **Repeat this process** until you have stacks of up to four dogs.

4. Remember to fill in the `stacks` table to use your results from `stack_helper`!

> **Hint**: Generating the comma-separated list of dogs is easier if you start with no commas for one dog.

Use Ok to test your code:

```
python3 ok -q stack
```

## Lab 13: Final Review

### Required Questions

### Scheme

For a quick refresher on Scheme, see [Lab 09](https://inst.eecs.berkeley.edu/~cs61a/sp18/lab/lab09).

> This question is to be done in `lab13.scm`.

#### Q1: Compose All

Implement `compose-all`, which takes a list of one-argument functions and returns a one-argument function that applies each function in that list in turn to its argument. For example, if `func` is the result of calling `compose-all` on a list of functions `(f g h)`, then `(func x)` should be equivalent to the result of calling `(h (g (f x)))`.

```scheme
scm> (define (square x) (* x x))
square
scm> (define (add-one x) (+ x 1))
add-one
scm> (define (double x) (* x 2))
double
scm> (define composed (compose-all (list double square add-one)))
composed
scm> (composed 1)
5
scm> (composed 2)
17

; Q1
(define (compose-all funcs)
  (define (helper x funcs)
          (if (null? funcs) x (helper ((car funcs) x) (cdr funcs)))
  )
  (lambda (x) (helper x funcs))
)
```

Use Ok to test your code:

```
python3 ok -q compose-all
```

<font color = pink>ÊÉ≥‰∫Ü‰∏Ä‰ºöÂÑøÔºå‰ΩÜÊòØÂÅöÂá∫Êù•‰∫Ü„ÄÇËÅ™ÊòéÁöÑÊàë„ÄÇ</font>

### Tail Recursion

For a quick refresher on tail recursion, see [Discussion 8](https://inst.eecs.berkeley.edu/~cs61a/sp18/disc/disc08.pdf#page=5).

> This question is to be done in `lab13.scm`.

#### Q2: Replicate

Write a tail-recursive function that returns a list with `x` repeated `n` times.

```scheme
scm> (tail-replicate 3 10)
(3 3 3 3 3 3 3 3 3 3)
scm> (tail-replicate 5 0)
()
scm> (tail-replicate 100 5)
(100 100 100 100 100)

(define (tail-replicate x n)
  (define (helper x n result)
         (if (= n 0) result
             (helper x (- n 1) (cons x result)))
  )
  (helper x n nil)
)
```

Use Ok to test your code:

```
python3 ok -q tail-replicate
```

### Generators 

For a quick refresher on generators, see [Lab 11](https://inst.eecs.berkeley.edu/~cs61a/sp18/lab/lab11).

> This question is to be done in `lab13.py`.

#### Q3: Generate Permutations ‚≠ê‚≠ê‚≠ê

Given a list of unique elements, a *permutation* of the list is a reordering of the elements. For example, `[2, 1, 3]`, `[1, 3, 2]`, and `[3, 2, 1]` are all permutations of the list `[1, 2, 3]`.

Implement `permutations`, a generator function that takes in a `lst` and outputs all permutations of `lst`, each as a list (see doctest for an example). The order in which you generate permutations is irrelevant.

> **Hint:** If you had the permutations of `lst` minus one element, how could you use that to generate the permutations of the full `lst`?

> Note that in the provided code, the `return` statement acts like a `raise StopIteration`. ==The point of this is so that the returned generator doesn't enter the rest of the body on any calls to `next` after the first if the input list is empty.== Note that this `return` statement does not affect the fact that the function will still return a generator object because the body contains `yield` statements.

```python
def permutations(lst):
    """Generates all permutations of sequence LST. Each permutation is a
    list of the elements in LST in a different order.

    The order of the permutations does not matter.

    >>> sorted(permutations([1, 2, 3]))
    [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]
    >>> type(permutations([1, 2, 3]))
    <class 'generator'>
    >>> sorted(permutations((10, 20, 30)))
    [[10, 20, 30], [10, 30, 20], [20, 10, 30], [20, 30, 10], [30, 10, 20], [30, 20, 10]]
    >>> sorted(permutations("ab"))
    [['a', 'b'], ['b', 'a']]
    """
    if not lst:
        yield []
        return
    "*** YOUR CODE HERE ***"
    for perm in permutations([x for x in lst if x != lst[0]]):
        for k in range(len(perm) + 1):
            yield perm[:k] + [lst[0]] + perm[k:]
```

<font color = pink>Â¶ÇÊûú‰∏çÂÜôÊàêgeneratorÔºåÂ∞±ÊòØ‰∏ãÈù¢ËøôÊ†∑Ôºö</font>

```python
def permutation(list, ans = []):
    if len(list) == 0:
        print(ans)
    for i in list:
        tempans = ans + [i]
        temp = list[:]
        temp.remove(i)
        permutation(temp, tempans)
```

Use Ok to test your code:

```
python3 ok -q permutations
```

### Optional Questions

#### Streams

For a quick refresher on streams, see [Discussion 9](https://inst.eecs.berkeley.edu/~cs61a/sp18/disc/disc09.pdf#page=5).

> This question is to be done in `lab13_extra.scm`.

#### Q4: Run-Length Encoding

Run-length encoding is a very simple **data compression technique**, ==whereby runs of data are compressed and stored as a single value==. A *run* is defined to be a contiguous sequence of the same number. For example, in the (finite) sequence

```
1, 1, 1, 1, 1, 6, 6, 6, 6, 2, 5, 5, 5
```

there are four runs: one each of 1, 6, 2, and 5. We can represent the same sequence as a sequence of two-element lists:

```
(1 5), (6 4), (2 1), (5 3)
```

Notice that the first element of each list is the number in a run, and the second element is the number of of times that number appears in the run.

==We will extend this idea to streams.== Write a function called `rle` that takes in a stream of data, and returns a corresponding stream of two-element lists, which represents the run-length encoded version of the stream. You do not have to consider compressing infinite runs.

```scheme
scm> (define s (cons-stream 1 (cons-stream 1 (cons-stream 2 nil))))
s
scm> (define encoding (rle s))
encoding
scm> (car encoding)  ; Run of number 1 of length 2
(1 2)
scm> (car (cdr-stream encoding))  ; Run of number 2 of length 1
(2 1)
scm> (stream-to-list (rle (list-to-stream '(1 1 2 2 2 3))))  ; See functions at bottom of lab13.scm
((1 2) (2 3) (3 1))

(define (rle s)
  (define (helper s value count)
           (cond ((null? s) (cons-stream (cons value (cons count nil)) nil))
                 ((= value (car s)) (helper (cdr-stream s) value (+ 1 count)))
                 (else (cons-stream (cons value (cons count nil)) (helper (cdr-stream s) (car s) 1)))
           )
  )
  (if (null? s) nil (helper (cdr-stream s) (car s) 1))
)
```

Use Ok to test your code:

```
python3 ok -q rle
```

<font color = pink>ÊúâÁÇπÈöæÈöæÔºåÂØπstreamÂÖ∂ÂÆûËøò‰∏çÂ§™ÁÜüÊÇâ„ÄÇ</font>

#### More Tail Recursion

> This question is to be done in `lab13_extra.scm`.

#### Q5: Insert 

Write **a tail-recursive function** that inserts a number `n` into a non-empty sorted list of numbers, `s`.

> *Hint:* Use the built-in Scheme function `append` to concatenate two lists together.
>
> ```
> scm> (append '(1 2) '(3 4))
> (1 2 3 4)
> scm> (append '(2 4 6) '())
> (2 4 6)
> scm> (append '() '(5 3 1))
> (5 3 1)
> ```

```scheme
scm> (insert 1 '(2))
(1 2)
scm> (insert 5 '(2 4 6 8))
(2 4 5 6 8)
scm> (insert 1000 '(1 2 3 4 5 6))
(1 2 3 4 5 6 1000)
; ËøôÊòØÂæàËá™ÁÑ∂ÁöÑËÉΩÊÉ≥Âà∞ÁöÑrecursion
(define (insert n s)
    (cond ((null? s) (list n))
        ((< n (car s)) (append (list n) s))
        (else (append (list (car s)) (insert n (cdr s))))
  )
)
; ËøôÊòØÈ¢òÁõÆË¶ÅÊ±ÇÁöÑtail recursion
(define (insert n s)
  (define (helper n s r)
          (cond ((null? s) (append r (list n)))
                ((< n (car s)) (append r (list n) s))
                (else (helper n (cdr s) (append r (list (car s)))))
          )
  )
  (helper n s nil)
)
```

Use Ok to test your code:

```
python3 ok -q insert
```

> The Ok tests for this problem don't check whether your solution is tail-recursive! In order to check your understanding, you can run some manual tests with large input such as the following to ensure that your function use a constant number of frames:
>
> ```
> scm> (define big-list (tail-replicate 3 1000))
> big-list
> scm> (define result (insert 4 big-list))
> result
> scm> (define expected (append big-list (list 4)))
> expected
> scm> (equal? result expected)
> True
> ```

#### More Scheme

> These questions are to be done in `lab13_extra.scm`.

#### Q6: Deep Map

Write the function `deep-map`, which takes a function `fn` and a nested list `s`. A nested list is a list where each element is either a number or a list (e.g. `(1 (2) 3)` where `1`, `(2)`, and `3` are the elements). It returns a list with identical structure to `s`, but replacing each non-list element by the result of applying `fn` on it, even for elements within sub-lists. For example:

```
scm> (define (double x) (* 2 x))
double
scm> (deep-map double '(2 (3 4)))
(4 (6 8))
```

Assume that the input has no dotted (malformed) lists.

> *Hint*: You can use the function `list?`, which checks if a value is a list.

```scheme
(define (deep-map fn s)
  (cond ((null? s) nil)
        ((list? (car s)) (cons (deep-map fn (car s)) (deep-map fn (cdr s))))
        (else (cons (fn (car s)) (deep-map fn (cdr s))))
  )
)
```

<font color = pink>Êú∫Êô∫È•º‰ªîÔºåÁÜüÁªÉÂÅöÈ¢òÔºåÂæàÂø´Â∞±pass‰∫ÜÔºåÁúüËÅ™ÊòéÔºÅ</font>

Use Ok to test your code:

```
python3 ok -q deep-map
```

#### Q7: Tally

Implement `tally`, which takes a list of `names` and returns a list of pairs, one pair for each unique name in `names`. Each pair should contain a name and the number of times that the name appeared in `names`. Each name should appear only once in the output, and the names should be ordered by when they first appear in `names`.

*Hint*: Use the `eq?` procedure to test if two names are the same.

```scheme
scm> (tally '(james jen jemin john))
((james . 1) (jen . 1) (jemin . 1) (john . 1))
scm> (tally '(billy billy bob billy bob billy bob))
((billy . 4) (bob . 3))
scm> (tally '())
()
(define (tally names)
  'YOUR-CODE-HERE
  nil
)
```

*Hint*: If you find the procedure getting too complicated, you may want to try implementing the `count` and `unique` helper procedures to use in your solution. You may also want to use `map` and `filter` in your solution.

```scheme
; Implementing and using these helper procedures is optional. You are allowed
; to delete them.
(define (unique s name)
  'YOUR-CODE-HERE
  (filter (lambda (x) (not (eq? x name))) s)
)

(define (count name s)
  'YOUR-CODE-HERE
  (if (null? s)
      0
      (if (eq? (car s) name)
          (+ 1 (count name (cdr s)))
          (count name (cdr s))))
)

(define (tally names)
  'YOUR-CODE-HERE
  (if (null? names)
      nil
      (cons (cons (car names) (count (car names) names)) (tally (unique names (car names)))))
)
```

Use Ok to test your code:

```
python3 ok -q tally
```

<font color = pink>Ê≤°ÂÜôÂá∫Êù•ÔºåÂÜô‰∫Ü‰∏Ä‰∏™Â§öÂ∞èÊó∂ÁÉ¶ÁÇ∏‰∫ÜÔºåÁúã‰∫Ügithub‰∏äÁöÑÁ≠îÊ°à„ÄÇ</font>

#### More Generators

> This question is to be done in `lab13_extra.py`.

#### Q8: Generators generator

Write the generator function `make_generators_generator`, which takes **a zero-argument generator function `g`** and returns a generator that yields generators. For each element `e` yielded by the generator object returned by calling `g`, a new generator object is yielded that will generate items 1 through `e` yielded by the generator returned by `g`.

```python
def make_generators_generator(g):
    """Generates all the "sub"-generators of the generator returned by
    the generator function g.

    >>> def ints_to(n):
    ...     for i in range(1, n + 1):
    ...          yield i
    ...
    >>> def ints_to_5():
    ...     for item in ints_to(5):
    ...         yield item
    ...
    >>> for gen in make_generators_generator(ints_to_5):
    ...     print("Next Generator:")
    ...     for item in gen:
    ...         print(item)
    ...
    Next Generator:
    1
    Next Generator:
    1
    2
    Next Generator:
    1
    2
    3
    Next Generator:
    1
    2
    3
    4
    Next Generator:
    1
    2
    3
    4
    5
    """
    "*** YOUR CODE HERE ***"
    def part_g(n):
        for i in range(1, n + 1):
            yield i
    whole_g = g()
    try:
        while True:
            yield part_g(next(whole_g))
    except StopIteration:
        pass
```

Use Ok to test your code:

```
python3 ok -q make_generators_generator
```

<font color = pink>ËÅ™ÊòéÈ•º‰ªîÔºåÊìÖÈïøËõáËõá„ÄÇÂìàÂìà„ÄÇ</font>