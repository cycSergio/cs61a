#  Python Crash Course：从入门到实践

## 第一部分 基础知识

### 第1章 起步、变量和简单数据类型 

#### 1.1 运行 hello_world.py时发生的情况

末尾的.py指出，这是一个Python程序，因此编辑器将使用Python解释器来运行它。

#### 1.2 变量

- 变量的命名、使用（在使用变量==之前==别忘了给它先赋值）

- ==字符串==的修改、拼接、制表符&换行符删除空白

  ##### 1 修改字符串

  ```python
  # 使用Methods来修改字符串的大小写
  name = 'peter with ruby'
  print(name.title())
  '''
  在print()语句中，方法title()出现在变量name的后面。方法的英文是method，它是Python可以对数据所执行的操作。
  The dot (.) after name in name.title() tells Python to make the title() method act on the variable name.
  每个方法后面都跟着一对括号，这是因为方法通常需要额外的信息来完成其工作。这种信息通常在括号内提供。
  The title() function doesn’t need any additional information, so its parentheses are empty. 
  '''
  # print(name.upper()) 将字符串改为全部大写
  # print(name.lower()) 将字符串改为全部小写 
  '''
  存储数据时，方法lower()很有用的噢。因为很多时候，你无法依靠用户来提供正确的大小写，因此你需要将字符串先转换为小写，再存储他它们。以后需要显示这些信息的时候，再将其转化为最合适的大小写方式。
  '''
  ```

  ##### 2 合并（拼接）字符串 

  Python使用加号（+）来合并字符串，这一方式叫==拼接==。

  ```python
  first_name = 'peter'
  last_name = 'chen'
  full_name = first_name + ' ' + last_name  # 使用拼接来创建完整的信息
  print('Hello,' + full_name.title() + '!')
  ```

  ##### 3 制表符&换行符

  在编程中，==空白==泛指任何非打印字符，如空格、制表符（\t）和换行符（\n）。你可以使用空白来组织输出，让它更容易读懂。

  ```python
  >>>print('Python')
  Python
  >>>print('\tPython')
     Python
  >>>print('Languages:\nPython\nC\nJavascript')
  Languages:
  Python
  C
  Javascript
  >>>print('Languages:\n\tPython\n\tC\n\tJavascript')  # 还可以在同一个字符串中同时使用制表符和换行符噢！
  #Languages:
  #   Python
  #   C
  #   Javascript
  ```

  ##### 4 删除空白 

  在程序中，额外的空白可能零人迷惑，😵。对人类来说，'Python' 和 'Python ' 看起来没什么两样，但是对于程序来说，Python能够发现 'Python ' 中额外的空白，并且认为它是有意义的 —— 除非你告诉它不是这样的！

  Python能够找出字符串开头和末尾多余的空白，有3种方法，rstrip(), strip(), lstrip(). 但是这些方法对于空格的删除是==暂时的==，再次访问原先的变量时，你会发现它的值没有被改变，依然包含多余的空白。要永久删除多余的空格，你需要把删除后的结果再次存储回变量中，如下：

  ```python
  favorite_language = ' python '
  favorite_languate = favorite_language.strip()
  '''
  在实际程序中，这些剥除函数最常用于，在存储用户输入之前，先对其进行清理。
  '''
  ```

  ##### 5 print语句相关

- ==数字==：整数、浮点数、避免类型错误

- 注释

- the Zen of Python (Python之禅)

### 第2章 列表简介、操作列表 

在这一章中，你将学习如何在==列表==中存储信息，以及如何通过遍历列表来操作其中的数据。

#### 2.1 列表是什么 

==列表==是新手可以直接使用的最强大的Python功能之一，它融合了众多**重要的编程概念**。

In Python, square brackets ([]) indicate a list, and individual elements  in the list are separated by commas. 

列表是一种 sequence, 是有序集合，它有两个特征：①能够知道它的长度，length；②能够访问其中的元素，element selection。

通常，可以用==索引==来访问列表中的元素。注意索引从0开始，而-1表示返回最后一个元素，索引-2表示返回倒数第二个，以此类推。

#### 2.2 修改、添加和删除元素 

你创建的大多数列表都将是==动态==的，这意味着列表创建后，将随着程需的运行而增删相应的元素。

##### 2.2.1 修改列表元素

这与访问列表元素的语法**类似**，要修改列表元素，你可以指定列表的名字和要修改的元素的索引，再指定该元素的新值。

```python
lst = [1, 1, 3]
lst[2] = 1 # 这就是在修改列表元素了噢。

```

##### 2.2.2 在列表中添加元素

1. 在列表末尾添加元素

   ```python
   lst = [1, 1, 3]
   lst.append(30)
   '''
   方法append()将元素30添加到了列表lst的末尾，并且不影响到列表中的其他所有元素。
   你可以先创建一个空列表，再使用一系列的append()语句添加元素。这种创建列表的方式极其常见，因为经常要等到程序运行后，你才知道用户要在程序中存储哪些数据。为了控制用户，可以先创建一个空列表，用于存储用户将要输入的值，然后将用户提供的每个新值附加到列表中来。
   '''
   ```

2. 在列表中间插入元素

   使用方法insert()可以在列表的**任何位置**添加新元素，为此，你需要指定新元素的索引和值。

   ```python
   lst = [1,1,1]
   lst.insert(0, 10)
   
   ```

##### 2.2.3 从列表中删除元素

1. 使用==del语句==删除元素

   使用del语句可以删除任何位置处的列表元素，**条件**是你要知道其索引。并且，使用del语句把值从列表中删除以后，你就无法再访问它了。

   ```python
   del lst[0]
   ```

   

2. 使用==方法pop()==删除元素

   有时候，你需要把某个元素从列表中删除，并且接着使用这个元素的值！方法pop()可删除列表末尾的元素，并且让你可以接着使用它。它会给你弹出你删掉的那个元素。

   ![image-20220122230139292](C:\Users\cyc\AppData\Roaming\Typora\typora-user-images\image-20220122230139292.png)

   ```python
   popped = lst.pop()
   print(popped)
   print(lst)
   ```

   

3. ==弹出==列表中==任何位置==处的元素

   事实上，你可以使用方法pop()来删除列表中==任意位置==的元素，只需要在括号中指定要删除元素的索引即可。

   ```python
   popped1 = lst.pop(1)
   print(popped1)
   print(lst)
   ```

   也别忘了，每当你使用pop()时，被弹出的元素同样也不在原先的列表中了。

   如果你**不确定**应该使用del语句还是pop()方法，有一个简单的判断标准：如果你要从列表中删除一个元素，且不再以任何方式使用它，就使用del语句；如果你要在删除元素后还能继续使用它，就使用方法pop().

4. 根据值删除元素

   有时候，你不知道要从列表中删除的值的索引，只是到你要删除的元素的值，可使用方法remove()，只要指出你要删掉的值就可以了。比如：

   ```python
   lst.remove(10)
   ```

   但是要注意，方法remove()只删除==第一个==指定的值。如果要删除的值可能在列表中出现多次，就需要使用==循环==来判断是否删除了所有这样的值。（会在循环那一章学到哈）

#### 2.3 组织列表 ，也就是排序

##### 2.3.1 使用方法sort()对列表进行永久性排序 

方法sort()会按照字母排序、永久性地修改列表元素的排列。如果要反向排列，就向sort()方法传递参数reverse = True 即可。

```python
cars.sort()
cars.sort(reverse = True)
```



##### 2.3.2 使用函数sorted()对列表进行临时排序 

如果你想保留列表元素==原来的==排列顺序，同时以特定的顺序呈现它们，可以使用函数sorted()。<font color = pink>Q1: 这里突然有一个问题，函数和方法有什么区别呢？方法前面有dot？</font>

函数sorted()让你能够按照特定顺序显示列表元素，同时不影响它们在列表中的原始排列顺序。若要反向排序，也可以向函数sorted()传递参数reverse = True

```python
print(sorted(cars))
```

##### 2.3.3 倒着打印列表 

要反转列表元素，使用方法reverse(). 这一改变是永久性的，但是你可以随时把它恢复原样，只要再对列表调用reverse()即可，哈哈哈。

```python
cars.reverse()
```

##### 2.3.4 确定列表的长度

就是用函数len()啊。

#### 2.4 使用列表时避免索引错误 

在访问列表元素的时候，发生索引错误是很常见的。在程需对其进行了==动态处理==的时候尤其如此，你可以检查一下最后是不是变成空列表了、想想这时候要怎么办。

以上是关于列表的基础操作，接下来，你将学习如何以**更高效**（其实就是指==遍历==）的方式处理列表元素。

#### 2.5 遍历整个列表 

你经常需要遍历（==遍历==是很重要的概念，因为它是让计算机自动完成重复工作的常见方式之一）列表的所有元素，对每个元素执行相同的操作。

在 for i in lst: 中，i是用于存储列表lst中每个元素值的**临时变量**。for循环后面有缩进的代码都会反复执行，直到列表中所有元素都遍历结束哈。

要正确缩进哦，通过缩进你也可以一眼看出程序的大致组织结构。

#### 2.6 创建数值列表 

列表非常适合于存储数字集合，而Python提供了很多工具，可以帮助你高效地处理数字列表。

##### 2.6.1 使用函数range() 

range()可以作为for循环header中的范围；也可以通过list()把range中的元素转换在一个列表之中，比如list(range(1,6))

在使用函数range()的时候，还可以指定步长。比如 list(range(2,11,2))，最后就是一个包含偶数的列表。

使用函数range()==几乎能够创建任何你需要的数字集==：例如你想将前10个整数的平方加入到一个列表中：

```python
squares = []
for value in range(1, 11):
    square = value ** 2
    squares.append[square]
# append好好用啊，好例子！
```

然后也可以用min(), max(), sum()等函数对数字列表进行简单的**统计计算**哈。

##### 2.6.2 list comprehension 

list comprehension 将 for 循环和创建新元素的代码合并==成一行==，并自动附加新元素。

```python
squares = [value ** 2 for value in range(1, 11)]
```



#### 2.7 使用列表的一部分 

在前面，我们学习了如何访问单个列表元素、如何遍历列表的所有元素。现在，我们还可以处理列表的部分元素——Python称之为==切片==。

##### 2.7.1 切片

```python
lst[0 : 3]
lst[: 5] # 如果你没有指定第一个索引，Python将自动从列表从头开始提取
lst[-3 :] # 前面说过，-3 索引返回倒数第三个元素，所以这里会返回列表末尾的最后3个元素。
```



##### 2.7.2 复制列表

你经常需要根据既有列表来创建全新的列表。

要复制列表，可以创建一个包含整个列表的切片，方法是==同时省略==起始索引和终止索引，[ : ].

```python
my_foods = ['aa','bb','cc']
friend_foods = my_foods[ : ]
friend_foods = my_foods
'''
比较上面两行的不同。
如果只是简单的 friend_foods = my_foods，那么这两个变量其实指向同一个列表。你一旦修改了其中一个，另一个也是会变的。
'''
```



#### 2.8 元组 

列表是可以修改的，所以非常适合用于存储在程序运行期间可能变化的数据集。然而，有时候你需要创建一系列不可修改的元素——==元组==。

元组使用圆括号，也可以使用索引来访问其中的元素。但是，你==不能修改==其中的元素。

像列表一样，也可以使用for循环来遍历元组中的所有元素。

如果你想修改，那你只能重新定义整个元组，把原来元组的名称bound to新值。

总之，相比于列表，元组是更简单的数据结构。如果需要存储的一组值在程序的整个生命周期内都不改变，那么可以使用元组。

### 第3章 if语句 

每条 if 语句的核心都是一个值为True或False的表达式，这种表达式称为条件测试。Python根据条件测试的值为True还是False来决定是否执行 if 语句中的代码。

Python是区分大小写的。

然后，我们编写的大多数条件表达式都是检查两个值是否相等，但是有时候检查两个值是否不等的效率更高。

然后，如果想要同时检查多个条件，那么可以借助关键字 and 和 or。

也可以检查特定值是否包含或者不包含在列表中。

if 语句的结构：单个 if 语句；if-elif-else 结构

值得注意的是，Python并不要求 if-elif 结构后面必须有 else 代码块哦。在有些情况下，else 代码块很有用；不过在有些情况下，使用一条 elif 语句来处理特定情形会更清晰一些。因为else是一条保罗万象的语句，只要不满足任何 if 或则和 elif 中的条件测试，else 中的代码就会执行，而这可能会让你引入无效甚至恶意的数据。如果你知道最终要测试的条件，应该考虑使用一个 elif 代码块来代替 else 代码块。这样，你就可以肯定，仅当满足相应的条件时，你的代码才会执行。

在使用 if 语句时，一个需要特别关注的问题是==测试多个条件==？？的时候：

if-elif-else结构功能强大，但是仅适合用于只有一个条件满足的情况：遇到通过了的条件测试后，Python就会跳过余下的测试。这种行为很好，效率很高，让你能够测试一个特定的条件。**然而**，有时候你必须检查你关心的所有条件，在这一情况下，应该使用一系列不包含elif和else的代码块的简单if语句。在可能有多个条件为True，并且你需要在每个条件为True时都采取相应的举措时，就适合采用这种方法。

### 第4章 字典 

在本章，会学习如何访问和修改字典中的信息、如何遍历字典中的数据（==字典可存储的信息量几乎不受限制==）、存储字典的列表/存储列表的字典/存储字典的字典。

理解字典后，**你就能够更准确地为各种真实物体建模**。你可以创建一个表示人物的字典，然后想在其中存储多少信息就存储多少信息：姓名、年龄、地址、职业以及你想要描述的任何方面。你还能够存储任意两种相关的信息，如一系列单词及其含义、一系列山脉及其海拔。

与大多数编程概念一样，要熟练使用字典，也需要一段时间的练习。使用字典一段时间后，你就会明白为何它们能够**高效地模拟现实世界中的情形**。

#### 4.1 字典的基本知识，访问、修改、删除和遍历字典etc

可以将任何Python对象用作字典中的值（value）。

可以把key放在[]来获取这个key所对应的value值。

可以修改key的value或者添加key-value pairs。

对于字典中不再需要的信息，可以使用 del 语句将相应的key-value pair 彻底删除。使用del语句时，需要指定字典的名字和要删除的key。

有多种遍历字典的方式：所有key-value pair、所有key、所有value。比如我有一个已经定义好的字典 dict：

可以使用一个for循环来遍历这个字典—— for key, value in dict.items():。需要注意的是，即便遍历字典时，键值对的返回顺序也与==存储顺序==不一样哦，因为Python不关心键值对的存储顺序，而只跟踪键和值之间的关联关系。

可以使用 for value in dict.values(): 来遍历这个字典中的所有值

可以使用 for value in dict.keys(): 来遍历这个字典中的所有键；然后，可以注意一下，遍历字典时，==会默认是在遍历所有的key==，所以你也可以把这句code替换为for value in dict():，它同样是在遍历这个字典中的所有key哈。当然，如果显式地使用方法keys（）可以让代码更容易理解，你也可以选择这样做。方法keys（）返回一个列表，其中包含字典的所有键。

#### 4.2 如果你想按照顺序来遍历字典或者想要剔除重复的value值

要以特定的顺序返回元素，一种方法是在for循环中对返回的key进行排序。为此，可以使用函数sorted（）来获得按照特定顺序排列的key列表的副本。比如，for i in sorted(dict.keys()): blabla的。

另外，通过对包含重复元素的列表调用set（），可以让Python找出列表中独一无二的元素，并使用这些元素来创建一个集合。比如，for i in set(dict.values()): 巴拉拉的

#### 4.3 嵌套

有时候，需要将一系列字典存储在列表中，或者将列表作为值存储在字典中，这称为嵌套。嵌套是一项强大的功能。

- 把一系列字典存储在列表中：我们经常需要在列表中包含大量的字典，而其中每个字典都包含特定对象的众多信息。例如，你可能需要为网站的每一个用户创建一个字典，并将这些字典存储在一个名为users的列表中。在这个列表中，**所有字典的结构都相同**，因此你可以==遍历==这个列表，并且以相同的方式处理其中的每个字典。
- 在字典中存储列表：每当需要在字典中将一个key关联到多个value的时候，都可以在字典中嵌套一个列表。在这种情况下，如果我们要遍历这个字典，那我们需要两个for循环来遍历value的列表。比如：

```python
favorite_languages = {
    'jen': ['python', 'ruby'],
    'sarah': ['c'],
    'edward': ['ruby', 'go'],
	}

for name, languages in favorite_languages.items():
    print('\n' + name.title() + "'s favorite languages are:")
    for language in languages: # 在遍历字典的主循环中，我们又使用了一个for循环来遍历每个人喜欢的语言列表。
        print('\t' + language.title())
```

不过还是要注意，**列表和字典的嵌套层级不应该太多**。如果嵌套层级比前面的示例多得多，很可能==有更简单的==解决问题的方案！

- 在字典中存储字典：也可以在字典中嵌套字典，但这样做时，代码可能很快复杂起来。以及，请保证每个内部的小字典结构相同，这样会使得嵌套的字典处理起来更容易哈！

### 第5章 用户输入和while循环 

这一章，将学习while循环以及如何从用户那里获得输入。这是exciting的一章，让你知道如何将程序变成交互性的——能够对用户输入做出响应。



### 第6章 函数 

<font color =pink>打算精读函数这一章，先看一遍中文的，然后再看一遍原版的</font>

需要在程序中多次执行同一项任务时，无需反复编写完成该任务的代码，而只需==调用==执行该任务的函数，让Python运行其中的代码。

此外，你还需学习向函数==传递信息==的方式。你将学习如何编写主要任务时显示信息的函数，还有用于处理数据并返回一个或一组值的函数。

最后，你将学习如何将函数存储在被称为**模块**的独立文件中，让主程序文件的组织更为有序。

#### 6.1 函数的基本概念、基本结构etc的简单知识点

docstring是函数的注释，描述了函数是做什么的。docstring用三引号括起来，Python用它们来**生成**有关程序中函数的文档。

要使用一个函数，可以**调用**它。==函数调用==让Python执行该函数中的代码。调用函数，就是依次指定函数名以及用括号括起来的必要信息。

```python
def greet_user(username):
    """显示简单的问候语"""
    print('Hello,' + username.title() + '!')
    
greet_user('peter')
```

- 形参和实参

  在函数定义过程中，username是一个形参；在调用函数时传进去的参数peter，是实参，调用的时候实参‘Peter’传递给了函数greet_user(username)并将这个值存储在了形参username中哈！

  鉴于函数定义中可以包含多个形参，那么函数调用中也可能包含多个实参。向函数传递实参的方式有很多——**位置实参**、**关键字实参**etc

  - 位置实参：你调用函数的时候，Python必须将函数调用中的每个实参都关联到函数定义中的一个形参。为此，最简单的关联方式是基于函数参数的==顺序==哈。所以在使用位置实参来调用函数时，实参传进去的顺序时很重要的哈。

  - 关键字实参：是指传递给函数参数的时候，直接在实参中把形参的名字和value关联起来，因此不会混淆（意思就是，**我们在调用这个函数的时候，向Python明确地指出了各个实参所对应的形参是哪一个，比如greet_user(username = 'Peter')这样**，函数定义的时候该怎么写还是怎么写）。这一方式让你无需考虑函数调用中的实参顺序，还清楚地指出了函数调用中各个值的用途。

  - 默认值：编写函数时，可以给每个形参指定**默认值**。在调用函数时如果你给形参提供了实参，那Python当然用你这次传进来的值；否则，将使用形参的默认值。因此，给形参指定默认值后，可以在函数调用中省略相应的实参，这样也可以简化函数调用，还可以清楚地指出函数的典型用法。不过注意，在使用默认值时，要在形参列表中先列出**没有默认值的形参**，再列出有默认值的形参，这样才能让Python正确地解读出位置实参哈。

    举个例子，你要获取很多人的名字，需要他们同时提供名、中间名和姓氏作为你的函数的3个参数。不过，因为并非所有的人都有中间名，而如果你调用这个函数时只提供了名和姓氏，那函数就不能正确运行。所以，你可以给中间名这个参数指定一个**默认值**——一个空字符串，从而可以让没有中间名的用户不需要提供这个实参。不过注意，此时**你需要把这个参数移到形参列表的末尾哦**。

- 返回值

  在函数中，可以使用return语句将值返回到调用函数的代码行。返回值让你能够将程序的大部分繁重工作移到函数中取完成，从而简化主程序。 函数可以返回任何类型的值，包括列表和字典等较为复杂的数据结构。

  ​                                                                

  ```python
  def build_person(first_name, last_name, age = ' '):
      """返回一个字典，其中包含有关一个人的信息"""
      person = {'first': first_name, 'last': last_name}
      if age:
          person['age'] = age
      return person
  # 在函数定义中，我们放了一个可选形参age，并将其默认值设置为空字符串。如果函数调用包含这个形参的值，就把这个值添加到字典中进行存储。
  ```

  ​                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 

  ​                      函数这一章看到了319页，感觉while的break在61a里面没学到诶。先看类。

### 第7章 类 

1月24日 正在看denero的2.4video，放一张课件截图在此，感觉很深刻，还不能完全理解：

![image-20220124203253734](C:\Users\cyc\AppData\Roaming\Typora\typora-user-images\image-20220124203253734.png)



> ==面向对象编程==是最有效的软件编写方法之一。在面向对象编程中，你编写表示现实世界中的事物和情景的类，并基于这些类来创建对象。在编写类时，你定义一大类对象都有的通用行为。基于类创建**对象**时，每个对象都自动具备这种通用行为，然后可以根据需要赋予每个对象独特的个性。（怎么赋予独特的个性？）使用面向对象编程可以**模拟**现实情境，其逼真程度达到了令你惊讶的地步。
>
> 根据类来创建对象被称为**实例化**，这让你能够使用类的实例。在本章中，你将编写一些类并创建其实例；你将指定可在实例中存储什么信息，定义可对这些实例执行哪些操作；你还将编写一些类来拓展既有类的功能，让相似的类能够高效地共享代码；你将把自己编写的类存储在模块中，并在自己的程序文件中导入其他程序员编写的类。

#### 7.1 创建和使用类，class  

使用==类==几乎可以模拟任何东西。我们举一个小狗的简单类Dog的例子——它表示的不是特定的小狗，而是任何小狗。在这里，我们认为任何小狗都有这样的通用性质：2个信息（名字、信息）和2种行为（蹲下和打滚）。我们的Dog类将包含这些通用的行为。编写完这个Dog类以后，我们将使用它来创建表示特定小狗的实例。

##### 7.1.1 创建Dog类 

重复一下，根据Dog类创建的每个实例都将存储名字和年龄，同时我们也会赋予每条小狗蹲下（sit（））和打滚（roll_over()）的能力。

```python
class Dog():
    """一次模拟小狗的简单尝试"""
    def __init__(self, name, age): # __init__()是一个特殊的方法，每当你根据Dog类创建新实例时，Python都会自动运行它。
        """初始化属性name和age"""   # 在这个方法的名称中，开头和末尾各有两个下划线，这是一种约定，旨在避免Python默认方法与普通方法发生名称冲突。
        self.name = name
        self.age = age
    
    def sit(self):
        """模拟小狗被命令时蹲下"""
        print(self.name.title() + " is now sitting.")
    
    def roll_over(self):
        """模拟小狗被命令时打滚"""
        print(self.name.title() + " rolled over.")
     
```

啊，只是提醒一句，可能现在你还看不懂上面的code，但是没关系，在这一章里到处是这样的例子，你有大把的机会熟悉它。💪

在方法init（）中，我们定义它包含三个形参：self，name和age。在这个方法的定义中，==形参self==必不可少，还必须位于其他形参的前面。为何必须要在昂发定义中包含self中呢？因为

##### 7.1.2 根据类来创建实例

#### 7.2 使用类和实例 

##### 7.2.1 Car类 

##### 7.2.2 给属性指定默认值 

##### 7.2.3 修改属性的值

#### 7.3 继承 

#### 7.4 导入类 

#### 7.5 Python标准库 

#### 7.6 类编码风格

### 第8章 文件和异常 

### 第9章 测试代码

## 第二部分 项目

### 项目1 外星人入侵

### 项目2 数据可视化 

### 项目3 Web应用程序